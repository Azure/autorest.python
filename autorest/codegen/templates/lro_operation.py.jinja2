{% import 'keywords.jinja2' as keywords with context %}
{% from 'operation_tools.jinja2' import response_handling %}
{% set trace_decorator = "@distributed_trace_async" if async_mode else "@distributed_trace" %}
{% set async_prefix = "Async" if async_mode else "" %}
{% set poller = "async_poller" if async_mode else "LROPoller" %}
{% set operation_name = operation.python_name if async_mode else "begin_"+operation.python_name %}
{% macro method_signature() %}
{% if async_mode %}
async def {{ operation_name }}(
    self,
    {% for param_signature in operation.parameters.async_method_signature %}
    {{ param_signature }},
    {% endfor %}
    {% if operation.parameters.method | first %}
    *,
    {% endif %}
    cls: ClsType[{{ keywords.return_type_annotation(operation) }}] = None,
    polling: Optional[bool] = True,
    **kwargs
){{ keywords.async_return_type_annotation(operation) }}:
{% else %}
def {{ operation_name }}(
    self,
    {% for param_signature in operation.parameters.sync_method_signature %}
    {{ param_signature }}
    {% endfor %}
    cls=None,  # type: ClsType[{{ keywords.return_type_annotation(operation) }}]
    polling=True,  # type: Optional[bool]
    **kwargs  # type: Any
):
{% endif %}{% endmacro %}
{% macro return_docstring() %}
:return: An instance of LROPoller that returns {{ operation.responses[0].schema.name if operation.responses[0].has_body else "None"}}
    :rtype: ~azure.core.polling.LROPoller[{{ operation.responses[0].schema.docstring_type if operation.responses[0].has_body else "None" }}]
{% endmacro %}
{% macro param_documentation_string(parameter) %}:param {{ parameter.serialized_name }}: {{ parameter.description }}{% endmacro %}
{% macro exception_name() %}{{ operation.exceptions[0].schema.name }}Exception{% endmacro %}
{% macro response_headers(response) %}
response_headers = {
    {% for response_header in response.headers %}
    '{{ response_header.name }}': self._deserialize('{{ response_header.schema.get_serialization_type() }}', response.headers.get('{{ response_header.name }}')),
    {% endfor %}
}
{% endmacro %}
{% set lro_options = (", lro_options={'final-state-via': '"+ operation.lro_options['final-state-via'] + "'}") if operation.lro_options else "" %}
{# actual template starts here #}
{% if code_model.options['tracing'] %}
{{ trace_decorator }}
{% endif %}
{{ method_signature() }}
{%- if not async_mode %}
    {{ keywords.sync_return_type_annotation(operation) }}
{% endif %}
    """{{operation.description }}
    {% if operation.summary %}

    {{ operation.summary | wordwrap(width=95, break_long_words=False, wrapstring='\n    ') }}
    {% endif %}

{% if operation.deprecated -%}
    .. warning::
       This method is deprecated

{% endif -%}
{% for parameter in operation.parameters.method %}
    {%- for doc_string in param_documentation_string(parameter).replace('\n', '\n ').split('\n') %}
    {{ doc_string | wordwrap(width=95, break_long_words=False, wrapstring='\n     ')}}
    {% endfor %}
    :type {{ parameter.serialized_name }}: {{ parameter.schema.docstring_type }}
{% endfor %}
    :param callable cls: A custom type or function that will be passed the direct response
    :param polling: True for ARMPolling, False for no polling, or a
     polling object for personal polling strategy
    {{ return_docstring() }}
    {% if not operation.exceptions %}
        {% if code_model.options['azure_arm'] %}
    :raises ~azure.mgmt.core.ARMError:
        {% else %}
    :raises ~azure.core.HttpResponseError:
        {% endif %}
    {% else %}
    :raises ~{{ code_model.namespace }}.models.{{ exception_name() }}:
    {% endif %}
    """
    raw_result = {{ keywords.await }}self._{{ operation.name }}_initial(
        {% for parameter in operation.parameters.method %}
        {{ parameter.serialized_name }}={{ parameter.serialized_name }},
        {% endfor %}
        cls=lambda x,y,z: x,
        **kwargs
    )

    def get_long_running_output(pipeline_response):
        {% if operation.lro_response.has_headers %}
        response_headers = {}
        response = pipeline_response.http_response
        {% endif %}
        {% if operation.lro_response %}
        {{ response_handling(operation.lro_response)|indent(8) }}
        {% endif %}
        if cls:
            return cls(pipeline_response, {{ 'deserialized' if operation.lro_response.has_body else 'None'}}, {{ 'response_headers' if operation.lro_response.has_headers else '{}' }})
        {% if operation.lro_response.has_body %}
        return deserialized
        {% endif %}

    lro_delay = kwargs.get(
        'polling_interval',
        self._config.polling_interval
    )
    if polling is True: polling_method = {{ async_prefix }}ARMPolling(lro_delay{{ lro_options }},  **kwargs)
    elif polling is False: polling_method = {{ async_prefix }}NoPolling()
    else: polling_method = polling
    return {{ keywords.await }}{{ poller }}(self._client, raw_result, get_long_running_output, polling_method)
{{ operation_name }}.metadata = {'url': '{{ operation.url }}'}