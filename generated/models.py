# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
from msrest.serialization import Model

class AccountSasParameters(Model):
    """The parameters to list SAS credentials of a storage account.

    :param signed_services: The signed services accessible with the account SAS. Possible values include: Blob (b), Queue (q), Table (t), File (f).
    :type signed_services: str or Services
    :param signed_resource_types: The signed resource types that are accessible with the account SAS. Service (s): Access to service-level APIs; Container (c): Access to container-level APIs; Object (o): Access to object-level APIs for blobs, queue messages, table entities, and files.
    :type signed_resource_types: str or SignedResourceTypes
    :param signed_permission: The signed permissions for the account SAS. Possible values include: Read (r), Write (w), Delete (d), List (l), Add (a), Create (c), Update (u) and Process (p).
    :type signed_permission: str or Permissions
    :param signed_ip: An IP address or a range of IP addresses from which to accept requests.
    :type signed_ip: str
    :param signed_protocol: The protocol permitted for a request made with the account SAS.
    :type signed_protocol: str or HttpProtocol
    :param signed_start: The time at which the SAS becomes valid.
    :type signed_start: datetime.datetime
    :param signed_expiry: The time at which the shared access signature becomes invalid.
    :type signed_expiry: datetime.datetime
    :param key_to_sign: The key to sign the account SAS token with.
    :type key_to_sign: str
    """

    _attribute_map = {
        'signed_services': {'key': 'signed_services', 'type': 'str'}
        'signed_resource_types': {'key': 'signed_resource_types', 'type': 'str'}
        'signed_permission': {'key': 'signed_permission', 'type': 'str'}
        'signed_ip': {'key': 'signed_ip', 'type': 'str'}
        'signed_protocol': {'key': 'signed_protocol', 'type': 'str'}
        'signed_start': {'key': 'signed_start', 'type': 'datetime.datetime'}
        'signed_expiry': {'key': 'signed_expiry', 'type': 'datetime.datetime'}
        'key_to_sign': {'key': 'key_to_sign', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(AccountSasParameters, self).__init__(**kwargs)
        self.signed_services = kwargs.get('signed_services', None)
        self.signed_resource_types = kwargs.get('signed_resource_types', None)
        self.signed_permission = kwargs.get('signed_permission', None)
        self.signed_ip = kwargs.get('signed_ip', None)
        self.signed_protocol = kwargs.get('signed_protocol', None)
        self.signed_start = kwargs.get('signed_start', None)
        self.signed_expiry = kwargs.get('signed_expiry', None)
        self.key_to_sign = kwargs.get('key_to_sign', None)

class AccountSasParameters(Model):
    """The parameters to list SAS credentials of a storage account.

    :param signed_services: The signed services accessible with the account SAS. Possible values include: Blob (b), Queue (q), Table (t), File (f).
    :type signed_services: str or Services
    :param signed_resource_types: The signed resource types that are accessible with the account SAS. Service (s): Access to service-level APIs; Container (c): Access to container-level APIs; Object (o): Access to object-level APIs for blobs, queue messages, table entities, and files.
    :type signed_resource_types: str or SignedResourceTypes
    :param signed_permission: The signed permissions for the account SAS. Possible values include: Read (r), Write (w), Delete (d), List (l), Add (a), Create (c), Update (u) and Process (p).
    :type signed_permission: str or Permissions
    :param signed_ip: An IP address or a range of IP addresses from which to accept requests.
    :type signed_ip: str
    :param signed_protocol: The protocol permitted for a request made with the account SAS.
    :type signed_protocol: str or HttpProtocol
    :param signed_start: The time at which the SAS becomes valid.
    :type signed_start: datetime.datetime
    :param signed_expiry: The time at which the shared access signature becomes invalid.
    :type signed_expiry: datetime.datetime
    :param key_to_sign: The key to sign the account SAS token with.
    :type key_to_sign: str
    """

    _attribute_map = {
        'signed_services': {'key': 'signed_services', 'type': 'str'}
        'signed_resource_types': {'key': 'signed_resource_types', 'type': 'str'}
        'signed_permission': {'key': 'signed_permission', 'type': 'str'}
        'signed_ip': {'key': 'signed_ip', 'type': 'str'}
        'signed_protocol': {'key': 'signed_protocol', 'type': 'str'}
        'signed_start': {'key': 'signed_start', 'type': 'datetime.datetime'}
        'signed_expiry': {'key': 'signed_expiry', 'type': 'datetime.datetime'}
        'key_to_sign': {'key': 'key_to_sign', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(AccountSasParameters, self).__init__(**kwargs)
        self.signed_services = kwargs.get('signed_services', None)
        self.signed_resource_types = kwargs.get('signed_resource_types', None)
        self.signed_permission = kwargs.get('signed_permission', None)
        self.signed_ip = kwargs.get('signed_ip', None)
        self.signed_protocol = kwargs.get('signed_protocol', None)
        self.signed_start = kwargs.get('signed_start', None)
        self.signed_expiry = kwargs.get('signed_expiry', None)
        self.key_to_sign = kwargs.get('key_to_sign', None)

class AzureEntityResource(Model):
    """The resource model definition for a Azure Resource Manager resource with an etag.

    :param etag: Resource Etag.
    :type etag: str
    """

    _attribute_map = {
        'etag': {'key': 'etag', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(AzureEntityResource, self).__init__(**kwargs)
        self.etag = kwargs.get('etag', None)

class AzureFilesIdentityBasedAuthentication(Model):
    """Settings for Azure Files identity based authentication.

    :param directory_service_options: Indicates the directory service used.
    :type directory_service_options: str or DirectoryServiceOptions
    """

    _attribute_map = {
        'directory_service_options': {'key': 'directory_service_options', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(AzureFilesIdentityBasedAuthentication, self).__init__(**kwargs)
        self.directory_service_options = kwargs.get('directory_service_options', None)

class AzureFilesIdentityBasedAuthentication(Model):
    """Settings for Azure Files identity based authentication.

    :param directory_service_options: Indicates the directory service used.
    :type directory_service_options: str or DirectoryServiceOptions
    """

    _attribute_map = {
        'directory_service_options': {'key': 'directory_service_options', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(AzureFilesIdentityBasedAuthentication, self).__init__(**kwargs)
        self.directory_service_options = kwargs.get('directory_service_options', None)

class CheckNameAvailabilityResult(Model):
    """The CheckNameAvailability operation response.

    :param name_available: Gets a boolean value that indicates whether the name is available for you to use. If true, the name is available. If false, the name has already been taken or is invalid and cannot be used.
    :type name_available: bool
    :param reason: Gets the reason that a storage account name could not be used. The Reason element is only returned if NameAvailable is false.
    :type reason: str or Reason
    :param message: Gets an error message explaining the Reason value in more detail.
    :type message: str
    """

    _attribute_map = {
        'name_available': {'key': 'name_available', 'type': 'bool'}
        'reason': {'key': 'reason', 'type': 'str'}
        'message': {'key': 'message', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(CheckNameAvailabilityResult, self).__init__(**kwargs)
        self.name_available = kwargs.get('name_available', None)
        self.reason = kwargs.get('reason', None)
        self.message = kwargs.get('message', None)

class CheckNameAvailabilityResult(Model):
    """The CheckNameAvailability operation response.

    :param name_available: Gets a boolean value that indicates whether the name is available for you to use. If true, the name is available. If false, the name has already been taken or is invalid and cannot be used.
    :type name_available: bool
    :param reason: Gets the reason that a storage account name could not be used. The Reason element is only returned if NameAvailable is false.
    :type reason: str or Reason
    :param message: Gets an error message explaining the Reason value in more detail.
    :type message: str
    """

    _attribute_map = {
        'name_available': {'key': 'name_available', 'type': 'bool'}
        'reason': {'key': 'reason', 'type': 'str'}
        'message': {'key': 'message', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(CheckNameAvailabilityResult, self).__init__(**kwargs)
        self.name_available = kwargs.get('name_available', None)
        self.reason = kwargs.get('reason', None)
        self.message = kwargs.get('message', None)

class CustomDomain(Model):
    """The custom domain assigned to this storage account. This can be set via Update.

    :param name: Gets or sets the custom domain name assigned to the storage account. Name is the CNAME source.
    :type name: str
    :param use_sub_domain_name: Indicates whether indirect CName validation is enabled. Default value is false. This should only be set on updates.
    :type use_sub_domain_name: bool
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'}
        'use_sub_domain_name': {'key': 'use_sub_domain_name', 'type': 'bool'}
        
    }

    def __init__(self, **kwargs):
        super(CustomDomain, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.use_sub_domain_name = kwargs.get('use_sub_domain_name', None)

class CustomDomain(Model):
    """The custom domain assigned to this storage account. This can be set via Update.

    :param name: Gets or sets the custom domain name assigned to the storage account. Name is the CNAME source.
    :type name: str
    :param use_sub_domain_name: Indicates whether indirect CName validation is enabled. Default value is false. This should only be set on updates.
    :type use_sub_domain_name: bool
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'}
        'use_sub_domain_name': {'key': 'use_sub_domain_name', 'type': 'bool'}
        
    }

    def __init__(self, **kwargs):
        super(CustomDomain, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.use_sub_domain_name = kwargs.get('use_sub_domain_name', None)

class DateAfterCreation(Model):
    """Object to define the number of days after creation.

    :param days_after_creation_greater_than: Value indicating the age in days after creation.
    :type days_after_creation_greater_than: float
    """

    _attribute_map = {
        'days_after_creation_greater_than': {'key': 'days_after_creation_greater_than', 'type': 'float'}
        
    }

    def __init__(self, **kwargs):
        super(DateAfterCreation, self).__init__(**kwargs)
        self.days_after_creation_greater_than = kwargs.get('days_after_creation_greater_than', None)

class DateAfterCreation(Model):
    """Object to define the number of days after creation.

    :param days_after_creation_greater_than: Value indicating the age in days after creation.
    :type days_after_creation_greater_than: float
    """

    _attribute_map = {
        'days_after_creation_greater_than': {'key': 'days_after_creation_greater_than', 'type': 'float'}
        
    }

    def __init__(self, **kwargs):
        super(DateAfterCreation, self).__init__(**kwargs)
        self.days_after_creation_greater_than = kwargs.get('days_after_creation_greater_than', None)

class DateAfterModification(Model):
    """Object to define the number of days after last modification.

    :param days_after_modification_greater_than: Value indicating the age in days after last modification.
    :type days_after_modification_greater_than: float
    """

    _attribute_map = {
        'days_after_modification_greater_than': {'key': 'days_after_modification_greater_than', 'type': 'float'}
        
    }

    def __init__(self, **kwargs):
        super(DateAfterModification, self).__init__(**kwargs)
        self.days_after_modification_greater_than = kwargs.get('days_after_modification_greater_than', None)

class DateAfterModification(Model):
    """Object to define the number of days after last modification.

    :param days_after_modification_greater_than: Value indicating the age in days after last modification.
    :type days_after_modification_greater_than: float
    """

    _attribute_map = {
        'days_after_modification_greater_than': {'key': 'days_after_modification_greater_than', 'type': 'float'}
        
    }

    def __init__(self, **kwargs):
        super(DateAfterModification, self).__init__(**kwargs)
        self.days_after_modification_greater_than = kwargs.get('days_after_modification_greater_than', None)

class Dimension(Model):
    """Dimension of blobs, possibly be blob type or access tier.

    :param name: Display name of dimension.
    :type name: str
    :param display_name: Display name of dimension.
    :type display_name: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'}
        'display_name': {'key': 'display_name', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(Dimension, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.display_name = kwargs.get('display_name', None)

class Dimension(Model):
    """Dimension of blobs, possibly be blob type or access tier.

    :param name: Display name of dimension.
    :type name: str
    :param display_name: Display name of dimension.
    :type display_name: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'}
        'display_name': {'key': 'display_name', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(Dimension, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.display_name = kwargs.get('display_name', None)

class Encryption(Model):
    """The encryption settings on the storage account.

    :param services: A list of services that support encryption.
    :type services: EncryptionServices
    :param key_source: The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault.
    :type key_source: str or KeySource
    :param keyvaultproperties: Properties of key vault.
    :type keyvaultproperties: KeyVaultProperties
    """

    _attribute_map = {
        'services': {'key': 'services', 'type': 'EncryptionServices'}
        'key_source': {'key': 'key_source', 'type': 'str'}
        'keyvaultproperties': {'key': 'keyvaultproperties', 'type': 'KeyVaultProperties'}
        
    }

    def __init__(self, **kwargs):
        super(Encryption, self).__init__(**kwargs)
        self.services = kwargs.get('services', None)
        self.key_source = kwargs.get('key_source', None)
        self.keyvaultproperties = kwargs.get('keyvaultproperties', None)

class Encryption(Model):
    """The encryption settings on the storage account.

    :param services: A list of services that support encryption.
    :type services: EncryptionServices
    :param key_source: The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault.
    :type key_source: str or KeySource
    :param keyvaultproperties: Properties of key vault.
    :type keyvaultproperties: KeyVaultProperties
    """

    _attribute_map = {
        'services': {'key': 'services', 'type': 'EncryptionServices'}
        'key_source': {'key': 'key_source', 'type': 'str'}
        'keyvaultproperties': {'key': 'keyvaultproperties', 'type': 'KeyVaultProperties'}
        
    }

    def __init__(self, **kwargs):
        super(Encryption, self).__init__(**kwargs)
        self.services = kwargs.get('services', None)
        self.key_source = kwargs.get('key_source', None)
        self.keyvaultproperties = kwargs.get('keyvaultproperties', None)

class EncryptionService(Model):
    """A service that allows server-side encryption to be used.

    :param enabled: A boolean indicating whether or not the service encrypts the data as it is stored.
    :type enabled: bool
    :param last_enabled_time: Gets a rough estimate of the date/time when the encryption was last enabled by the user. Only returned when encryption is enabled. There might be some unencrypted blobs which were written after this time, as it is just a rough estimate.
    :type last_enabled_time: datetime.datetime
    """

    _attribute_map = {
        'enabled': {'key': 'enabled', 'type': 'bool'}
        'last_enabled_time': {'key': 'last_enabled_time', 'type': 'datetime.datetime'}
        
    }

    def __init__(self, **kwargs):
        super(EncryptionService, self).__init__(**kwargs)
        self.enabled = kwargs.get('enabled', None)
        self.last_enabled_time = kwargs.get('last_enabled_time', None)

class EncryptionService(Model):
    """A service that allows server-side encryption to be used.

    :param enabled: A boolean indicating whether or not the service encrypts the data as it is stored.
    :type enabled: bool
    :param last_enabled_time: Gets a rough estimate of the date/time when the encryption was last enabled by the user. Only returned when encryption is enabled. There might be some unencrypted blobs which were written after this time, as it is just a rough estimate.
    :type last_enabled_time: datetime.datetime
    """

    _attribute_map = {
        'enabled': {'key': 'enabled', 'type': 'bool'}
        'last_enabled_time': {'key': 'last_enabled_time', 'type': 'datetime.datetime'}
        
    }

    def __init__(self, **kwargs):
        super(EncryptionService, self).__init__(**kwargs)
        self.enabled = kwargs.get('enabled', None)
        self.last_enabled_time = kwargs.get('last_enabled_time', None)

class EncryptionServices(Model):
    """A list of services that support encryption.

    :param blob: A service that allows server-side encryption to be used.
    :type blob: EncryptionService
    :param file: A service that allows server-side encryption to be used.
    :type file: EncryptionService
    :param table: A service that allows server-side encryption to be used.
    :type table: EncryptionService
    :param queue: A service that allows server-side encryption to be used.
    :type queue: EncryptionService
    """

    _attribute_map = {
        'blob': {'key': 'blob', 'type': 'EncryptionService'}
        'file': {'key': 'file', 'type': 'EncryptionService'}
        'table': {'key': 'table', 'type': 'EncryptionService'}
        'queue': {'key': 'queue', 'type': 'EncryptionService'}
        
    }

    def __init__(self, **kwargs):
        super(EncryptionServices, self).__init__(**kwargs)
        self.blob = kwargs.get('blob', None)
        self.file = kwargs.get('file', None)
        self.table = kwargs.get('table', None)
        self.queue = kwargs.get('queue', None)

class EncryptionServices(Model):
    """A list of services that support encryption.

    :param blob: A service that allows server-side encryption to be used.
    :type blob: EncryptionService
    :param file: A service that allows server-side encryption to be used.
    :type file: EncryptionService
    :param table: A service that allows server-side encryption to be used.
    :type table: EncryptionService
    :param queue: A service that allows server-side encryption to be used.
    :type queue: EncryptionService
    """

    _attribute_map = {
        'blob': {'key': 'blob', 'type': 'EncryptionService'}
        'file': {'key': 'file', 'type': 'EncryptionService'}
        'table': {'key': 'table', 'type': 'EncryptionService'}
        'queue': {'key': 'queue', 'type': 'EncryptionService'}
        
    }

    def __init__(self, **kwargs):
        super(EncryptionServices, self).__init__(**kwargs)
        self.blob = kwargs.get('blob', None)
        self.file = kwargs.get('file', None)
        self.table = kwargs.get('table', None)
        self.queue = kwargs.get('queue', None)

class Endpoints(Model):
    """The URIs that are used to perform a retrieval of a public blob, queue, table, web or dfs object.

    :param blob: Gets the blob endpoint.
    :type blob: str
    :param queue: Gets the queue endpoint.
    :type queue: str
    :param table: Gets the table endpoint.
    :type table: str
    :param file: Gets the file endpoint.
    :type file: str
    :param web: Gets the web endpoint.
    :type web: str
    :param dfs: Gets the dfs endpoint.
    :type dfs: str
    """

    _attribute_map = {
        'blob': {'key': 'blob', 'type': 'str'}
        'queue': {'key': 'queue', 'type': 'str'}
        'table': {'key': 'table', 'type': 'str'}
        'file': {'key': 'file', 'type': 'str'}
        'web': {'key': 'web', 'type': 'str'}
        'dfs': {'key': 'dfs', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(Endpoints, self).__init__(**kwargs)
        self.blob = kwargs.get('blob', None)
        self.queue = kwargs.get('queue', None)
        self.table = kwargs.get('table', None)
        self.file = kwargs.get('file', None)
        self.web = kwargs.get('web', None)
        self.dfs = kwargs.get('dfs', None)

class Endpoints(Model):
    """The URIs that are used to perform a retrieval of a public blob, queue, table, web or dfs object.

    :param blob: Gets the blob endpoint.
    :type blob: str
    :param queue: Gets the queue endpoint.
    :type queue: str
    :param table: Gets the table endpoint.
    :type table: str
    :param file: Gets the file endpoint.
    :type file: str
    :param web: Gets the web endpoint.
    :type web: str
    :param dfs: Gets the dfs endpoint.
    :type dfs: str
    """

    _attribute_map = {
        'blob': {'key': 'blob', 'type': 'str'}
        'queue': {'key': 'queue', 'type': 'str'}
        'table': {'key': 'table', 'type': 'str'}
        'file': {'key': 'file', 'type': 'str'}
        'web': {'key': 'web', 'type': 'str'}
        'dfs': {'key': 'dfs', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(Endpoints, self).__init__(**kwargs)
        self.blob = kwargs.get('blob', None)
        self.queue = kwargs.get('queue', None)
        self.table = kwargs.get('table', None)
        self.file = kwargs.get('file', None)
        self.web = kwargs.get('web', None)
        self.dfs = kwargs.get('dfs', None)

class GeoReplicationStats(Model):
    """Statistics related to replication for storage account's Blob, Table, Queue and File services. It is only available when geo-redundant replication is enabled for the storage account.

    :param status: The status of the secondary location. Possible values are: - Live: Indicates that the secondary location is active and operational. - Bootstrap: Indicates initial synchronization from the primary location to the secondary location is in progress.This typically occurs when replication is first enabled. - Unavailable: Indicates that the secondary location is temporarily unavailable.
    :type status: str or GeoReplicationStatus
    :param last_sync_time: All primary writes preceding this UTC date/time value are guaranteed to be available for read operations. Primary writes following this point in time may or may not be available for reads. Element may be default value if value of LastSyncTime is not available, this can happen if secondary is offline or we are in bootstrap.
    :type last_sync_time: datetime.datetime
    :param can_failover: A boolean flag which indicates whether or not account failover is supported for the account.
    :type can_failover: bool
    """

    _attribute_map = {
        'status': {'key': 'status', 'type': 'str'}
        'last_sync_time': {'key': 'last_sync_time', 'type': 'datetime.datetime'}
        'can_failover': {'key': 'can_failover', 'type': 'bool'}
        
    }

    def __init__(self, **kwargs):
        super(GeoReplicationStats, self).__init__(**kwargs)
        self.status = kwargs.get('status', None)
        self.last_sync_time = kwargs.get('last_sync_time', None)
        self.can_failover = kwargs.get('can_failover', None)

class GeoReplicationStats(Model):
    """Statistics related to replication for storage account's Blob, Table, Queue and File services. It is only available when geo-redundant replication is enabled for the storage account.

    :param status: The status of the secondary location. Possible values are: - Live: Indicates that the secondary location is active and operational. - Bootstrap: Indicates initial synchronization from the primary location to the secondary location is in progress.This typically occurs when replication is first enabled. - Unavailable: Indicates that the secondary location is temporarily unavailable.
    :type status: str or GeoReplicationStatus
    :param last_sync_time: All primary writes preceding this UTC date/time value are guaranteed to be available for read operations. Primary writes following this point in time may or may not be available for reads. Element may be default value if value of LastSyncTime is not available, this can happen if secondary is offline or we are in bootstrap.
    :type last_sync_time: datetime.datetime
    :param can_failover: A boolean flag which indicates whether or not account failover is supported for the account.
    :type can_failover: bool
    """

    _attribute_map = {
        'status': {'key': 'status', 'type': 'str'}
        'last_sync_time': {'key': 'last_sync_time', 'type': 'datetime.datetime'}
        'can_failover': {'key': 'can_failover', 'type': 'bool'}
        
    }

    def __init__(self, **kwargs):
        super(GeoReplicationStats, self).__init__(**kwargs)
        self.status = kwargs.get('status', None)
        self.last_sync_time = kwargs.get('last_sync_time', None)
        self.can_failover = kwargs.get('can_failover', None)

class IPRule(Model):
    """IP rule with specific IP or IP range in CIDR format.

    :param value: Specifies the IP or IP range in CIDR format. Only IPV4 address is allowed.
    :type value: str
    :param action: The action of virtual network rule.
    :type action: str or Action
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': 'str'}
        'action': {'key': 'action', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(IPRule, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)
        self.action = kwargs.get('action', None)

class IPRule(Model):
    """IP rule with specific IP or IP range in CIDR format.

    :param value: Specifies the IP or IP range in CIDR format. Only IPV4 address is allowed.
    :type value: str
    :param action: The action of virtual network rule.
    :type action: str or Action
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': 'str'}
        'action': {'key': 'action', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(IPRule, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)
        self.action = kwargs.get('action', None)

class Identity(Model):
    """Identity for the resource.

    :param principal_id: The principal ID of resource identity.
    :type principal_id: str
    :param tenant_id: The tenant ID of resource.
    :type tenant_id: str
    :param type: The identity type.
    :type type: str or IdentityType
    """

    _attribute_map = {
        'principal_id': {'key': 'principal_id', 'type': 'str'}
        'tenant_id': {'key': 'tenant_id', 'type': 'str'}
        'type': {'key': 'type', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(Identity, self).__init__(**kwargs)
        self.principal_id = kwargs.get('principal_id', None)
        self.tenant_id = kwargs.get('tenant_id', None)
        self.type = kwargs.get('type', None)

class Identity(Model):
    """Identity for the resource.

    :param principal_id: The principal ID of resource identity.
    :type principal_id: str
    :param tenant_id: The tenant ID of resource.
    :type tenant_id: str
    :param type: The identity type.
    :type type: str or IdentityType
    """

    _attribute_map = {
        'principal_id': {'key': 'principal_id', 'type': 'str'}
        'tenant_id': {'key': 'tenant_id', 'type': 'str'}
        'type': {'key': 'type', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(Identity, self).__init__(**kwargs)
        self.principal_id = kwargs.get('principal_id', None)
        self.tenant_id = kwargs.get('tenant_id', None)
        self.type = kwargs.get('type', None)

class KeyVaultProperties(Model):
    """Properties of key vault.

    :param keyname: The name of KeyVault key.
    :type keyname: str
    :param keyversion: The version of KeyVault key.
    :type keyversion: str
    :param keyvaulturi: The Uri of KeyVault.
    :type keyvaulturi: str
    """

    _attribute_map = {
        'keyname': {'key': 'keyname', 'type': 'str'}
        'keyversion': {'key': 'keyversion', 'type': 'str'}
        'keyvaulturi': {'key': 'keyvaulturi', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(KeyVaultProperties, self).__init__(**kwargs)
        self.keyname = kwargs.get('keyname', None)
        self.keyversion = kwargs.get('keyversion', None)
        self.keyvaulturi = kwargs.get('keyvaulturi', None)

class KeyVaultProperties(Model):
    """Properties of key vault.

    :param keyname: The name of KeyVault key.
    :type keyname: str
    :param keyversion: The version of KeyVault key.
    :type keyversion: str
    :param keyvaulturi: The Uri of KeyVault.
    :type keyvaulturi: str
    """

    _attribute_map = {
        'keyname': {'key': 'keyname', 'type': 'str'}
        'keyversion': {'key': 'keyversion', 'type': 'str'}
        'keyvaulturi': {'key': 'keyvaulturi', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(KeyVaultProperties, self).__init__(**kwargs)
        self.keyname = kwargs.get('keyname', None)
        self.keyversion = kwargs.get('keyversion', None)
        self.keyvaulturi = kwargs.get('keyvaulturi', None)

class ListAccountSasResponse(Model):
    """The List SAS credentials operation response.

    :param account_sas_token: List SAS credentials of storage account.
    :type account_sas_token: str
    """

    _attribute_map = {
        'account_sas_token': {'key': 'account_sas_token', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(ListAccountSasResponse, self).__init__(**kwargs)
        self.account_sas_token = kwargs.get('account_sas_token', None)

class ListAccountSasResponse(Model):
    """The List SAS credentials operation response.

    :param account_sas_token: List SAS credentials of storage account.
    :type account_sas_token: str
    """

    _attribute_map = {
        'account_sas_token': {'key': 'account_sas_token', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(ListAccountSasResponse, self).__init__(**kwargs)
        self.account_sas_token = kwargs.get('account_sas_token', None)

class ListServiceSasResponse(Model):
    """The List service SAS credentials operation response.

    :param service_sas_token: List service SAS credentials of specific resource.
    :type service_sas_token: str
    """

    _attribute_map = {
        'service_sas_token': {'key': 'service_sas_token', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(ListServiceSasResponse, self).__init__(**kwargs)
        self.service_sas_token = kwargs.get('service_sas_token', None)

class ListServiceSasResponse(Model):
    """The List service SAS credentials operation response.

    :param service_sas_token: List service SAS credentials of specific resource.
    :type service_sas_token: str
    """

    _attribute_map = {
        'service_sas_token': {'key': 'service_sas_token', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(ListServiceSasResponse, self).__init__(**kwargs)
        self.service_sas_token = kwargs.get('service_sas_token', None)

class ManagementPolicy(Model):
    """The Get Storage Account ManagementPolicies operation response.

    :param properties: The Storage Account ManagementPolicy properties.
    :type properties: ManagementPolicyProperties
    """

    _attribute_map = {
        'properties': {'key': 'properties', 'type': 'ManagementPolicyProperties'}
        
    }

    def __init__(self, **kwargs):
        super(ManagementPolicy, self).__init__(**kwargs)
        self.properties = kwargs.get('properties', None)

class ManagementPolicyAction(Model):
    """Actions are applied to the filtered blobs when the execution condition is met.

    :param base_blob: Management policy action for base blob.
    :type base_blob: ManagementPolicyBaseBlob
    :param snapshot: Management policy action for snapshot.
    :type snapshot: ManagementPolicySnapShot
    """

    _attribute_map = {
        'base_blob': {'key': 'base_blob', 'type': 'ManagementPolicyBaseBlob'}
        'snapshot': {'key': 'snapshot', 'type': 'ManagementPolicySnapShot'}
        
    }

    def __init__(self, **kwargs):
        super(ManagementPolicyAction, self).__init__(**kwargs)
        self.base_blob = kwargs.get('base_blob', None)
        self.snapshot = kwargs.get('snapshot', None)

class ManagementPolicyAction(Model):
    """Actions are applied to the filtered blobs when the execution condition is met.

    :param base_blob: Management policy action for base blob.
    :type base_blob: ManagementPolicyBaseBlob
    :param snapshot: Management policy action for snapshot.
    :type snapshot: ManagementPolicySnapShot
    """

    _attribute_map = {
        'base_blob': {'key': 'base_blob', 'type': 'ManagementPolicyBaseBlob'}
        'snapshot': {'key': 'snapshot', 'type': 'ManagementPolicySnapShot'}
        
    }

    def __init__(self, **kwargs):
        super(ManagementPolicyAction, self).__init__(**kwargs)
        self.base_blob = kwargs.get('base_blob', None)
        self.snapshot = kwargs.get('snapshot', None)

class ManagementPolicyBaseBlob(Model):
    """Management policy action for base blob.

    :param tier_to_cool: Object to define the number of days after last modification.
    :type tier_to_cool: DateAfterModification
    :param tier_to_archive: Object to define the number of days after last modification.
    :type tier_to_archive: DateAfterModification
    :param delete: Object to define the number of days after last modification.
    :type delete: DateAfterModification
    """

    _attribute_map = {
        'tier_to_cool': {'key': 'tier_to_cool', 'type': 'DateAfterModification'}
        'tier_to_archive': {'key': 'tier_to_archive', 'type': 'DateAfterModification'}
        'delete': {'key': 'delete', 'type': 'DateAfterModification'}
        
    }

    def __init__(self, **kwargs):
        super(ManagementPolicyBaseBlob, self).__init__(**kwargs)
        self.tier_to_cool = kwargs.get('tier_to_cool', None)
        self.tier_to_archive = kwargs.get('tier_to_archive', None)
        self.delete = kwargs.get('delete', None)

class ManagementPolicyBaseBlob(Model):
    """Management policy action for base blob.

    :param tier_to_cool: Object to define the number of days after last modification.
    :type tier_to_cool: DateAfterModification
    :param tier_to_archive: Object to define the number of days after last modification.
    :type tier_to_archive: DateAfterModification
    :param delete: Object to define the number of days after last modification.
    :type delete: DateAfterModification
    """

    _attribute_map = {
        'tier_to_cool': {'key': 'tier_to_cool', 'type': 'DateAfterModification'}
        'tier_to_archive': {'key': 'tier_to_archive', 'type': 'DateAfterModification'}
        'delete': {'key': 'delete', 'type': 'DateAfterModification'}
        
    }

    def __init__(self, **kwargs):
        super(ManagementPolicyBaseBlob, self).__init__(**kwargs)
        self.tier_to_cool = kwargs.get('tier_to_cool', None)
        self.tier_to_archive = kwargs.get('tier_to_archive', None)
        self.delete = kwargs.get('delete', None)

class ManagementPolicyDefinition(Model):
    """An object that defines the Lifecycle rule. Each definition is made up with a filters set and an actions set.

    :param actions: Actions are applied to the filtered blobs when the execution condition is met.
    :type actions: ManagementPolicyAction
    :param filters: Filters limit rule actions to a subset of blobs within the storage account. If multiple filters are defined, a logical AND is performed on all filters.
    :type filters: ManagementPolicyFilter
    """

    _attribute_map = {
        'actions': {'key': 'actions', 'type': 'ManagementPolicyAction'}
        'filters': {'key': 'filters', 'type': 'ManagementPolicyFilter'}
        
    }

    def __init__(self, **kwargs):
        super(ManagementPolicyDefinition, self).__init__(**kwargs)
        self.actions = kwargs.get('actions', None)
        self.filters = kwargs.get('filters', None)

class ManagementPolicyDefinition(Model):
    """An object that defines the Lifecycle rule. Each definition is made up with a filters set and an actions set.

    :param actions: Actions are applied to the filtered blobs when the execution condition is met.
    :type actions: ManagementPolicyAction
    :param filters: Filters limit rule actions to a subset of blobs within the storage account. If multiple filters are defined, a logical AND is performed on all filters.
    :type filters: ManagementPolicyFilter
    """

    _attribute_map = {
        'actions': {'key': 'actions', 'type': 'ManagementPolicyAction'}
        'filters': {'key': 'filters', 'type': 'ManagementPolicyFilter'}
        
    }

    def __init__(self, **kwargs):
        super(ManagementPolicyDefinition, self).__init__(**kwargs)
        self.actions = kwargs.get('actions', None)
        self.filters = kwargs.get('filters', None)

class ManagementPolicyFilter(Model):
    """Filters limit rule actions to a subset of blobs within the storage account. If multiple filters are defined, a logical AND is performed on all filters.

    :param prefix_match: An array of strings for prefixes to be match.
    :type prefix_match: list[string]
    :param blob_types: An array of predefined enum values. Only blockBlob is supported.
    :type blob_types: list[string]
    """

    _attribute_map = {
        'prefix_match': {'key': 'prefix_match', 'type': '[string]'}
        'blob_types': {'key': 'blob_types', 'type': '[string]'}
        
    }

    def __init__(self, **kwargs):
        super(ManagementPolicyFilter, self).__init__(**kwargs)
        self.prefix_match = kwargs.get('prefix_match', None)
        self.blob_types = kwargs.get('blob_types', None)

class ManagementPolicyFilter(Model):
    """Filters limit rule actions to a subset of blobs within the storage account. If multiple filters are defined, a logical AND is performed on all filters.

    :param prefix_match: An array of strings for prefixes to be match.
    :type prefix_match: list[string]
    :param blob_types: An array of predefined enum values. Only blockBlob is supported.
    :type blob_types: list[string]
    """

    _attribute_map = {
        'prefix_match': {'key': 'prefix_match', 'type': '[string]'}
        'blob_types': {'key': 'blob_types', 'type': '[string]'}
        
    }

    def __init__(self, **kwargs):
        super(ManagementPolicyFilter, self).__init__(**kwargs)
        self.prefix_match = kwargs.get('prefix_match', None)
        self.blob_types = kwargs.get('blob_types', None)

class ManagementPolicyProperties(Model):
    """The Storage Account ManagementPolicy properties.

    :param last_modified_time: Returns the date and time the ManagementPolicies was last modified.
    :type last_modified_time: datetime.datetime
    :param policy: The Storage Account ManagementPolicies Rules. See more details in: https://docs.microsoft.com/en-us/azure/storage/common/storage-lifecycle-managment-concepts.
    :type policy: ManagementPolicySchema
    """

    _attribute_map = {
        'last_modified_time': {'key': 'last_modified_time', 'type': 'datetime.datetime'}
        'policy': {'key': 'policy', 'type': 'ManagementPolicySchema'}
        
    }

    def __init__(self, **kwargs):
        super(ManagementPolicyProperties, self).__init__(**kwargs)
        self.last_modified_time = kwargs.get('last_modified_time', None)
        self.policy = kwargs.get('policy', None)

class ManagementPolicyProperties(Model):
    """The Storage Account ManagementPolicy properties.

    :param last_modified_time: Returns the date and time the ManagementPolicies was last modified.
    :type last_modified_time: datetime.datetime
    :param policy: The Storage Account ManagementPolicies Rules. See more details in: https://docs.microsoft.com/en-us/azure/storage/common/storage-lifecycle-managment-concepts.
    :type policy: ManagementPolicySchema
    """

    _attribute_map = {
        'last_modified_time': {'key': 'last_modified_time', 'type': 'datetime.datetime'}
        'policy': {'key': 'policy', 'type': 'ManagementPolicySchema'}
        
    }

    def __init__(self, **kwargs):
        super(ManagementPolicyProperties, self).__init__(**kwargs)
        self.last_modified_time = kwargs.get('last_modified_time', None)
        self.policy = kwargs.get('policy', None)

class ManagementPolicyRule(Model):
    """An object that wraps the Lifecycle rule. Each rule is uniquely defined by name.

    :param enabled: Rule is enabled if set to true.
    :type enabled: bool
    :param name: A rule name can contain any combination of alpha numeric characters. Rule name is case-sensitive. It must be unique within a policy.
    :type name: str
    :param type: The valid value is Lifecycle.
    :type type: str or type
    :param definition: An object that defines the Lifecycle rule. Each definition is made up with a filters set and an actions set.
    :type definition: ManagementPolicyDefinition
    """

    _attribute_map = {
        'enabled': {'key': 'enabled', 'type': 'bool'}
        'name': {'key': 'name', 'type': 'str'}
        'type': {'key': 'type', 'type': 'str'}
        'definition': {'key': 'definition', 'type': 'ManagementPolicyDefinition'}
        
    }

    def __init__(self, **kwargs):
        super(ManagementPolicyRule, self).__init__(**kwargs)
        self.enabled = kwargs.get('enabled', None)
        self.name = kwargs.get('name', None)
        self.type = kwargs.get('type', None)
        self.definition = kwargs.get('definition', None)

class ManagementPolicyRule(Model):
    """An object that wraps the Lifecycle rule. Each rule is uniquely defined by name.

    :param enabled: Rule is enabled if set to true.
    :type enabled: bool
    :param name: A rule name can contain any combination of alpha numeric characters. Rule name is case-sensitive. It must be unique within a policy.
    :type name: str
    :param type: The valid value is Lifecycle.
    :type type: str or type
    :param definition: An object that defines the Lifecycle rule. Each definition is made up with a filters set and an actions set.
    :type definition: ManagementPolicyDefinition
    """

    _attribute_map = {
        'enabled': {'key': 'enabled', 'type': 'bool'}
        'name': {'key': 'name', 'type': 'str'}
        'type': {'key': 'type', 'type': 'str'}
        'definition': {'key': 'definition', 'type': 'ManagementPolicyDefinition'}
        
    }

    def __init__(self, **kwargs):
        super(ManagementPolicyRule, self).__init__(**kwargs)
        self.enabled = kwargs.get('enabled', None)
        self.name = kwargs.get('name', None)
        self.type = kwargs.get('type', None)
        self.definition = kwargs.get('definition', None)

class ManagementPolicySchema(Model):
    """The Storage Account ManagementPolicies Rules. See more details in: https://docs.microsoft.com/en-us/azure/storage/common/storage-lifecycle-managment-concepts.

    :param rules: The Storage Account ManagementPolicies Rules. See more details in: https://docs.microsoft.com/en-us/azure/storage/common/storage-lifecycle-managment-concepts.
    :type rules: list[object]
    """

    _attribute_map = {
        'rules': {'key': 'rules', 'type': '[object]'}
        
    }

    def __init__(self, **kwargs):
        super(ManagementPolicySchema, self).__init__(**kwargs)
        self.rules = kwargs.get('rules', None)

class ManagementPolicySchema(Model):
    """The Storage Account ManagementPolicies Rules. See more details in: https://docs.microsoft.com/en-us/azure/storage/common/storage-lifecycle-managment-concepts.

    :param rules: The Storage Account ManagementPolicies Rules. See more details in: https://docs.microsoft.com/en-us/azure/storage/common/storage-lifecycle-managment-concepts.
    :type rules: list[object]
    """

    _attribute_map = {
        'rules': {'key': 'rules', 'type': '[object]'}
        
    }

    def __init__(self, **kwargs):
        super(ManagementPolicySchema, self).__init__(**kwargs)
        self.rules = kwargs.get('rules', None)

class ManagementPolicySnapShot(Model):
    """Management policy action for snapshot.

    :param delete: Object to define the number of days after creation.
    :type delete: DateAfterCreation
    """

    _attribute_map = {
        'delete': {'key': 'delete', 'type': 'DateAfterCreation'}
        
    }

    def __init__(self, **kwargs):
        super(ManagementPolicySnapShot, self).__init__(**kwargs)
        self.delete = kwargs.get('delete', None)

class ManagementPolicySnapShot(Model):
    """Management policy action for snapshot.

    :param delete: Object to define the number of days after creation.
    :type delete: DateAfterCreation
    """

    _attribute_map = {
        'delete': {'key': 'delete', 'type': 'DateAfterCreation'}
        
    }

    def __init__(self, **kwargs):
        super(ManagementPolicySnapShot, self).__init__(**kwargs)
        self.delete = kwargs.get('delete', None)

class MetricSpecification(Model):
    """Metric specification of operation.

    :param name: Name of metric specification.
    :type name: str
    :param display_name: Display name of metric specification.
    :type display_name: str
    :param display_description: Display description of metric specification.
    :type display_description: str
    :param unit: Unit could be Bytes or Count.
    :type unit: str
    :param dimensions: Dimensions of blobs, including blob type and access tier.
    :type dimensions: list[object]
    :param aggregation_type: Aggregation type could be Average.
    :type aggregation_type: str
    :param fill_gap_with_zero: The property to decide fill gap with zero or not.
    :type fill_gap_with_zero: bool
    :param category: The category this metric specification belong to, could be Capacity.
    :type category: str
    :param resource_id_dimension_name_override: Account Resource Id.
    :type resource_id_dimension_name_override: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'}
        'display_name': {'key': 'display_name', 'type': 'str'}
        'display_description': {'key': 'display_description', 'type': 'str'}
        'unit': {'key': 'unit', 'type': 'str'}
        'dimensions': {'key': 'dimensions', 'type': '[object]'}
        'aggregation_type': {'key': 'aggregation_type', 'type': 'str'}
        'fill_gap_with_zero': {'key': 'fill_gap_with_zero', 'type': 'bool'}
        'category': {'key': 'category', 'type': 'str'}
        'resource_id_dimension_name_override': {'key': 'resource_id_dimension_name_override', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(MetricSpecification, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.display_name = kwargs.get('display_name', None)
        self.display_description = kwargs.get('display_description', None)
        self.unit = kwargs.get('unit', None)
        self.dimensions = kwargs.get('dimensions', None)
        self.aggregation_type = kwargs.get('aggregation_type', None)
        self.fill_gap_with_zero = kwargs.get('fill_gap_with_zero', None)
        self.category = kwargs.get('category', None)
        self.resource_id_dimension_name_override = kwargs.get('resource_id_dimension_name_override', None)

class MetricSpecification(Model):
    """Metric specification of operation.

    :param name: Name of metric specification.
    :type name: str
    :param display_name: Display name of metric specification.
    :type display_name: str
    :param display_description: Display description of metric specification.
    :type display_description: str
    :param unit: Unit could be Bytes or Count.
    :type unit: str
    :param dimensions: Dimensions of blobs, including blob type and access tier.
    :type dimensions: list[object]
    :param aggregation_type: Aggregation type could be Average.
    :type aggregation_type: str
    :param fill_gap_with_zero: The property to decide fill gap with zero or not.
    :type fill_gap_with_zero: bool
    :param category: The category this metric specification belong to, could be Capacity.
    :type category: str
    :param resource_id_dimension_name_override: Account Resource Id.
    :type resource_id_dimension_name_override: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'}
        'display_name': {'key': 'display_name', 'type': 'str'}
        'display_description': {'key': 'display_description', 'type': 'str'}
        'unit': {'key': 'unit', 'type': 'str'}
        'dimensions': {'key': 'dimensions', 'type': '[object]'}
        'aggregation_type': {'key': 'aggregation_type', 'type': 'str'}
        'fill_gap_with_zero': {'key': 'fill_gap_with_zero', 'type': 'bool'}
        'category': {'key': 'category', 'type': 'str'}
        'resource_id_dimension_name_override': {'key': 'resource_id_dimension_name_override', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(MetricSpecification, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.display_name = kwargs.get('display_name', None)
        self.display_description = kwargs.get('display_description', None)
        self.unit = kwargs.get('unit', None)
        self.dimensions = kwargs.get('dimensions', None)
        self.aggregation_type = kwargs.get('aggregation_type', None)
        self.fill_gap_with_zero = kwargs.get('fill_gap_with_zero', None)
        self.category = kwargs.get('category', None)
        self.resource_id_dimension_name_override = kwargs.get('resource_id_dimension_name_override', None)

class NetworkRuleSet(Model):
    """Network rule set

    :param bypass: Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Possible values are any combination of Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None to bypass none of those traffics.
    :type bypass: str or Bypass
    :param virtual_network_rules: Sets the virtual network rules.
    :type virtual_network_rules: list[object]
    :param ip_rules: Sets the IP ACL rules.
    :type ip_rules: list[object]
    :param default_action: Specifies the default action of allow or deny when no other rules match.
    :type default_action: str or DefaultAction
    """

    _attribute_map = {
        'bypass': {'key': 'bypass', 'type': 'str'}
        'virtual_network_rules': {'key': 'virtual_network_rules', 'type': '[object]'}
        'ip_rules': {'key': 'ip_rules', 'type': '[object]'}
        'default_action': {'key': 'default_action', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(NetworkRuleSet, self).__init__(**kwargs)
        self.bypass = kwargs.get('bypass', None)
        self.virtual_network_rules = kwargs.get('virtual_network_rules', None)
        self.ip_rules = kwargs.get('ip_rules', None)
        self.default_action = kwargs.get('default_action', None)

class NetworkRuleSet(Model):
    """Network rule set

    :param bypass: Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Possible values are any combination of Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None to bypass none of those traffics.
    :type bypass: str or Bypass
    :param virtual_network_rules: Sets the virtual network rules.
    :type virtual_network_rules: list[object]
    :param ip_rules: Sets the IP ACL rules.
    :type ip_rules: list[object]
    :param default_action: Specifies the default action of allow or deny when no other rules match.
    :type default_action: str or DefaultAction
    """

    _attribute_map = {
        'bypass': {'key': 'bypass', 'type': 'str'}
        'virtual_network_rules': {'key': 'virtual_network_rules', 'type': '[object]'}
        'ip_rules': {'key': 'ip_rules', 'type': '[object]'}
        'default_action': {'key': 'default_action', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(NetworkRuleSet, self).__init__(**kwargs)
        self.bypass = kwargs.get('bypass', None)
        self.virtual_network_rules = kwargs.get('virtual_network_rules', None)
        self.ip_rules = kwargs.get('ip_rules', None)
        self.default_action = kwargs.get('default_action', None)

class Operation(Model):
    """Storage REST API operation definition.

    :param name: Operation name: {provider}/{resource}/{operation}.
    :type name: str
    :param display: Display metadata associated with the operation.
    :type display: Operation-display
    :param origin: The origin of operations.
    :type origin: str
    :param properties: Properties of operation, include metric specifications.
    :type properties: OperationProperties
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'}
        'display': {'key': 'display', 'type': 'Operation-display'}
        'origin': {'key': 'origin', 'type': 'str'}
        'properties': {'key': 'properties', 'type': 'OperationProperties'}
        
    }

    def __init__(self, **kwargs):
        super(Operation, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.display = kwargs.get('display', None)
        self.origin = kwargs.get('origin', None)
        self.properties = kwargs.get('properties', None)

class Operation(Model):
    """Storage REST API operation definition.

    :param name: Operation name: {provider}/{resource}/{operation}.
    :type name: str
    :param display: Display metadata associated with the operation.
    :type display: Operation-display
    :param origin: The origin of operations.
    :type origin: str
    :param properties: Properties of operation, include metric specifications.
    :type properties: OperationProperties
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'}
        'display': {'key': 'display', 'type': 'Operation-display'}
        'origin': {'key': 'origin', 'type': 'str'}
        'properties': {'key': 'properties', 'type': 'OperationProperties'}
        
    }

    def __init__(self, **kwargs):
        super(Operation, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.display = kwargs.get('display', None)
        self.origin = kwargs.get('origin', None)
        self.properties = kwargs.get('properties', None)

class Operation-display(Model):
    """Display metadata associated with the operation.

    :param provider: Service provider: Microsoft Storage.
    :type provider: str
    :param resource: Resource on which the operation is performed etc.
    :type resource: str
    :param operation: Type of operation: get, read, delete, etc.
    :type operation: str
    :param description: Description of the operation.
    :type description: str
    """

    _attribute_map = {
        'provider': {'key': 'provider', 'type': 'str'}
        'resource': {'key': 'resource', 'type': 'str'}
        'operation': {'key': 'operation', 'type': 'str'}
        'description': {'key': 'description', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(Operation-display, self).__init__(**kwargs)
        self.provider = kwargs.get('provider', None)
        self.resource = kwargs.get('resource', None)
        self.operation = kwargs.get('operation', None)
        self.description = kwargs.get('description', None)

class Operation-display(Model):
    """Display metadata associated with the operation.

    :param provider: Service provider: Microsoft Storage.
    :type provider: str
    :param resource: Resource on which the operation is performed etc.
    :type resource: str
    :param operation: Type of operation: get, read, delete, etc.
    :type operation: str
    :param description: Description of the operation.
    :type description: str
    """

    _attribute_map = {
        'provider': {'key': 'provider', 'type': 'str'}
        'resource': {'key': 'resource', 'type': 'str'}
        'operation': {'key': 'operation', 'type': 'str'}
        'description': {'key': 'description', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(Operation-display, self).__init__(**kwargs)
        self.provider = kwargs.get('provider', None)
        self.resource = kwargs.get('resource', None)
        self.operation = kwargs.get('operation', None)
        self.description = kwargs.get('description', None)

class OperationListResult(Model):
    """Result of the request to list Storage operations. It contains a list of operations and a URL link to get the next set of results.

    :param value: List of Storage operations supported by the Storage resource provider.
    :type value: list[object]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[object]'}
        
    }

    def __init__(self, **kwargs):
        super(OperationListResult, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)

class OperationListResult(Model):
    """Result of the request to list Storage operations. It contains a list of operations and a URL link to get the next set of results.

    :param value: List of Storage operations supported by the Storage resource provider.
    :type value: list[object]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[object]'}
        
    }

    def __init__(self, **kwargs):
        super(OperationListResult, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)

class OperationProperties(Model):
    """Properties of operation, include metric specifications.

    :param service_specification: One property of operation, include metric specifications.
    :type service_specification: ServiceSpecification
    """

    _attribute_map = {
        'service_specification': {'key': 'service_specification', 'type': 'ServiceSpecification'}
        
    }

    def __init__(self, **kwargs):
        super(OperationProperties, self).__init__(**kwargs)
        self.service_specification = kwargs.get('service_specification', None)

class OperationProperties(Model):
    """Properties of operation, include metric specifications.

    :param service_specification: One property of operation, include metric specifications.
    :type service_specification: ServiceSpecification
    """

    _attribute_map = {
        'service_specification': {'key': 'service_specification', 'type': 'ServiceSpecification'}
        
    }

    def __init__(self, **kwargs):
        super(OperationProperties, self).__init__(**kwargs)
        self.service_specification = kwargs.get('service_specification', None)

class Resource(Model):
    """MISSING-SCHEMA-DESCRIPTION-OBJECTSCHEMA

    :param id: Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :type id: str
    :param name: The name of the resource.
    :type name: str
    :param type: The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
    :type type: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'}
        'name': {'key': 'name', 'type': 'str'}
        'type': {'key': 'type', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(Resource, self).__init__(**kwargs)
        self.id = kwargs.get('id', None)
        self.name = kwargs.get('name', None)
        self.type = kwargs.get('type', None)

class Resource(Model):
    """MISSING-SCHEMA-DESCRIPTION-OBJECTSCHEMA

    :param id: Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :type id: str
    :param name: The name of the resource.
    :type name: str
    :param type: The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
    :type type: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'}
        'name': {'key': 'name', 'type': 'str'}
        'type': {'key': 'type', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(Resource, self).__init__(**kwargs)
        self.id = kwargs.get('id', None)
        self.name = kwargs.get('name', None)
        self.type = kwargs.get('type', None)

class Restriction(Model):
    """The restriction because of which SKU cannot be used.

    :param type: The type of restrictions. As of now only possible value for this is location.
    :type type: str
    :param values: The value of restrictions. If the restriction type is set to location. This would be different locations where the SKU is restricted.
    :type values: list[string]
    :param reason_code: The reason for the restriction. As of now this can be "QuotaId" or "NotAvailableForSubscription". Quota Id is set when the SKU has requiredQuotas parameter as the subscription does not belong to that quota. The "NotAvailableForSubscription" is related to capacity at DC.
    :type reason_code: str or ReasonCode
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'}
        'values': {'key': 'values', 'type': '[string]'}
        'reason_code': {'key': 'reason_code', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(Restriction, self).__init__(**kwargs)
        self.type = kwargs.get('type', None)
        self.values = kwargs.get('values', None)
        self.reason_code = kwargs.get('reason_code', None)

class Restriction(Model):
    """The restriction because of which SKU cannot be used.

    :param type: The type of restrictions. As of now only possible value for this is location.
    :type type: str
    :param values: The value of restrictions. If the restriction type is set to location. This would be different locations where the SKU is restricted.
    :type values: list[string]
    :param reason_code: The reason for the restriction. As of now this can be "QuotaId" or "NotAvailableForSubscription". Quota Id is set when the SKU has requiredQuotas parameter as the subscription does not belong to that quota. The "NotAvailableForSubscription" is related to capacity at DC.
    :type reason_code: str or ReasonCode
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'}
        'values': {'key': 'values', 'type': '[string]'}
        'reason_code': {'key': 'reason_code', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(Restriction, self).__init__(**kwargs)
        self.type = kwargs.get('type', None)
        self.values = kwargs.get('values', None)
        self.reason_code = kwargs.get('reason_code', None)

class SKUCapability(Model):
    """The capability information in the specified SKU, including file encryption, network ACLs, change notification, etc.

    :param name: The name of capability, The capability information in the specified SKU, including file encryption, network ACLs, change notification, etc.
    :type name: str
    :param value: A string value to indicate states of given capability. Possibly 'true' or 'false'.
    :type value: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'}
        'value': {'key': 'value', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(SKUCapability, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.value = kwargs.get('value', None)

class SKUCapability(Model):
    """The capability information in the specified SKU, including file encryption, network ACLs, change notification, etc.

    :param name: The name of capability, The capability information in the specified SKU, including file encryption, network ACLs, change notification, etc.
    :type name: str
    :param value: A string value to indicate states of given capability. Possibly 'true' or 'false'.
    :type value: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'}
        'value': {'key': 'value', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(SKUCapability, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.value = kwargs.get('value', None)

class ServiceSasParameters(Model):
    """The parameters to list service SAS credentials of a specific resource.

    :param canonicalized_resource: The canonical path to the signed resource.
    :type canonicalized_resource: str
    :param signed_resource: The signed services accessible with the service SAS. Possible values include: Blob (b), Container (c), File (f), Share (s).
    :type signed_resource: str or signedResource
    :param signed_permission: The signed permissions for the account SAS. Possible values include: Read (r), Write (w), Delete (d), List (l), Add (a), Create (c), Update (u) and Process (p).
    :type signed_permission: str or Permissions
    :param signed_ip: An IP address or a range of IP addresses from which to accept requests.
    :type signed_ip: str
    :param signed_protocol: The protocol permitted for a request made with the account SAS.
    :type signed_protocol: str or HttpProtocol
    :param signed_start: The time at which the SAS becomes valid.
    :type signed_start: datetime.datetime
    :param signed_expiry: The time at which the shared access signature becomes invalid.
    :type signed_expiry: datetime.datetime
    :param signed_identifier: A unique value up to 64 characters in length that correlates to an access policy specified for the container, queue, or table.
    :type signed_identifier: str
    :param start_pk: The start of partition key.
    :type start_pk: str
    :param end_pk: The end of partition key.
    :type end_pk: str
    :param start_rk: The start of row key.
    :type start_rk: str
    :param end_rk: The end of row key.
    :type end_rk: str
    :param key_to_sign: The key to sign the account SAS token with.
    :type key_to_sign: str
    :param rscc: The response header override for cache control.
    :type rscc: str
    :param rscd: The response header override for content disposition.
    :type rscd: str
    :param rsce: The response header override for content encoding.
    :type rsce: str
    :param rscl: The response header override for content language.
    :type rscl: str
    :param rsct: The response header override for content type.
    :type rsct: str
    """

    _attribute_map = {
        'canonicalized_resource': {'key': 'canonicalized_resource', 'type': 'str'}
        'signed_resource': {'key': 'signed_resource', 'type': 'str'}
        'signed_permission': {'key': 'signed_permission', 'type': 'str'}
        'signed_ip': {'key': 'signed_ip', 'type': 'str'}
        'signed_protocol': {'key': 'signed_protocol', 'type': 'str'}
        'signed_start': {'key': 'signed_start', 'type': 'datetime.datetime'}
        'signed_expiry': {'key': 'signed_expiry', 'type': 'datetime.datetime'}
        'signed_identifier': {'key': 'signed_identifier', 'type': 'str'}
        'start_pk': {'key': 'start_pk', 'type': 'str'}
        'end_pk': {'key': 'end_pk', 'type': 'str'}
        'start_rk': {'key': 'start_rk', 'type': 'str'}
        'end_rk': {'key': 'end_rk', 'type': 'str'}
        'key_to_sign': {'key': 'key_to_sign', 'type': 'str'}
        'rscc': {'key': 'rscc', 'type': 'str'}
        'rscd': {'key': 'rscd', 'type': 'str'}
        'rsce': {'key': 'rsce', 'type': 'str'}
        'rscl': {'key': 'rscl', 'type': 'str'}
        'rsct': {'key': 'rsct', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(ServiceSasParameters, self).__init__(**kwargs)
        self.canonicalized_resource = kwargs.get('canonicalized_resource', None)
        self.signed_resource = kwargs.get('signed_resource', None)
        self.signed_permission = kwargs.get('signed_permission', None)
        self.signed_ip = kwargs.get('signed_ip', None)
        self.signed_protocol = kwargs.get('signed_protocol', None)
        self.signed_start = kwargs.get('signed_start', None)
        self.signed_expiry = kwargs.get('signed_expiry', None)
        self.signed_identifier = kwargs.get('signed_identifier', None)
        self.start_pk = kwargs.get('start_pk', None)
        self.end_pk = kwargs.get('end_pk', None)
        self.start_rk = kwargs.get('start_rk', None)
        self.end_rk = kwargs.get('end_rk', None)
        self.key_to_sign = kwargs.get('key_to_sign', None)
        self.rscc = kwargs.get('rscc', None)
        self.rscd = kwargs.get('rscd', None)
        self.rsce = kwargs.get('rsce', None)
        self.rscl = kwargs.get('rscl', None)
        self.rsct = kwargs.get('rsct', None)

class ServiceSasParameters(Model):
    """The parameters to list service SAS credentials of a specific resource.

    :param canonicalized_resource: The canonical path to the signed resource.
    :type canonicalized_resource: str
    :param signed_resource: The signed services accessible with the service SAS. Possible values include: Blob (b), Container (c), File (f), Share (s).
    :type signed_resource: str or signedResource
    :param signed_permission: The signed permissions for the account SAS. Possible values include: Read (r), Write (w), Delete (d), List (l), Add (a), Create (c), Update (u) and Process (p).
    :type signed_permission: str or Permissions
    :param signed_ip: An IP address or a range of IP addresses from which to accept requests.
    :type signed_ip: str
    :param signed_protocol: The protocol permitted for a request made with the account SAS.
    :type signed_protocol: str or HttpProtocol
    :param signed_start: The time at which the SAS becomes valid.
    :type signed_start: datetime.datetime
    :param signed_expiry: The time at which the shared access signature becomes invalid.
    :type signed_expiry: datetime.datetime
    :param signed_identifier: A unique value up to 64 characters in length that correlates to an access policy specified for the container, queue, or table.
    :type signed_identifier: str
    :param start_pk: The start of partition key.
    :type start_pk: str
    :param end_pk: The end of partition key.
    :type end_pk: str
    :param start_rk: The start of row key.
    :type start_rk: str
    :param end_rk: The end of row key.
    :type end_rk: str
    :param key_to_sign: The key to sign the account SAS token with.
    :type key_to_sign: str
    :param rscc: The response header override for cache control.
    :type rscc: str
    :param rscd: The response header override for content disposition.
    :type rscd: str
    :param rsce: The response header override for content encoding.
    :type rsce: str
    :param rscl: The response header override for content language.
    :type rscl: str
    :param rsct: The response header override for content type.
    :type rsct: str
    """

    _attribute_map = {
        'canonicalized_resource': {'key': 'canonicalized_resource', 'type': 'str'}
        'signed_resource': {'key': 'signed_resource', 'type': 'str'}
        'signed_permission': {'key': 'signed_permission', 'type': 'str'}
        'signed_ip': {'key': 'signed_ip', 'type': 'str'}
        'signed_protocol': {'key': 'signed_protocol', 'type': 'str'}
        'signed_start': {'key': 'signed_start', 'type': 'datetime.datetime'}
        'signed_expiry': {'key': 'signed_expiry', 'type': 'datetime.datetime'}
        'signed_identifier': {'key': 'signed_identifier', 'type': 'str'}
        'start_pk': {'key': 'start_pk', 'type': 'str'}
        'end_pk': {'key': 'end_pk', 'type': 'str'}
        'start_rk': {'key': 'start_rk', 'type': 'str'}
        'end_rk': {'key': 'end_rk', 'type': 'str'}
        'key_to_sign': {'key': 'key_to_sign', 'type': 'str'}
        'rscc': {'key': 'rscc', 'type': 'str'}
        'rscd': {'key': 'rscd', 'type': 'str'}
        'rsce': {'key': 'rsce', 'type': 'str'}
        'rscl': {'key': 'rscl', 'type': 'str'}
        'rsct': {'key': 'rsct', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(ServiceSasParameters, self).__init__(**kwargs)
        self.canonicalized_resource = kwargs.get('canonicalized_resource', None)
        self.signed_resource = kwargs.get('signed_resource', None)
        self.signed_permission = kwargs.get('signed_permission', None)
        self.signed_ip = kwargs.get('signed_ip', None)
        self.signed_protocol = kwargs.get('signed_protocol', None)
        self.signed_start = kwargs.get('signed_start', None)
        self.signed_expiry = kwargs.get('signed_expiry', None)
        self.signed_identifier = kwargs.get('signed_identifier', None)
        self.start_pk = kwargs.get('start_pk', None)
        self.end_pk = kwargs.get('end_pk', None)
        self.start_rk = kwargs.get('start_rk', None)
        self.end_rk = kwargs.get('end_rk', None)
        self.key_to_sign = kwargs.get('key_to_sign', None)
        self.rscc = kwargs.get('rscc', None)
        self.rscd = kwargs.get('rscd', None)
        self.rsce = kwargs.get('rsce', None)
        self.rscl = kwargs.get('rscl', None)
        self.rsct = kwargs.get('rsct', None)

class ServiceSpecification(Model):
    """One property of operation, include metric specifications.

    :param metric_specifications: Metric specifications of operation.
    :type metric_specifications: list[object]
    """

    _attribute_map = {
        'metric_specifications': {'key': 'metric_specifications', 'type': '[object]'}
        
    }

    def __init__(self, **kwargs):
        super(ServiceSpecification, self).__init__(**kwargs)
        self.metric_specifications = kwargs.get('metric_specifications', None)

class ServiceSpecification(Model):
    """One property of operation, include metric specifications.

    :param metric_specifications: Metric specifications of operation.
    :type metric_specifications: list[object]
    """

    _attribute_map = {
        'metric_specifications': {'key': 'metric_specifications', 'type': '[object]'}
        
    }

    def __init__(self, **kwargs):
        super(ServiceSpecification, self).__init__(**kwargs)
        self.metric_specifications = kwargs.get('metric_specifications', None)

class Sku(Model):
    """The SKU of the storage account.

    :param name: Gets or sets the SKU name. Required for account creation; optional for update. Note that in older versions, SKU name was called accountType.
    :type name: str or SkuName
    :param tier: Gets the SKU tier. This is based on the SKU name.
    :type tier: str or SkuTier
    :param resource_type: The type of the resource, usually it is 'storageAccounts'.
    :type resource_type: str
    :param kind: Indicates the type of storage account.
    :type kind: str or Kind
    :param locations: The set of locations that the SKU is available. This will be supported and registered Azure Geo Regions (e.g. West US, East US, Southeast Asia, etc.).
    :type locations: list[string]
    :param capabilities: The capability information in the specified SKU, including file encryption, network ACLs, change notification, etc.
    :type capabilities: list[object]
    :param restrictions: The restrictions because of which SKU cannot be used. This is empty if there are no restrictions.
    :type restrictions: list[object]
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'}
        'tier': {'key': 'tier', 'type': 'str'}
        'resource_type': {'key': 'resource_type', 'type': 'str'}
        'kind': {'key': 'kind', 'type': 'str'}
        'locations': {'key': 'locations', 'type': '[string]'}
        'capabilities': {'key': 'capabilities', 'type': '[object]'}
        'restrictions': {'key': 'restrictions', 'type': '[object]'}
        
    }

    def __init__(self, **kwargs):
        super(Sku, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.tier = kwargs.get('tier', None)
        self.resource_type = kwargs.get('resource_type', None)
        self.kind = kwargs.get('kind', None)
        self.locations = kwargs.get('locations', None)
        self.capabilities = kwargs.get('capabilities', None)
        self.restrictions = kwargs.get('restrictions', None)

class Sku(Model):
    """The SKU of the storage account.

    :param name: Gets or sets the SKU name. Required for account creation; optional for update. Note that in older versions, SKU name was called accountType.
    :type name: str or SkuName
    :param tier: Gets the SKU tier. This is based on the SKU name.
    :type tier: str or SkuTier
    :param resource_type: The type of the resource, usually it is 'storageAccounts'.
    :type resource_type: str
    :param kind: Indicates the type of storage account.
    :type kind: str or Kind
    :param locations: The set of locations that the SKU is available. This will be supported and registered Azure Geo Regions (e.g. West US, East US, Southeast Asia, etc.).
    :type locations: list[string]
    :param capabilities: The capability information in the specified SKU, including file encryption, network ACLs, change notification, etc.
    :type capabilities: list[object]
    :param restrictions: The restrictions because of which SKU cannot be used. This is empty if there are no restrictions.
    :type restrictions: list[object]
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'}
        'tier': {'key': 'tier', 'type': 'str'}
        'resource_type': {'key': 'resource_type', 'type': 'str'}
        'kind': {'key': 'kind', 'type': 'str'}
        'locations': {'key': 'locations', 'type': '[string]'}
        'capabilities': {'key': 'capabilities', 'type': '[object]'}
        'restrictions': {'key': 'restrictions', 'type': '[object]'}
        
    }

    def __init__(self, **kwargs):
        super(Sku, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.tier = kwargs.get('tier', None)
        self.resource_type = kwargs.get('resource_type', None)
        self.kind = kwargs.get('kind', None)
        self.locations = kwargs.get('locations', None)
        self.capabilities = kwargs.get('capabilities', None)
        self.restrictions = kwargs.get('restrictions', None)

class StorageAccount(Model):
    """The storage account.

    :param sku: The SKU of the storage account.
    :type sku: Sku
    :param kind: Indicates the type of storage account.
    :type kind: str or Kind
    :param identity: Identity for the resource.
    :type identity: Identity
    :param properties: Properties of the storage account.
    :type properties: StorageAccountProperties
    """

    _attribute_map = {
        'sku': {'key': 'sku', 'type': 'Sku'}
        'kind': {'key': 'kind', 'type': 'str'}
        'identity': {'key': 'identity', 'type': 'Identity'}
        'properties': {'key': 'properties', 'type': 'StorageAccountProperties'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccount, self).__init__(**kwargs)
        self.sku = kwargs.get('sku', None)
        self.kind = kwargs.get('kind', None)
        self.identity = kwargs.get('identity', None)
        self.properties = kwargs.get('properties', None)

class StorageAccountCheckNameAvailabilityParameters(Model):
    """The parameters used to check the availability of the storage account name.

    :param name: The storage account name.
    :type name: str
    :param type: The type of resource, Microsoft.Storage/storageAccounts.
    :type type: str or Type
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'}
        'type': {'key': 'type', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccountCheckNameAvailabilityParameters, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.type = kwargs.get('type', None)

class StorageAccountCheckNameAvailabilityParameters(Model):
    """The parameters used to check the availability of the storage account name.

    :param name: The storage account name.
    :type name: str
    :param type: The type of resource, Microsoft.Storage/storageAccounts.
    :type type: str or Type
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'}
        'type': {'key': 'type', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccountCheckNameAvailabilityParameters, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.type = kwargs.get('type', None)

class StorageAccountCreateParameters(Model):
    """The parameters used when creating a storage account.

    :param sku: The SKU of the storage account.
    :type sku: Sku
    :param kind: Indicates the type of storage account.
    :type kind: str or Kind
    :param location: Required. Gets or sets the location of the resource. This will be one of the supported and registered Azure Geo Regions (e.g. West US, East US, Southeast Asia, etc.). The geo region of a resource cannot be changed once it is created, but if an identical geo region is specified on update, the request will succeed.
    :type location: str
    :param tags: Gets or sets a list of key value pairs that describe the resource. These tags can be used for viewing and grouping this resource (across resource groups). A maximum of 15 tags can be provided for a resource. Each tag must have a key with a length no greater than 128 characters and a value with a length no greater than 256 characters.
    :type tags: dict[str, string]
    :param identity: Identity for the resource.
    :type identity: Identity
    :param properties: The parameters used to create the storage account.
    :type properties: StorageAccountPropertiesCreateParameters
    """

    _attribute_map = {
        'sku': {'key': 'sku', 'type': 'Sku'}
        'kind': {'key': 'kind', 'type': 'str'}
        'location': {'key': 'location', 'type': 'str'}
        'tags': {'key': 'tags', 'type': '{string}'}
        'identity': {'key': 'identity', 'type': 'Identity'}
        'properties': {'key': 'properties', 'type': 'StorageAccountPropertiesCreateParameters'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccountCreateParameters, self).__init__(**kwargs)
        self.sku = kwargs.get('sku', None)
        self.kind = kwargs.get('kind', None)
        self.location = kwargs.get('location', None)
        self.tags = kwargs.get('tags', None)
        self.identity = kwargs.get('identity', None)
        self.properties = kwargs.get('properties', None)

class StorageAccountCreateParameters(Model):
    """The parameters used when creating a storage account.

    :param sku: The SKU of the storage account.
    :type sku: Sku
    :param kind: Indicates the type of storage account.
    :type kind: str or Kind
    :param location: Required. Gets or sets the location of the resource. This will be one of the supported and registered Azure Geo Regions (e.g. West US, East US, Southeast Asia, etc.). The geo region of a resource cannot be changed once it is created, but if an identical geo region is specified on update, the request will succeed.
    :type location: str
    :param tags: Gets or sets a list of key value pairs that describe the resource. These tags can be used for viewing and grouping this resource (across resource groups). A maximum of 15 tags can be provided for a resource. Each tag must have a key with a length no greater than 128 characters and a value with a length no greater than 256 characters.
    :type tags: dict[str, string]
    :param identity: Identity for the resource.
    :type identity: Identity
    :param properties: The parameters used to create the storage account.
    :type properties: StorageAccountPropertiesCreateParameters
    """

    _attribute_map = {
        'sku': {'key': 'sku', 'type': 'Sku'}
        'kind': {'key': 'kind', 'type': 'str'}
        'location': {'key': 'location', 'type': 'str'}
        'tags': {'key': 'tags', 'type': '{string}'}
        'identity': {'key': 'identity', 'type': 'Identity'}
        'properties': {'key': 'properties', 'type': 'StorageAccountPropertiesCreateParameters'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccountCreateParameters, self).__init__(**kwargs)
        self.sku = kwargs.get('sku', None)
        self.kind = kwargs.get('kind', None)
        self.location = kwargs.get('location', None)
        self.tags = kwargs.get('tags', None)
        self.identity = kwargs.get('identity', None)
        self.properties = kwargs.get('properties', None)

class StorageAccountKey(Model):
    """An access key for the storage account.

    :param key_name: Name of the key.
    :type key_name: str
    :param value: Base 64-encoded value of the key.
    :type value: str
    :param permissions: Permissions for the key -- read-only or full permissions.
    :type permissions: str or KeyPermission
    """

    _attribute_map = {
        'key_name': {'key': 'key_name', 'type': 'str'}
        'value': {'key': 'value', 'type': 'str'}
        'permissions': {'key': 'permissions', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccountKey, self).__init__(**kwargs)
        self.key_name = kwargs.get('key_name', None)
        self.value = kwargs.get('value', None)
        self.permissions = kwargs.get('permissions', None)

class StorageAccountKey(Model):
    """An access key for the storage account.

    :param key_name: Name of the key.
    :type key_name: str
    :param value: Base 64-encoded value of the key.
    :type value: str
    :param permissions: Permissions for the key -- read-only or full permissions.
    :type permissions: str or KeyPermission
    """

    _attribute_map = {
        'key_name': {'key': 'key_name', 'type': 'str'}
        'value': {'key': 'value', 'type': 'str'}
        'permissions': {'key': 'permissions', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccountKey, self).__init__(**kwargs)
        self.key_name = kwargs.get('key_name', None)
        self.value = kwargs.get('value', None)
        self.permissions = kwargs.get('permissions', None)

class StorageAccountListKeysResult(Model):
    """The response from the ListKeys operation.

    :param keys: Gets the list of storage account keys and their properties for the specified storage account.
    :type keys: list[object]
    """

    _attribute_map = {
        'keys': {'key': 'keys', 'type': '[object]'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccountListKeysResult, self).__init__(**kwargs)
        self.keys = kwargs.get('keys', None)

class StorageAccountListKeysResult(Model):
    """The response from the ListKeys operation.

    :param keys: Gets the list of storage account keys and their properties for the specified storage account.
    :type keys: list[object]
    """

    _attribute_map = {
        'keys': {'key': 'keys', 'type': '[object]'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccountListKeysResult, self).__init__(**kwargs)
        self.keys = kwargs.get('keys', None)

class StorageAccountListResult(Model):
    """The response from the List Storage Accounts operation.

    :param value: Gets the list of storage accounts and their properties.
    :type value: list[and]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[and]'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccountListResult, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)

class StorageAccountListResult(Model):
    """The response from the List Storage Accounts operation.

    :param value: Gets the list of storage accounts and their properties.
    :type value: list[and]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[and]'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccountListResult, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)

class StorageAccountProperties(Model):
    """Properties of the storage account.

    :param provisioning_state: Gets the status of the storage account at the time the operation was called.
    :type provisioning_state: str or ProvisioningState
    :param primary_endpoints: The URIs that are used to perform a retrieval of a public blob, queue, table, web or dfs object.
    :type primary_endpoints: Endpoints
    :param primary_location: Gets the location of the primary data center for the storage account.
    :type primary_location: str
    :param status_of_primary: Gets the status indicating whether the primary location of the storage account is available or unavailable.
    :type status_of_primary: str or AccountStatus
    :param last_geo_failover_time: Gets the timestamp of the most recent instance of a failover to the secondary location. Only the most recent timestamp is retained. This element is not returned if there has never been a failover instance. Only available if the accountType is Standard_GRS or Standard_RAGRS.
    :type last_geo_failover_time: datetime.datetime
    :param secondary_location: Gets the location of the geo-replicated secondary for the storage account. Only available if the accountType is Standard_GRS or Standard_RAGRS.
    :type secondary_location: str
    :param status_of_secondary: Gets the status indicating whether the primary location of the storage account is available or unavailable.
    :type status_of_secondary: str or AccountStatus
    :param creation_time: Gets the creation date and time of the storage account in UTC.
    :type creation_time: datetime.datetime
    :param custom_domain: The custom domain assigned to this storage account. This can be set via Update.
    :type custom_domain: CustomDomain
    :param secondary_endpoints: The URIs that are used to perform a retrieval of a public blob, queue, table, web or dfs object.
    :type secondary_endpoints: Endpoints
    :param encryption: The encryption settings on the storage account.
    :type encryption: Encryption
    :param access_tier: Required for storage accounts where kind = BlobStorage. The access tier used for billing.
    :type access_tier: str or AccessTier
    :param azure_files_identity_based_authentication: Settings for Azure Files identity based authentication.
    :type azure_files_identity_based_authentication: AzureFilesIdentityBasedAuthentication
    :param supports_https_traffic_only: Allows https traffic only to storage service if sets to true.
    :type supports_https_traffic_only: bool
    :param network_acls: Network rule set.
    :type network_acls: NetworkRuleSet
    :param is_hns_enabled: Account HierarchicalNamespace enabled if sets to true.
    :type is_hns_enabled: bool
    :param geo_replication_stats: Statistics related to replication for storage account's Blob, Table, Queue and File services. It is only available when geo-redundant replication is enabled for the storage account.
    :type geo_replication_stats: GeoReplicationStats
    :param failover_in_progress: If the failover is in progress, the value will be true, otherwise, it will be null.
    :type failover_in_progress: bool
    """

    _attribute_map = {
        'provisioning_state': {'key': 'provisioning_state', 'type': 'str'}
        'primary_endpoints': {'key': 'primary_endpoints', 'type': 'Endpoints'}
        'primary_location': {'key': 'primary_location', 'type': 'str'}
        'status_of_primary': {'key': 'status_of_primary', 'type': 'str'}
        'last_geo_failover_time': {'key': 'last_geo_failover_time', 'type': 'datetime.datetime'}
        'secondary_location': {'key': 'secondary_location', 'type': 'str'}
        'status_of_secondary': {'key': 'status_of_secondary', 'type': 'str'}
        'creation_time': {'key': 'creation_time', 'type': 'datetime.datetime'}
        'custom_domain': {'key': 'custom_domain', 'type': 'CustomDomain'}
        'secondary_endpoints': {'key': 'secondary_endpoints', 'type': 'Endpoints'}
        'encryption': {'key': 'encryption', 'type': 'Encryption'}
        'access_tier': {'key': 'access_tier', 'type': 'str'}
        'azure_files_identity_based_authentication': {'key': 'azure_files_identity_based_authentication', 'type': 'AzureFilesIdentityBasedAuthentication'}
        'supports_https_traffic_only': {'key': 'supports_https_traffic_only', 'type': 'bool'}
        'network_acls': {'key': 'network_acls', 'type': 'NetworkRuleSet'}
        'is_hns_enabled': {'key': 'is_hns_enabled', 'type': 'bool'}
        'geo_replication_stats': {'key': 'geo_replication_stats', 'type': 'GeoReplicationStats'}
        'failover_in_progress': {'key': 'failover_in_progress', 'type': 'bool'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccountProperties, self).__init__(**kwargs)
        self.provisioning_state = kwargs.get('provisioning_state', None)
        self.primary_endpoints = kwargs.get('primary_endpoints', None)
        self.primary_location = kwargs.get('primary_location', None)
        self.status_of_primary = kwargs.get('status_of_primary', None)
        self.last_geo_failover_time = kwargs.get('last_geo_failover_time', None)
        self.secondary_location = kwargs.get('secondary_location', None)
        self.status_of_secondary = kwargs.get('status_of_secondary', None)
        self.creation_time = kwargs.get('creation_time', None)
        self.custom_domain = kwargs.get('custom_domain', None)
        self.secondary_endpoints = kwargs.get('secondary_endpoints', None)
        self.encryption = kwargs.get('encryption', None)
        self.access_tier = kwargs.get('access_tier', None)
        self.azure_files_identity_based_authentication = kwargs.get('azure_files_identity_based_authentication', None)
        self.supports_https_traffic_only = kwargs.get('supports_https_traffic_only', None)
        self.network_acls = kwargs.get('network_acls', None)
        self.is_hns_enabled = kwargs.get('is_hns_enabled', None)
        self.geo_replication_stats = kwargs.get('geo_replication_stats', None)
        self.failover_in_progress = kwargs.get('failover_in_progress', None)

class StorageAccountProperties(Model):
    """Properties of the storage account.

    :param provisioning_state: Gets the status of the storage account at the time the operation was called.
    :type provisioning_state: str or ProvisioningState
    :param primary_endpoints: The URIs that are used to perform a retrieval of a public blob, queue, table, web or dfs object.
    :type primary_endpoints: Endpoints
    :param primary_location: Gets the location of the primary data center for the storage account.
    :type primary_location: str
    :param status_of_primary: Gets the status indicating whether the primary location of the storage account is available or unavailable.
    :type status_of_primary: str or AccountStatus
    :param last_geo_failover_time: Gets the timestamp of the most recent instance of a failover to the secondary location. Only the most recent timestamp is retained. This element is not returned if there has never been a failover instance. Only available if the accountType is Standard_GRS or Standard_RAGRS.
    :type last_geo_failover_time: datetime.datetime
    :param secondary_location: Gets the location of the geo-replicated secondary for the storage account. Only available if the accountType is Standard_GRS or Standard_RAGRS.
    :type secondary_location: str
    :param status_of_secondary: Gets the status indicating whether the primary location of the storage account is available or unavailable.
    :type status_of_secondary: str or AccountStatus
    :param creation_time: Gets the creation date and time of the storage account in UTC.
    :type creation_time: datetime.datetime
    :param custom_domain: The custom domain assigned to this storage account. This can be set via Update.
    :type custom_domain: CustomDomain
    :param secondary_endpoints: The URIs that are used to perform a retrieval of a public blob, queue, table, web or dfs object.
    :type secondary_endpoints: Endpoints
    :param encryption: The encryption settings on the storage account.
    :type encryption: Encryption
    :param access_tier: Required for storage accounts where kind = BlobStorage. The access tier used for billing.
    :type access_tier: str or AccessTier
    :param azure_files_identity_based_authentication: Settings for Azure Files identity based authentication.
    :type azure_files_identity_based_authentication: AzureFilesIdentityBasedAuthentication
    :param supports_https_traffic_only: Allows https traffic only to storage service if sets to true.
    :type supports_https_traffic_only: bool
    :param network_acls: Network rule set.
    :type network_acls: NetworkRuleSet
    :param is_hns_enabled: Account HierarchicalNamespace enabled if sets to true.
    :type is_hns_enabled: bool
    :param geo_replication_stats: Statistics related to replication for storage account's Blob, Table, Queue and File services. It is only available when geo-redundant replication is enabled for the storage account.
    :type geo_replication_stats: GeoReplicationStats
    :param failover_in_progress: If the failover is in progress, the value will be true, otherwise, it will be null.
    :type failover_in_progress: bool
    """

    _attribute_map = {
        'provisioning_state': {'key': 'provisioning_state', 'type': 'str'}
        'primary_endpoints': {'key': 'primary_endpoints', 'type': 'Endpoints'}
        'primary_location': {'key': 'primary_location', 'type': 'str'}
        'status_of_primary': {'key': 'status_of_primary', 'type': 'str'}
        'last_geo_failover_time': {'key': 'last_geo_failover_time', 'type': 'datetime.datetime'}
        'secondary_location': {'key': 'secondary_location', 'type': 'str'}
        'status_of_secondary': {'key': 'status_of_secondary', 'type': 'str'}
        'creation_time': {'key': 'creation_time', 'type': 'datetime.datetime'}
        'custom_domain': {'key': 'custom_domain', 'type': 'CustomDomain'}
        'secondary_endpoints': {'key': 'secondary_endpoints', 'type': 'Endpoints'}
        'encryption': {'key': 'encryption', 'type': 'Encryption'}
        'access_tier': {'key': 'access_tier', 'type': 'str'}
        'azure_files_identity_based_authentication': {'key': 'azure_files_identity_based_authentication', 'type': 'AzureFilesIdentityBasedAuthentication'}
        'supports_https_traffic_only': {'key': 'supports_https_traffic_only', 'type': 'bool'}
        'network_acls': {'key': 'network_acls', 'type': 'NetworkRuleSet'}
        'is_hns_enabled': {'key': 'is_hns_enabled', 'type': 'bool'}
        'geo_replication_stats': {'key': 'geo_replication_stats', 'type': 'GeoReplicationStats'}
        'failover_in_progress': {'key': 'failover_in_progress', 'type': 'bool'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccountProperties, self).__init__(**kwargs)
        self.provisioning_state = kwargs.get('provisioning_state', None)
        self.primary_endpoints = kwargs.get('primary_endpoints', None)
        self.primary_location = kwargs.get('primary_location', None)
        self.status_of_primary = kwargs.get('status_of_primary', None)
        self.last_geo_failover_time = kwargs.get('last_geo_failover_time', None)
        self.secondary_location = kwargs.get('secondary_location', None)
        self.status_of_secondary = kwargs.get('status_of_secondary', None)
        self.creation_time = kwargs.get('creation_time', None)
        self.custom_domain = kwargs.get('custom_domain', None)
        self.secondary_endpoints = kwargs.get('secondary_endpoints', None)
        self.encryption = kwargs.get('encryption', None)
        self.access_tier = kwargs.get('access_tier', None)
        self.azure_files_identity_based_authentication = kwargs.get('azure_files_identity_based_authentication', None)
        self.supports_https_traffic_only = kwargs.get('supports_https_traffic_only', None)
        self.network_acls = kwargs.get('network_acls', None)
        self.is_hns_enabled = kwargs.get('is_hns_enabled', None)
        self.geo_replication_stats = kwargs.get('geo_replication_stats', None)
        self.failover_in_progress = kwargs.get('failover_in_progress', None)

class StorageAccountPropertiesCreateParameters(Model):
    """The parameters used to create the storage account.

    :param custom_domain: The custom domain assigned to this storage account. This can be set via Update.
    :type custom_domain: CustomDomain
    :param encryption: The encryption settings on the storage account.
    :type encryption: Encryption
    :param network_acls: Network rule set.
    :type network_acls: NetworkRuleSet
    :param access_tier: Required for storage accounts where kind = BlobStorage. The access tier used for billing.
    :type access_tier: str or AccessTier
    :param azure_files_identity_based_authentication: Settings for Azure Files identity based authentication.
    :type azure_files_identity_based_authentication: AzureFilesIdentityBasedAuthentication
    :param supports_https_traffic_only: Allows https traffic only to storage service if sets to true. The default value is true since API version 2019-04-01.
    :type supports_https_traffic_only: bool
    :param is_hns_enabled: Account HierarchicalNamespace enabled if sets to true.
    :type is_hns_enabled: bool
    """

    _attribute_map = {
        'custom_domain': {'key': 'custom_domain', 'type': 'CustomDomain'}
        'encryption': {'key': 'encryption', 'type': 'Encryption'}
        'network_acls': {'key': 'network_acls', 'type': 'NetworkRuleSet'}
        'access_tier': {'key': 'access_tier', 'type': 'str'}
        'azure_files_identity_based_authentication': {'key': 'azure_files_identity_based_authentication', 'type': 'AzureFilesIdentityBasedAuthentication'}
        'supports_https_traffic_only': {'key': 'supports_https_traffic_only', 'type': 'bool'}
        'is_hns_enabled': {'key': 'is_hns_enabled', 'type': 'bool'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccountPropertiesCreateParameters, self).__init__(**kwargs)
        self.custom_domain = kwargs.get('custom_domain', None)
        self.encryption = kwargs.get('encryption', None)
        self.network_acls = kwargs.get('network_acls', None)
        self.access_tier = kwargs.get('access_tier', None)
        self.azure_files_identity_based_authentication = kwargs.get('azure_files_identity_based_authentication', None)
        self.supports_https_traffic_only = kwargs.get('supports_https_traffic_only', None)
        self.is_hns_enabled = kwargs.get('is_hns_enabled', None)

class StorageAccountPropertiesCreateParameters(Model):
    """The parameters used to create the storage account.

    :param custom_domain: The custom domain assigned to this storage account. This can be set via Update.
    :type custom_domain: CustomDomain
    :param encryption: The encryption settings on the storage account.
    :type encryption: Encryption
    :param network_acls: Network rule set.
    :type network_acls: NetworkRuleSet
    :param access_tier: Required for storage accounts where kind = BlobStorage. The access tier used for billing.
    :type access_tier: str or AccessTier
    :param azure_files_identity_based_authentication: Settings for Azure Files identity based authentication.
    :type azure_files_identity_based_authentication: AzureFilesIdentityBasedAuthentication
    :param supports_https_traffic_only: Allows https traffic only to storage service if sets to true. The default value is true since API version 2019-04-01.
    :type supports_https_traffic_only: bool
    :param is_hns_enabled: Account HierarchicalNamespace enabled if sets to true.
    :type is_hns_enabled: bool
    """

    _attribute_map = {
        'custom_domain': {'key': 'custom_domain', 'type': 'CustomDomain'}
        'encryption': {'key': 'encryption', 'type': 'Encryption'}
        'network_acls': {'key': 'network_acls', 'type': 'NetworkRuleSet'}
        'access_tier': {'key': 'access_tier', 'type': 'str'}
        'azure_files_identity_based_authentication': {'key': 'azure_files_identity_based_authentication', 'type': 'AzureFilesIdentityBasedAuthentication'}
        'supports_https_traffic_only': {'key': 'supports_https_traffic_only', 'type': 'bool'}
        'is_hns_enabled': {'key': 'is_hns_enabled', 'type': 'bool'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccountPropertiesCreateParameters, self).__init__(**kwargs)
        self.custom_domain = kwargs.get('custom_domain', None)
        self.encryption = kwargs.get('encryption', None)
        self.network_acls = kwargs.get('network_acls', None)
        self.access_tier = kwargs.get('access_tier', None)
        self.azure_files_identity_based_authentication = kwargs.get('azure_files_identity_based_authentication', None)
        self.supports_https_traffic_only = kwargs.get('supports_https_traffic_only', None)
        self.is_hns_enabled = kwargs.get('is_hns_enabled', None)

class StorageAccountPropertiesUpdateParameters(Model):
    """The parameters used when updating a storage account.

    :param custom_domain: The custom domain assigned to this storage account. This can be set via Update.
    :type custom_domain: CustomDomain
    :param encryption: The encryption settings on the storage account.
    :type encryption: Encryption
    :param access_tier: Required for storage accounts where kind = BlobStorage. The access tier used for billing.
    :type access_tier: str or AccessTier
    :param azure_files_identity_based_authentication: Settings for Azure Files identity based authentication.
    :type azure_files_identity_based_authentication: AzureFilesIdentityBasedAuthentication
    :param supports_https_traffic_only: Allows https traffic only to storage service if sets to true.
    :type supports_https_traffic_only: bool
    :param network_acls: Network rule set.
    :type network_acls: NetworkRuleSet
    """

    _attribute_map = {
        'custom_domain': {'key': 'custom_domain', 'type': 'CustomDomain'}
        'encryption': {'key': 'encryption', 'type': 'Encryption'}
        'access_tier': {'key': 'access_tier', 'type': 'str'}
        'azure_files_identity_based_authentication': {'key': 'azure_files_identity_based_authentication', 'type': 'AzureFilesIdentityBasedAuthentication'}
        'supports_https_traffic_only': {'key': 'supports_https_traffic_only', 'type': 'bool'}
        'network_acls': {'key': 'network_acls', 'type': 'NetworkRuleSet'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccountPropertiesUpdateParameters, self).__init__(**kwargs)
        self.custom_domain = kwargs.get('custom_domain', None)
        self.encryption = kwargs.get('encryption', None)
        self.access_tier = kwargs.get('access_tier', None)
        self.azure_files_identity_based_authentication = kwargs.get('azure_files_identity_based_authentication', None)
        self.supports_https_traffic_only = kwargs.get('supports_https_traffic_only', None)
        self.network_acls = kwargs.get('network_acls', None)

class StorageAccountPropertiesUpdateParameters(Model):
    """The parameters used when updating a storage account.

    :param custom_domain: The custom domain assigned to this storage account. This can be set via Update.
    :type custom_domain: CustomDomain
    :param encryption: The encryption settings on the storage account.
    :type encryption: Encryption
    :param access_tier: Required for storage accounts where kind = BlobStorage. The access tier used for billing.
    :type access_tier: str or AccessTier
    :param azure_files_identity_based_authentication: Settings for Azure Files identity based authentication.
    :type azure_files_identity_based_authentication: AzureFilesIdentityBasedAuthentication
    :param supports_https_traffic_only: Allows https traffic only to storage service if sets to true.
    :type supports_https_traffic_only: bool
    :param network_acls: Network rule set.
    :type network_acls: NetworkRuleSet
    """

    _attribute_map = {
        'custom_domain': {'key': 'custom_domain', 'type': 'CustomDomain'}
        'encryption': {'key': 'encryption', 'type': 'Encryption'}
        'access_tier': {'key': 'access_tier', 'type': 'str'}
        'azure_files_identity_based_authentication': {'key': 'azure_files_identity_based_authentication', 'type': 'AzureFilesIdentityBasedAuthentication'}
        'supports_https_traffic_only': {'key': 'supports_https_traffic_only', 'type': 'bool'}
        'network_acls': {'key': 'network_acls', 'type': 'NetworkRuleSet'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccountPropertiesUpdateParameters, self).__init__(**kwargs)
        self.custom_domain = kwargs.get('custom_domain', None)
        self.encryption = kwargs.get('encryption', None)
        self.access_tier = kwargs.get('access_tier', None)
        self.azure_files_identity_based_authentication = kwargs.get('azure_files_identity_based_authentication', None)
        self.supports_https_traffic_only = kwargs.get('supports_https_traffic_only', None)
        self.network_acls = kwargs.get('network_acls', None)

class StorageAccountRegenerateKeyParameters(Model):
    """The parameters used to regenerate the storage account key.

    :param key_name: The name of storage keys that want to be regenerated, possible values are key1, key2.
    :type key_name: str
    """

    _attribute_map = {
        'key_name': {'key': 'key_name', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccountRegenerateKeyParameters, self).__init__(**kwargs)
        self.key_name = kwargs.get('key_name', None)

class StorageAccountRegenerateKeyParameters(Model):
    """The parameters used to regenerate the storage account key.

    :param key_name: The name of storage keys that want to be regenerated, possible values are key1, key2.
    :type key_name: str
    """

    _attribute_map = {
        'key_name': {'key': 'key_name', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccountRegenerateKeyParameters, self).__init__(**kwargs)
        self.key_name = kwargs.get('key_name', None)

class StorageAccountUpdateParameters(Model):
    """The parameters that can be provided when updating the storage account properties.

    :param sku: The SKU of the storage account.
    :type sku: Sku
    :param tags: Gets or sets a list of key value pairs that describe the resource. These tags can be used in viewing and grouping this resource (across resource groups). A maximum of 15 tags can be provided for a resource. Each tag must have a key no greater in length than 128 characters and a value no greater in length than 256 characters.
    :type tags: dict[str, string]
    :param identity: Identity for the resource.
    :type identity: Identity
    :param properties: The parameters used when updating a storage account.
    :type properties: StorageAccountPropertiesUpdateParameters
    :param kind: Indicates the type of storage account.
    :type kind: str or Kind
    """

    _attribute_map = {
        'sku': {'key': 'sku', 'type': 'Sku'}
        'tags': {'key': 'tags', 'type': '{string}'}
        'identity': {'key': 'identity', 'type': 'Identity'}
        'properties': {'key': 'properties', 'type': 'StorageAccountPropertiesUpdateParameters'}
        'kind': {'key': 'kind', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccountUpdateParameters, self).__init__(**kwargs)
        self.sku = kwargs.get('sku', None)
        self.tags = kwargs.get('tags', None)
        self.identity = kwargs.get('identity', None)
        self.properties = kwargs.get('properties', None)
        self.kind = kwargs.get('kind', None)

class StorageAccountUpdateParameters(Model):
    """The parameters that can be provided when updating the storage account properties.

    :param sku: The SKU of the storage account.
    :type sku: Sku
    :param tags: Gets or sets a list of key value pairs that describe the resource. These tags can be used in viewing and grouping this resource (across resource groups). A maximum of 15 tags can be provided for a resource. Each tag must have a key no greater in length than 128 characters and a value no greater in length than 256 characters.
    :type tags: dict[str, string]
    :param identity: Identity for the resource.
    :type identity: Identity
    :param properties: The parameters used when updating a storage account.
    :type properties: StorageAccountPropertiesUpdateParameters
    :param kind: Indicates the type of storage account.
    :type kind: str or Kind
    """

    _attribute_map = {
        'sku': {'key': 'sku', 'type': 'Sku'}
        'tags': {'key': 'tags', 'type': '{string}'}
        'identity': {'key': 'identity', 'type': 'Identity'}
        'properties': {'key': 'properties', 'type': 'StorageAccountPropertiesUpdateParameters'}
        'kind': {'key': 'kind', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(StorageAccountUpdateParameters, self).__init__(**kwargs)
        self.sku = kwargs.get('sku', None)
        self.tags = kwargs.get('tags', None)
        self.identity = kwargs.get('identity', None)
        self.properties = kwargs.get('properties', None)
        self.kind = kwargs.get('kind', None)

class StorageSkuListResult(Model):
    """The response from the List Storage SKUs operation.

    :param value: Get the list result of storage SKUs and their properties.
    :type value: list[object]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[object]'}
        
    }

    def __init__(self, **kwargs):
        super(StorageSkuListResult, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)

class StorageSkuListResult(Model):
    """The response from the List Storage SKUs operation.

    :param value: Get the list result of storage SKUs and their properties.
    :type value: list[object]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[object]'}
        
    }

    def __init__(self, **kwargs):
        super(StorageSkuListResult, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)

class TrackedResource(Model):
    """The resource model definition for a ARM tracked top level resource

    :param tags: Resource tags.
    :type tags: dict[str, string]
    :param location: The geo-location where the resource lives.
    :type location: str
    """

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{string}'}
        'location': {'key': 'location', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(TrackedResource, self).__init__(**kwargs)
        self.tags = kwargs.get('tags', None)
        self.location = kwargs.get('location', None)

class Usage(Model):
    """Describes Storage Resource Usage.

    :param unit: Gets the unit of measurement.
    :type unit: str or UsageUnit
    :param current_value: Gets the current count of the allocated resources in the subscription.
    :type current_value: int
    :param limit: Gets the maximum count of the resources that can be allocated in the subscription.
    :type limit: int
    :param name: The usage names that can be used; currently limited to StorageAccount.
    :type name: UsageName
    """

    _attribute_map = {
        'unit': {'key': 'unit', 'type': 'str'}
        'current_value': {'key': 'current_value', 'type': 'int'}
        'limit': {'key': 'limit', 'type': 'int'}
        'name': {'key': 'name', 'type': 'UsageName'}
        
    }

    def __init__(self, **kwargs):
        super(Usage, self).__init__(**kwargs)
        self.unit = kwargs.get('unit', None)
        self.current_value = kwargs.get('current_value', None)
        self.limit = kwargs.get('limit', None)
        self.name = kwargs.get('name', None)

class Usage(Model):
    """Describes Storage Resource Usage.

    :param unit: Gets the unit of measurement.
    :type unit: str or UsageUnit
    :param current_value: Gets the current count of the allocated resources in the subscription.
    :type current_value: int
    :param limit: Gets the maximum count of the resources that can be allocated in the subscription.
    :type limit: int
    :param name: The usage names that can be used; currently limited to StorageAccount.
    :type name: UsageName
    """

    _attribute_map = {
        'unit': {'key': 'unit', 'type': 'str'}
        'current_value': {'key': 'current_value', 'type': 'int'}
        'limit': {'key': 'limit', 'type': 'int'}
        'name': {'key': 'name', 'type': 'UsageName'}
        
    }

    def __init__(self, **kwargs):
        super(Usage, self).__init__(**kwargs)
        self.unit = kwargs.get('unit', None)
        self.current_value = kwargs.get('current_value', None)
        self.limit = kwargs.get('limit', None)
        self.name = kwargs.get('name', None)

class UsageListResult(Model):
    """The response from the List Usages operation.

    :param value: Gets or sets the list of Storage Resource Usages.
    :type value: list[object]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[object]'}
        
    }

    def __init__(self, **kwargs):
        super(UsageListResult, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)

class UsageListResult(Model):
    """The response from the List Usages operation.

    :param value: Gets or sets the list of Storage Resource Usages.
    :type value: list[object]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[object]'}
        
    }

    def __init__(self, **kwargs):
        super(UsageListResult, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)

class UsageName(Model):
    """The usage names that can be used; currently limited to StorageAccount.

    :param value: Gets a string describing the resource name.
    :type value: str
    :param localized_value: Gets a localized string describing the resource name.
    :type localized_value: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': 'str'}
        'localized_value': {'key': 'localized_value', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(UsageName, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)
        self.localized_value = kwargs.get('localized_value', None)

class UsageName(Model):
    """The usage names that can be used; currently limited to StorageAccount.

    :param value: Gets a string describing the resource name.
    :type value: str
    :param localized_value: Gets a localized string describing the resource name.
    :type localized_value: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': 'str'}
        'localized_value': {'key': 'localized_value', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(UsageName, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)
        self.localized_value = kwargs.get('localized_value', None)

class VirtualNetworkRule(Model):
    """Virtual Network rule.

    :param id: Resource ID of a subnet, for example: /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
    :type id: str
    :param action: The action of virtual network rule.
    :type action: str or Action
    :param state: Gets the state of virtual network rule.
    :type state: str or State
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'}
        'action': {'key': 'action', 'type': 'str'}
        'state': {'key': 'state', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(VirtualNetworkRule, self).__init__(**kwargs)
        self.id = kwargs.get('id', None)
        self.action = kwargs.get('action', None)
        self.state = kwargs.get('state', None)

class VirtualNetworkRule(Model):
    """Virtual Network rule.

    :param id: Resource ID of a subnet, for example: /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
    :type id: str
    :param action: The action of virtual network rule.
    :type action: str or Action
    :param state: Gets the state of virtual network rule.
    :type state: str or State
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'}
        'action': {'key': 'action', 'type': 'str'}
        'state': {'key': 'state', 'type': 'str'}
        
    }

    def __init__(self, **kwargs):
        super(VirtualNetworkRule, self).__init__(**kwargs)
        self.id = kwargs.get('id', None)
        self.action = kwargs.get('action', None)
        self.state = kwargs.get('state', None)