{# actual template starts here #}
{% import "macros.jinja2" as macros %}


{{ serializer.declare_model(model) }}
    """{{ model.description(is_operation_file=False) | wordwrap(width=95, break_long_words=False, break_on_hyphens=False, wrapstring='\n    ')  }}
    {% if model.discriminated_subtypes %}

    {{ serializer.discriminator_docstring(model) | wordwrap(width=95, break_long_words=False, break_on_hyphens=False, wrapstring='\n    ') }}
    {% endif %}
    {% if model.has_readonly_or_constant_property %}

    Readonly variables are only populated by the server, and will be ignored when sending a request.
    {% endif %}
    {% if (model.properties | selectattr('optional', "equalto", false) | first) is defined %}

    All required parameters must be populated in order to send to server.
    {% endif %}

    {% if model.properties != None %}
        {% for p in model.properties %}
            {% for line in serializer.variable_documentation_string(p) %}
                {% for doc_string in line.replace('\n', '\n ').split('\n') %}
    {{ macros.wrap_model_string(doc_string, '\n     ') -}}
                {% endfor %}
            {% endfor %}
        {% endfor %}
    {% endif %}
    """

    {% if model.is_polymorphic %}
    __mapping__: Dict[str, _model_base.Model] = {}
    {% endif %}
    {% for p in serializer.get_properties_to_declare(model)%}
    {{ serializer.declare_property(p) }}
        {% set prop_description = p.description(is_operation_file=False).replace('"', '\\"') %}
        {% if prop_description %}
    """{{ macros.wrap_model_string(prop_description, '\n     ', '\"\"\"') -}}
        {% endif %}
    {% endfor %}

    {% if code_model.enable_flatten and model.has_flatten_property %}
    _flatten_items = ["{{ model.flatten_items|join('\", \"') }}"]
    {% endif %}

    {% if not model.internal and serializer.init_line(model) %}
    @overload
    def __init__(
        self,
        {% for param_signature in serializer.init_line(model) %}
        {{ param_signature }}
        {% endfor %}
    ):
        ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    {% endif %}
    {% set initialize_properties = serializer.initialize_properties(model) %}
    {% if not model.internal and serializer.init_line(model) or initialize_properties %}
    def __init__(self, *args: Any, **kwargs: Any) -> None:{{ '# pylint: disable=useless-super-delegation' if not initialize_properties else '' }}
        {% if code_model.enable_flatten and model.has_flatten_property %}
        {% set flatten_property_name = model.flatten_property.client_name %}
        {% set flatten_property_wire_name = model.flatten_property.wire_name %}
        flatten_map = {k: kwargs.pop(k, None) for k in self._flatten_items}
        super().__init__(*args, **kwargs)
        for k, v in flatten_map.items():
            if v is not None:
                setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self._flatten_items:
            if self.{{ flatten_property_name }}:
                return getattr(self.{{ flatten_property_name }}, name)
            return None
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self._flatten_items:
            if self.{{ flatten_property_name }} is None:
                class_type = self._attr_to_rest_field["{{ flatten_property_wire_name }}"]._class_type
                self.{{ flatten_property_name }} = class_type()
            setattr(self.{{ flatten_property_name }}, key, value)
        else:
            super().__setattr__(key, value)
        {% else %}
        super().__init__(*args, **kwargs)
        {% endif %}
    {% for initialize_property in initialize_properties %}
        {{ initialize_property }}
    {% endfor %}
    {% endif %}
