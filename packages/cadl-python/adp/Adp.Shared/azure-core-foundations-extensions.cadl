using Cadl.Http;
using Cadl.Rest;
using Cadl.Versioning;
using Azure.Core;
using Azure.Core.Foundations;
using Adp;

@versioned(Versions)
@versionedDependency(
  [[Versions.v1_0_Preview_1, Adp.Versions.v2023_00_00_for_public_preview]]
)
namespace Azure.Core.Foundations.Extensions;

enum Versions {
  v1_0_Preview_1,
}

/*
 This CADL file was created to customize the existing implementation from the foundations library.
 In this file we have addressed the following issues:
 1. Avoid inlining of the models - required by ADP backend and also by the AutoRest. All models must be references and have schema definitions in the OpenApi spec.
 2. In ADP we are using slightly different model for LRO. It has additional state [Created] and the operation type property.
 3. The `CustomBodyWrapper` just adds the `@doc` to the body element to suppress warnings during the spec validation.
 4. The `CustomResourceOkResponse` wraps the <T> with `@body`.
 5. The `CustomErrorResponse` adds missing header `x-ms-error-code` to the default error response
 6. For all LRO operations - add operation status location header and OK response where necessary to align with AutoRest code generator.
 7. The `CustomSingletonResource` has been introduced to allow operations on singleton child resources that have no identifier.
*/

@doc("""
Note, by adding this model we solve AutoRest validation issue.
Autorest requires that required properties will not be read-only.

Provides the 'ETag' field to enable conditional (cached) requests.  This model can be spread
into responses and item models to convey the ETag when it cannot simplybe conveyed in a header.
""")
model CustomEtagProperty {
  @visibility("read", "update")
  @doc("The entity tag for this resource.")
  etag: string;
}

@doc("List {name} resources", TResource)
op CustomResourceList<
  TResource extends object,
  TCustom extends Foundations.CustomizationFields = {}
> is Foundations.ResourceList<
  TResource,
  Foundations.CustomParameters<TCustom>,
  Page<TResource>
>;

@doc("Creates or replaces a {name}", TResource)
@createsOrReplacesResource(TResource)
op CustomResourceCreateOrReplace<
  TResource extends object,
  TResourceCreateParams extends object
> is Foundations.ResourceOperation<
  TResource,
  TResourceCreateParams,
  CustomResourceCreatedOrOkResponse<TResource>
>;

@doc("A wrapper for optional parameter in the body. The intent of model is to add description to 'body'")
model CustomBodyWrapper<T extends object> {
  @doc("Parameter of type '{name}' in the body.", T)
  @body
  body?: T;
}

@doc("A wrapper for required parameter in the body. The intent of model is to add description to 'body' and make it requred.")
model CustomRequiredBodyWrapper<T extends object> {
  @doc("Parameter of type '{name}' in the body.", T)
  @body
  body: T;
}

@doc("A {name} resource was successfully created.", T)
model CustomResourceCreatedResponse<T extends object> {
  ...Cadl.Http.Response<201>;
  @body body: T;
}

model CustomResourceOkResponse<T extends object> {
  ...Cadl.Http.Response<200>;
  @body body: T;
}

alias CustomResourceCreatedOrOkResponse<T extends object> = CustomResourceCreatedResponse<T> | CustomResourceOkResponse<T>;

@autoRoute
@doc("Creates a {name}.", TResource)
@createsResource(TResource)
op CustomLongRunningResourceCreateUsingHttpPost<
  TResource extends object,
  TResourceCreateParams extends object = {},
  TCustom extends Foundations.CustomizationFields = CustomPostLroRequestResponseHeaders
>(
  ...Foundations.CollectionKeysOf<TResource>,
  ...TResourceCreateParams,
  ...Foundations.ApiVersionParameter,
  ...Foundations.CustomParameters<TCustom>,
  ...LongRunningOperationIdHeader
): (AcceptedResponse<CustomBodyWrapper<LongRunningOperationResponse>> &
  Foundations.CustomResponseFields<TCustom>) | CustomResourceOkResponse<TResource> | CustomErrorResponse;

@autoRoute
@doc("Creates a {name}", TResource)
@createsResource(TResource)
op CustomLongRunningResourceCreateWithServiceProvidedName<
  TResource extends object,
  TResourceCreateParams extends object = {},
  TCustom extends Foundations.CustomizationFields = CustomPostLroRequestResponseHeaders
>(
  ...Foundations.CollectionKeysOf<TResource>,
  ...TResourceCreateParams,
  ...Foundations.ApiVersionParameter,
  ...Foundations.CustomParameters<TCustom>,
  ...LongRunningOperationIdHeader
): (AcceptedResponse<CustomBodyWrapper<LongRunningOperationResponse>> &
  Foundations.CustomResponseFields<TCustom>) | CustomResourceOkResponse<TResource> | CustomErrorResponse;

@action
@autoRoute
@actionSeparator(":")
@doc(
  "Runs a custom action on {name} as long-running operation (LRO)",
  TResource
)
op CustomLongRunningResourceAction<
  TResource extends object,
  TRequestParameters extends object = {},
  TCustom extends Foundations.CustomizationFields = CustomPostLroRequestResponseHeaders
>(
  ...Foundations.ItemKeysOf<TResource>,
  ...TRequestParameters,
  ...Foundations.ApiVersionParameter,
  ...Foundations.CustomParameters<TCustom>,
  ...LongRunningOperationIdHeader
): (AcceptedResponse<CustomBodyWrapper<LongRunningOperationResponse>> &
  Foundations.CustomResponseFields<TCustom>) | CustomResourceOkResponse<TResource> | CustomErrorResponse;

@action
@autoRoute
@actionSeparator(":")
@doc(
  "Runs a custom action on {name} as long-running operation (LRO)",
  TResource
)
op CustomLongRunningResourceActionWithParameters<
  TResource extends object,
  TParams extends object = {},
  TCustom extends Foundations.CustomizationFields = CustomPostLroRequestResponseHeaders
>(
  ...Foundations.ItemKeysOf<TResource>,
  ...TParams,
  ...Foundations.ApiVersionParameter,
  ...Foundations.CustomParameters<TCustom>,
  ...LongRunningOperationIdHeader
): (AcceptedResponse<CustomBodyWrapper<LongRunningOperationResponse>> &
  Foundations.CustomResponseFields<TCustom>) | CustomResourceOkResponse<TResource> | CustomErrorResponse;

#suppress "@azure-tools/cadl-azure-resource-manager/no-response-body" "This operation must return a status monitor in its response."
@autoRoute
@collectionAction(TResource)
@actionSeparator(":")
op CustomLongRunningResourceCollectionAction<
  TResource extends object,
  TParams extends object = {},
  TResponse extends object = TResource
> is Foundations.ResourceCollectionOperation<
  TResource,
  TParams & LongRunningOperationIdHeader & CustomRepeatabilityRequestHeaders,
  (AcceptedResponse<CustomBodyWrapper<LongRunningOperationResponse>> &
    CustomRepeatabilityResponseHeaders &
    LongRunningOperationStatusLocationHeader) | CustomResourceOkResponse<TResponse>
>;

#suppress "@azure-tools/cadl-azure-resource-manager/no-response-body" "We do support bodies in data plane service APIs..."
@delete
@autoRoute
@doc("Delete a {name} asynchronously.", TResource)
@deletesResource(TResource)
op CustomLongRunningResourceDelete<TResource extends object>(
  ...Foundations.ItemKeysOf<TResource>,
  ...Foundations.ApiVersionParameter,
  ...LongRunningOperationIdHeader
): (AcceptedResponse<CustomBodyWrapper<LongRunningOperationResponse>> &
  LongRunningOperationStatusLocationHeader) | NoContentResponse | CustomErrorResponse;

@doc("Error response with 'x-ms-error-code' header.")
@friendlyName("CustomErrorResponse")
model CustomErrorResponse is Foundations.ErrorResponse {
  ...XmsErrorCodeHeader;
}

@autoRoute
@get
op CustomSingletonResourceRead<
  TResource extends object,
  TParams extends object = {},
  TResponse extends object = TResource
> is Foundations.ResourceCollectionOperation<
  TResource,
  TParams,
  CustomResourceOkResponse<TResponse>
>;

@doc("Creates or replaces a {name}", TResource)
@createsOrReplacesResource(TResource)
@autoRoute
op CustomSingletonResourceCreateOrReplace<
  TResource extends object,
  TParams extends object,
  TResponse extends object = TResource
> is Foundations.ResourceCollectionOperation<
  TResource,
  TParams,
  CustomResourceCreatedOrOkResponse<TResponse>
>;

@doc("Indicates whether the repeatable request was accepted or rejected.")
enum RepeatabilityResult {
  "accepted",
  "rejected",
}

@doc("Provides the 'Repeatability-Result' header to enable repeatable requests.")
model CustomRepeatabilityResponseHeaders {
  @visibility("read")
  @header("Repeatability-Result")
  @doc("Indicates whether the repeatable request was accepted or rejected.")
  repeatabilityResult?: RepeatabilityResult;
}

@doc("Provides the 'Repeatability-*' headers to support repeatability for POST requests.")
model CustomPostLroRequestResponseHeaders {
  @doc("Provides the 'Repeatability-*' headers to enable repeatable requests.")
  parameters: CustomRepeatabilityRequestHeaders;

  @doc("Provides the 'Repeatability-Result' and 'Operation-Location' headers to support repeatability for POST LRO.")
  response: CustomRepeatabilityResponseHeaders &
    LongRunningOperationStatusLocationHeader;
}

@doc("""
  Provides the 'Repeatability-*' headers to support repeatability for POST requests.

  TODO: Remove this customized model after upgrading to new csharp emitter 
  with fix for the following issue: https://github.com/Azure/autorest.csharp/issues/2970
  and use the existing "Azure.Core.RepeatabilityRequestHeaders" instead.
  """)
model CustomRepeatabilityRequestHeaders {
  @visibility("create", "update", "delete")
  @header("Repeatability-Request-ID")
  @doc("An opaque, globally-unique, client-generated string identifier for the request.")
  repeatabilityRequestId?: string;

  @visibility("create", "update", "delete")
  @doc("Specifies the date and time at which the request was first created.")
  @header("Repeatability-First-Sent")
  repeatabilityFirstSent?: zonedDateTime;

  @visibility("create", "update", "delete")
  @doc("An opaque, globally-unique, client-generated string identifier for the client.")
  @header("Repeatability-Client-ID")
  repeatabilityClientId?: string;
}
