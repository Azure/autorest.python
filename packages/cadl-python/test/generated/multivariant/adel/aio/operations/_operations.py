# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import json
import sys
from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ... import models as _models
from ..._model_base import AzureJSONEncoder, _deserialize
from ...operations._operations import (
    build_alert_configs_create_request,
    build_alert_configs_delete_request,
    build_alert_configs_list_request,
    build_alert_configs_read_request,
    build_alert_configs_update_request,
    build_datasets_create_request,
    build_datasets_delete_request,
    build_datasets_list_request,
    build_datasets_preview_data_request,
    build_datasets_read_request,
    build_evaluations_create_request,
    build_evaluations_delete_request,
    build_evaluations_list_request,
    build_evaluations_read_request,
    build_hooks_create_request,
    build_hooks_delete_request,
    build_hooks_list_request,
    build_hooks_read_request,
    build_hooks_update_request,
    build_models_create_request,
    build_models_delete_request,
    build_models_detect_request,
    build_models_list_request,
    build_models_read_request,
    build_replays_create_request,
    build_replays_delete_request,
    build_replays_list_request,
    build_replays_read_request,
    build_schedules_create_request,
    build_schedules_delete_request,
    build_schedules_get_history_request,
    build_schedules_list_request,
    build_schedules_read_request,
    build_schedules_update_request,
)

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class AlertConfigsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~adel.aio.Adel`'s
        :attr:`alert_configs` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create(
        self,
        alert_config_name: str,
        body: Union[_models.AlertConfig, JSON],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AlertConfig:
        """create.

        :param alert_config_name: Unique identifier of an alert configuration. This parameter is
         case-sensitive. Required.
        :type alert_config_name: str
        :param body: Required.
        :type body: ~adel.models.AlertConfig or JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AlertConfig. This object is MutableMapping-compatible.
        :rtype: ~adel.models.AlertConfig
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, alert_config_name: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AlertConfig:
        """create.

        :param alert_config_name: Unique identifier of an alert configuration. This parameter is
         case-sensitive. Required.
        :type alert_config_name: str
        :param body: Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AlertConfig. This object is MutableMapping-compatible.
        :rtype: ~adel.models.AlertConfig
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(
        self, alert_config_name: str, body: Union[_models.AlertConfig, JSON, IO], **kwargs: Any
    ) -> _models.AlertConfig:
        """create.

        :param alert_config_name: Unique identifier of an alert configuration. This parameter is
         case-sensitive. Required.
        :type alert_config_name: str
        :param body: Is either a model type or a IO type. Required.
        :type body: ~adel.models.AlertConfig or JSON or IO
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: AlertConfig. This object is MutableMapping-compatible.
        :rtype: ~adel.models.AlertConfig
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.AlertConfig]

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=AzureJSONEncoder)

        request = build_alert_configs_create_request(
            alert_config_name=alert_config_name,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = _deserialize(_models.AlertConfig, response.json())

        if response.status_code == 201:
            deserialized = _deserialize(_models.AlertConfig, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def read(self, alert_config_name: str, **kwargs: Any) -> _models.AlertConfig:
        """read.

        :param alert_config_name: Unique identifier of an alert configuration. This parameter is
         case-sensitive. Required.
        :type alert_config_name: str
        :return: AlertConfig. This object is MutableMapping-compatible.
        :rtype: ~adel.models.AlertConfig
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.AlertConfig]

        request = build_alert_configs_read_request(
            alert_config_name=alert_config_name,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = _deserialize(_models.AlertConfig, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def list(
        self,
        *,
        skip: Optional[int] = None,
        sort_by: Optional[str] = None,
        order_by: Optional[Union[str, "_models.OrderBy"]] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.AlertConfig"]:
        """list.

        :keyword skip: The number of records to skip from the list of records based on the sorting
         field and ordering method specified. By default, records are ranked by descending created time
         (UTC). Default value is None.
        :paramtype skip: int
        :keyword sort_by: The name of the field on which you want to sort records. By default, records
         are sorted by created time (UTC). Default value is None.
        :paramtype sort_by: str
        :keyword order_by: Determines whether the records will be returned in descending or ascending
         order. By default, records are ranked in descending order. Known values are: "ASCENDING" and
         "DESCENDING". Default value is None.
        :paramtype order_by: str or ~adel.models.OrderBy
        :return: An iterator like instance of AlertConfig. This object is MutableMapping-compatible.
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~adel.models.AlertConfig]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models._models.PagedAlertConfig]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_alert_configs_list_request(
                    skip=skip,
                    sort_by=sort_by,
                    order_by=order_by,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                request = HttpRequest("GET", next_link)
                path_format_arguments = {
                    "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = _deserialize(_models.PagedAlertConfig, pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self, alert_config_name: str, **kwargs: Any
    ) -> None:
        """delete.

        :param alert_config_name: Unique identifier of an alert configuration. This parameter is
         case-sensitive. Required.
        :type alert_config_name: str
        :return: None. This object is MutableMapping-compatible.
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_alert_configs_delete_request(
            alert_config_name=alert_config_name,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @overload
    async def update(
        self,
        alert_config_name: str,
        body: Union[_models.AlertConfig, JSON],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.AlertConfig:
        """update.

        :param alert_config_name: Unique identifier of an alert configuration. This parameter is
         case-sensitive. Required.
        :type alert_config_name: str
        :param body: Required.
        :type body: ~adel.models.AlertConfig or JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: AlertConfig. This object is MutableMapping-compatible.
        :rtype: ~adel.models.AlertConfig
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self, alert_config_name: str, body: IO, *, content_type: str = "application/merge-patch+json", **kwargs: Any
    ) -> _models.AlertConfig:
        """update.

        :param alert_config_name: Unique identifier of an alert configuration. This parameter is
         case-sensitive. Required.
        :type alert_config_name: str
        :param body: Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: AlertConfig. This object is MutableMapping-compatible.
        :rtype: ~adel.models.AlertConfig
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(
        self, alert_config_name: str, body: Union[_models.AlertConfig, JSON, IO], **kwargs: Any
    ) -> _models.AlertConfig:
        """update.

        :param alert_config_name: Unique identifier of an alert configuration. This parameter is
         case-sensitive. Required.
        :type alert_config_name: str
        :param body: Is either a model type or a IO type. Required.
        :type body: ~adel.models.AlertConfig or JSON or IO
        :keyword content_type: Default value is None.
        :paramtype content_type: str
        :return: AlertConfig. This object is MutableMapping-compatible.
        :rtype: ~adel.models.AlertConfig
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("content-type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.AlertConfig]

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=AzureJSONEncoder)

        request = build_alert_configs_update_request(
            alert_config_name=alert_config_name,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = _deserialize(_models.AlertConfig, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized


class HooksOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~adel.aio.Adel`'s
        :attr:`hooks` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create(
        self, hook_name: str, body: Union[_models.Hook, JSON], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Hook:
        """create.

        :param hook_name: Unique identifier of a hook. This parameter is case-sensitive. Required.
        :type hook_name: str
        :param body: Required.
        :type body: ~adel.models.Hook or JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Hook. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Hook
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, hook_name: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Hook:
        """create.

        :param hook_name: Unique identifier of a hook. This parameter is case-sensitive. Required.
        :type hook_name: str
        :param body: Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Hook. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Hook
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(self, hook_name: str, body: Union[_models.Hook, JSON, IO], **kwargs: Any) -> _models.Hook:
        """create.

        :param hook_name: Unique identifier of a hook. This parameter is case-sensitive. Required.
        :type hook_name: str
        :param body: Is either a model type or a IO type. Required.
        :type body: ~adel.models.Hook or JSON or IO
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: Hook. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Hook
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Hook]

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=AzureJSONEncoder)

        request = build_hooks_create_request(
            hook_name=hook_name,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = _deserialize(_models.Hook, response.json())

        if response.status_code == 201:
            deserialized = _deserialize(_models.Hook, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def read(self, hook_name: str, **kwargs: Any) -> _models.Hook:
        """read.

        :param hook_name: Unique identifier of a hook. This parameter is case-sensitive. Required.
        :type hook_name: str
        :return: Hook. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Hook
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Hook]

        request = build_hooks_read_request(
            hook_name=hook_name,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = _deserialize(_models.Hook, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def list(
        self,
        *,
        skip: Optional[int] = None,
        sort_by: Optional[str] = None,
        order_by: Optional[Union[str, "_models.OrderBy"]] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.Hook"]:
        """list.

        :keyword skip: The number of records to skip from the list of records based on the sorting
         field and ordering method specified. By default, records are ranked by descending created time
         (UTC). Default value is None.
        :paramtype skip: int
        :keyword sort_by: The name of the field on which you want to sort records. By default, records
         are sorted by created time (UTC). Default value is None.
        :paramtype sort_by: str
        :keyword order_by: Determines whether the records will be returned in descending or ascending
         order. By default, records are ranked in descending order. Known values are: "ASCENDING" and
         "DESCENDING". Default value is None.
        :paramtype order_by: str or ~adel.models.OrderBy
        :return: An iterator like instance of Hook. This object is MutableMapping-compatible.
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~adel.models.Hook]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models._models.PagedHook]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_hooks_list_request(
                    skip=skip,
                    sort_by=sort_by,
                    order_by=order_by,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                request = HttpRequest("GET", next_link)
                path_format_arguments = {
                    "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = _deserialize(_models.PagedHook, pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def delete(self, hook_name: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """delete.

        :param hook_name: Unique identifier of a hook. This parameter is case-sensitive. Required.
        :type hook_name: str
        :return: None. This object is MutableMapping-compatible.
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_hooks_delete_request(
            hook_name=hook_name,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @overload
    async def update(
        self,
        hook_name: str,
        body: Union[_models.Hook, JSON],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.Hook:
        """update.

        :param hook_name: Unique identifier of a hook. This parameter is case-sensitive. Required.
        :type hook_name: str
        :param body: Required.
        :type body: ~adel.models.Hook or JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: Hook. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Hook
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self, hook_name: str, body: IO, *, content_type: str = "application/merge-patch+json", **kwargs: Any
    ) -> _models.Hook:
        """update.

        :param hook_name: Unique identifier of a hook. This parameter is case-sensitive. Required.
        :type hook_name: str
        :param body: Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: Hook. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Hook
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(self, hook_name: str, body: Union[_models.Hook, JSON, IO], **kwargs: Any) -> _models.Hook:
        """update.

        :param hook_name: Unique identifier of a hook. This parameter is case-sensitive. Required.
        :type hook_name: str
        :param body: Is either a model type or a IO type. Required.
        :type body: ~adel.models.Hook or JSON or IO
        :keyword content_type: Default value is None.
        :paramtype content_type: str
        :return: Hook. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Hook
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("content-type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Hook]

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=AzureJSONEncoder)

        request = build_hooks_update_request(
            hook_name=hook_name,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = _deserialize(_models.Hook, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized


class DatasetsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~adel.aio.Adel`'s
        :attr:`datasets` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create(
        self,
        dataset_name: str,
        body: Union[_models.RequestDataset, JSON],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Dataset:
        """create.

        :param dataset_name: Unique identifier of a dataset. This parameter is case-sensitive.
         Required.
        :type dataset_name: str
        :param body: Required.
        :type body: ~adel.models.RequestDataset or JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Dataset. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Dataset
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, dataset_name: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Dataset:
        """create.

        :param dataset_name: Unique identifier of a dataset. This parameter is case-sensitive.
         Required.
        :type dataset_name: str
        :param body: Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Dataset. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Dataset
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(
        self, dataset_name: str, body: Union[_models.RequestDataset, JSON, IO], **kwargs: Any
    ) -> _models.Dataset:
        """create.

        :param dataset_name: Unique identifier of a dataset. This parameter is case-sensitive.
         Required.
        :type dataset_name: str
        :param body: Is either a model type or a IO type. Required.
        :type body: ~adel.models.RequestDataset or JSON or IO
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: Dataset. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Dataset
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Dataset]

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=AzureJSONEncoder)

        request = build_datasets_create_request(
            dataset_name=dataset_name,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = _deserialize(_models.Dataset, response.json())

        if response.status_code == 201:
            deserialized = _deserialize(_models.Dataset, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def read(self, dataset_name: str, **kwargs: Any) -> _models.Dataset:
        """read.

        :param dataset_name: Unique identifier of a dataset. This parameter is case-sensitive.
         Required.
        :type dataset_name: str
        :return: Dataset. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Dataset
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Dataset]

        request = build_datasets_read_request(
            dataset_name=dataset_name,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = _deserialize(_models.Dataset, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def list(
        self,
        *,
        skip: Optional[int] = None,
        sort_by: Optional[str] = None,
        order_by: Optional[Union[str, "_models.OrderBy"]] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.Dataset"]:
        """list.

        :keyword skip: The number of records to skip from the list of records based on the sorting
         field and ordering method specified. By default, records are ranked by descending created time
         (UTC). Default value is None.
        :paramtype skip: int
        :keyword sort_by: The name of the field on which you want to sort records. By default, records
         are sorted by created time (UTC). Default value is None.
        :paramtype sort_by: str
        :keyword order_by: Determines whether the records will be returned in descending or ascending
         order. By default, records are ranked in descending order. Known values are: "ASCENDING" and
         "DESCENDING". Default value is None.
        :paramtype order_by: str or ~adel.models.OrderBy
        :return: An iterator like instance of Dataset. This object is MutableMapping-compatible.
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~adel.models.Dataset]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models._models.PagedDataset]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_datasets_list_request(
                    skip=skip,
                    sort_by=sort_by,
                    order_by=order_by,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                request = HttpRequest("GET", next_link)
                path_format_arguments = {
                    "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = _deserialize(_models.PagedDataset, pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def delete(self, dataset_name: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """delete.

        :param dataset_name: Unique identifier of a dataset. This parameter is case-sensitive.
         Required.
        :type dataset_name: str
        :return: None. This object is MutableMapping-compatible.
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_datasets_delete_request(
            dataset_name=dataset_name,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @overload
    async def preview_data(
        self, body: Union[_models.DatasetPreviewRequest, JSON], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DatasetPreviewResponse:
        """Query data from data source to preview.

        Verify data schema and preview data before/after a dataset is created. View raw data to better
        diagnose and explain a detected anomaly.

        :param body: Required.
        :type body: ~adel.models.DatasetPreviewRequest or JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DatasetPreviewResponse. This object is MutableMapping-compatible.
        :rtype: ~adel.models.DatasetPreviewResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def preview_data(
        self, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DatasetPreviewResponse:
        """Query data from data source to preview.

        Verify data schema and preview data before/after a dataset is created. View raw data to better
        diagnose and explain a detected anomaly.

        :param body: Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DatasetPreviewResponse. This object is MutableMapping-compatible.
        :rtype: ~adel.models.DatasetPreviewResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def preview_data(
        self, body: Union[_models.DatasetPreviewRequest, JSON, IO], **kwargs: Any
    ) -> _models.DatasetPreviewResponse:
        """Query data from data source to preview.

        Verify data schema and preview data before/after a dataset is created. View raw data to better
        diagnose and explain a detected anomaly.

        :param body: Is either a model type or a IO type. Required.
        :type body: ~adel.models.DatasetPreviewRequest or JSON or IO
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: DatasetPreviewResponse. This object is MutableMapping-compatible.
        :rtype: ~adel.models.DatasetPreviewResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DatasetPreviewResponse]

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=AzureJSONEncoder)

        request = build_datasets_preview_data_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = _deserialize(_models.DatasetPreviewResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized


class ModelsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~adel.aio.Adel`'s
        :attr:`models` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create(
        self,
        model_name: str,
        body: Union[_models.RequestModel, JSON],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Model:
        """create.

        :param model_name: Unique identifier of a model. This parameter is case-sensitive. Required.
        :type model_name: str
        :param body: Required.
        :type body: ~adel.models.RequestModel or JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Model. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Model
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, model_name: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Model:
        """create.

        :param model_name: Unique identifier of a model. This parameter is case-sensitive. Required.
        :type model_name: str
        :param body: Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Model. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Model
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(
        self, model_name: str, body: Union[_models.RequestModel, JSON, IO], **kwargs: Any
    ) -> _models.Model:
        """create.

        :param model_name: Unique identifier of a model. This parameter is case-sensitive. Required.
        :type model_name: str
        :param body: Is either a model type or a IO type. Required.
        :type body: ~adel.models.RequestModel or JSON or IO
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: Model. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Model
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Model]

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=AzureJSONEncoder)

        request = build_models_create_request(
            model_name=model_name,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = _deserialize(_models.Model, response.json())

        if response.status_code == 201:
            deserialized = _deserialize(_models.Model, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def read(self, model_name: str, **kwargs: Any) -> _models.Model:
        """read.

        :param model_name: Unique identifier of a model. This parameter is case-sensitive. Required.
        :type model_name: str
        :return: Model. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Model
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Model]

        request = build_models_read_request(
            model_name=model_name,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = _deserialize(_models.Model, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def list(
        self,
        *,
        skip: Optional[int] = None,
        sort_by: Optional[str] = None,
        order_by: Optional[Union[str, "_models.OrderBy"]] = None,
        status: Optional[Union[str, "_models.ModelStatus"]] = None,
        dataset_names: Optional[str] = None,
        top_per_dataset: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.Model"]:
        """list.

        :keyword skip: The number of records to skip from the list of records based on the sorting
         field and ordering method specified. By default, records are ranked by descending created time
         (UTC). Default value is None.
        :paramtype skip: int
        :keyword sort_by: The name of the field on which you want to sort records. By default, records
         are sorted by created time (UTC). Default value is None.
        :paramtype sort_by: str
        :keyword order_by: Determines whether the records will be returned in descending or ascending
         order. By default, records are ranked in descending order. Known values are: "ASCENDING" and
         "DESCENDING". Default value is None.
        :paramtype order_by: str or ~adel.models.OrderBy
        :keyword status: Filter models by one of the training statuses: CREATED, RUNNING, COMPLETED, or
         FAILED. Known values are: "CREATED", "RUNNING", "COMPLETED", and "FAILED". Default value is
         None.
        :paramtype status: str or ~adel.models.ModelStatus
        :keyword dataset_names: Filter models by a list of training dataset name(s). Format the list as
         a comma-separated string, no space allowed. For each dataset, by default the list of models are
         ranked by descending model created time (UTC). Default value is None.
        :paramtype dataset_names: str
        :keyword top_per_dataset: The total number of models to be returned per dataset, ordered by
         created time descending. By default, the full list of models will be returned for the dataset
         name(s) in your filter. Default value is None.
        :paramtype top_per_dataset: int
        :return: An iterator like instance of Model. This object is MutableMapping-compatible.
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~adel.models.Model]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models._models.PagedModel]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_models_list_request(
                    skip=skip,
                    sort_by=sort_by,
                    order_by=order_by,
                    status=status,
                    dataset_names=dataset_names,
                    top_per_dataset=top_per_dataset,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                request = HttpRequest("GET", next_link)
                path_format_arguments = {
                    "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = _deserialize(_models.PagedModel, pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def delete(self, model_name: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """delete.

        :param model_name: Unique identifier of a model. This parameter is case-sensitive. Required.
        :type model_name: str
        :return: None. This object is MutableMapping-compatible.
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_models_delete_request(
            model_name=model_name,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @overload
    async def detect(
        self,
        model_name: str,
        body: Union[_models.DetectionRequest, JSON],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DetectionResult:
        """Detect Multivariate Anomaly - Sync.

        Detect anomalies with a trained model and multivariate time-series data points specified in the
        request body. This API is recommended to be embedded in an inference schedule set up for
        continuous real-time inference. Please refer to the official documentation for the detailed
        quota and limits.

        :param model_name: Required.
        :type model_name: str
        :param body: Required.
        :type body: ~adel.models.DetectionRequest or JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DetectionResult. This object is MutableMapping-compatible.
        :rtype: ~adel.models.DetectionResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def detect(
        self, model_name: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DetectionResult:
        """Detect Multivariate Anomaly - Sync.

        Detect anomalies with a trained model and multivariate time-series data points specified in the
        request body. This API is recommended to be embedded in an inference schedule set up for
        continuous real-time inference. Please refer to the official documentation for the detailed
        quota and limits.

        :param model_name: Required.
        :type model_name: str
        :param body: Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DetectionResult. This object is MutableMapping-compatible.
        :rtype: ~adel.models.DetectionResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def detect(
        self, model_name: str, body: Union[_models.DetectionRequest, JSON, IO], **kwargs: Any
    ) -> _models.DetectionResult:
        """Detect Multivariate Anomaly - Sync.

        Detect anomalies with a trained model and multivariate time-series data points specified in the
        request body. This API is recommended to be embedded in an inference schedule set up for
        continuous real-time inference. Please refer to the official documentation for the detailed
        quota and limits.

        :param model_name: Required.
        :type model_name: str
        :param body: Is either a model type or a IO type. Required.
        :type body: ~adel.models.DetectionRequest or JSON or IO
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: DetectionResult. This object is MutableMapping-compatible.
        :rtype: ~adel.models.DetectionResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DetectionResult]

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=AzureJSONEncoder)

        request = build_models_detect_request(
            model_name=model_name,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = _deserialize(_models.DetectionResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized


class EvaluationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~adel.aio.Adel`'s
        :attr:`evaluations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create(
        self,
        evaluation_name: str,
        body: Union[_models.RequestEvaluation, JSON],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Evaluation:
        """create.

        :param evaluation_name: Unique identifier of a model evaluation. This parameter is
         case-sensitive. Required.
        :type evaluation_name: str
        :param body: Required.
        :type body: ~adel.models.RequestEvaluation or JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Evaluation. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Evaluation
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, evaluation_name: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Evaluation:
        """create.

        :param evaluation_name: Unique identifier of a model evaluation. This parameter is
         case-sensitive. Required.
        :type evaluation_name: str
        :param body: Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Evaluation. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Evaluation
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(
        self, evaluation_name: str, body: Union[_models.RequestEvaluation, JSON, IO], **kwargs: Any
    ) -> _models.Evaluation:
        """create.

        :param evaluation_name: Unique identifier of a model evaluation. This parameter is
         case-sensitive. Required.
        :type evaluation_name: str
        :param body: Is either a model type or a IO type. Required.
        :type body: ~adel.models.RequestEvaluation or JSON or IO
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: Evaluation. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Evaluation
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Evaluation]

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=AzureJSONEncoder)

        request = build_evaluations_create_request(
            evaluation_name=evaluation_name,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = _deserialize(_models.Evaluation, response.json())

        if response.status_code == 201:
            deserialized = _deserialize(_models.Evaluation, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def read(self, evaluation_name: str, **kwargs: Any) -> _models.Evaluation:
        """read.

        :param evaluation_name: Unique identifier of a model evaluation. This parameter is
         case-sensitive. Required.
        :type evaluation_name: str
        :return: Evaluation. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Evaluation
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Evaluation]

        request = build_evaluations_read_request(
            evaluation_name=evaluation_name,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = _deserialize(_models.Evaluation, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def list(
        self,
        *,
        skip: Optional[int] = None,
        sort_by: Optional[str] = None,
        order_by: Optional[Union[str, "_models.OrderBy"]] = None,
        status: Optional[Union[str, "_models.EvaluationStatus"]] = None,
        model_names: Optional[str] = None,
        top_per_model: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.Evaluation"]:
        """list.

        :keyword skip: The number of records to skip from the list of records based on the sorting
         field and ordering method specified. By default, records are ranked by descending created time
         (UTC). Default value is None.
        :paramtype skip: int
        :keyword sort_by: The name of the field on which you want to sort records. By default, records
         are sorted by created time (UTC). Default value is None.
        :paramtype sort_by: str
        :keyword order_by: Determines whether the records will be returned in descending or ascending
         order. By default, records are ranked in descending order. Known values are: "ASCENDING" and
         "DESCENDING". Default value is None.
        :paramtype order_by: str or ~adel.models.OrderBy
        :keyword status: Filter model evaluations by one of the evaluation statuses: CREATED, RUNNING,
         COMPLETED, or FAILED. Known values are: "CREATED", "RUNNING", "COMPLETED", and "FAILED".
         Default value is None.
        :paramtype status: str or ~adel.models.EvaluationStatus
        :keyword model_names: Filter evaluations by a list of model name(s). Format the list as a
         comma-separated string, no space allowed. For each model, by default the list of evaluations
         are ranked by descending evaluation created time (UTC). Default value is None.
        :paramtype model_names: str
        :keyword top_per_model: The total number of evaluations to be returned per model, ordered by
         created time descending. By default, the full list of evaluations will be returned for the
         model name(s) in your filter. Default value is None.
        :paramtype top_per_model: int
        :return: An iterator like instance of Evaluation. This object is MutableMapping-compatible.
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~adel.models.Evaluation]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models._models.PagedEvaluation]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_evaluations_list_request(
                    skip=skip,
                    sort_by=sort_by,
                    order_by=order_by,
                    status=status,
                    model_names=model_names,
                    top_per_model=top_per_model,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                request = HttpRequest("GET", next_link)
                path_format_arguments = {
                    "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = _deserialize(_models.PagedEvaluation, pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self, evaluation_name: str, **kwargs: Any
    ) -> None:
        """delete.

        :param evaluation_name: Unique identifier of a model evaluation. This parameter is
         case-sensitive. Required.
        :type evaluation_name: str
        :return: None. This object is MutableMapping-compatible.
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_evaluations_delete_request(
            evaluation_name=evaluation_name,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})


class SchedulesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~adel.aio.Adel`'s
        :attr:`schedules` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create(
        self,
        schedule_name: str,
        body: Union[_models.RequestSchedule, JSON],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Schedule:
        """create.

        :param schedule_name: Unique identifier of a live streaming inference schedule. This parameter
         is case-sensitive. Required.
        :type schedule_name: str
        :param body: Required.
        :type body: ~adel.models.RequestSchedule or JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Schedule. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Schedule
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, schedule_name: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Schedule:
        """create.

        :param schedule_name: Unique identifier of a live streaming inference schedule. This parameter
         is case-sensitive. Required.
        :type schedule_name: str
        :param body: Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Schedule. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Schedule
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(
        self, schedule_name: str, body: Union[_models.RequestSchedule, JSON, IO], **kwargs: Any
    ) -> _models.Schedule:
        """create.

        :param schedule_name: Unique identifier of a live streaming inference schedule. This parameter
         is case-sensitive. Required.
        :type schedule_name: str
        :param body: Is either a model type or a IO type. Required.
        :type body: ~adel.models.RequestSchedule or JSON or IO
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: Schedule. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Schedule
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Schedule]

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=AzureJSONEncoder)

        request = build_schedules_create_request(
            schedule_name=schedule_name,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = _deserialize(_models.Schedule, response.json())

        if response.status_code == 201:
            deserialized = _deserialize(_models.Schedule, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def read(self, schedule_name: str, **kwargs: Any) -> _models.Schedule:
        """read.

        :param schedule_name: Unique identifier of a live streaming inference schedule. This parameter
         is case-sensitive. Required.
        :type schedule_name: str
        :return: Schedule. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Schedule
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Schedule]

        request = build_schedules_read_request(
            schedule_name=schedule_name,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = _deserialize(_models.Schedule, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def list(
        self,
        *,
        skip: Optional[int] = None,
        sort_by: Optional[str] = None,
        order_by: Optional[Union[str, "_models.OrderBy"]] = None,
        status: Optional[Union[str, "_models.ScheduleStatus"]] = None,
        model_names: Optional[str] = None,
        top_per_model: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.Schedule"]:
        """list.

        :keyword skip: The number of records to skip from the list of records based on the sorting
         field and ordering method specified. By default, records are ranked by descending created time
         (UTC). Default value is None.
        :paramtype skip: int
        :keyword sort_by: The name of the field on which you want to sort records. By default, records
         are sorted by created time (UTC). Default value is None.
        :paramtype sort_by: str
        :keyword order_by: Determines whether the records will be returned in descending or ascending
         order. By default, records are ranked in descending order. Known values are: "ASCENDING" and
         "DESCENDING". Default value is None.
        :paramtype order_by: str or ~adel.models.OrderBy
        :keyword status: Filter inference schedules by one of the schedule statuses: ACTIVE,
         CLIENTPAUSED or SERVERPAUSED. Known values are: "ACTIVE", "CLIENTPAUSED", and "SERVERPAUSED".
         Default value is None.
        :paramtype status: str or ~adel.models.ScheduleStatus
        :keyword model_names: Filter inference schedules by a list of model name(s). Format the list as
         a comma-separated string, no space allowed. For each model, by default the list of inference
         schedules are ranked by descending inference schedule created time (UTC). Default value is
         None.
        :paramtype model_names: str
        :keyword top_per_model: The total number of inference schedules to be returned per model,
         ordered by created time descending. By default, the full list of inference schedules will be
         returned for the model name(s) in your filter. Default value is None.
        :paramtype top_per_model: int
        :return: An iterator like instance of Schedule. This object is MutableMapping-compatible.
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~adel.models.Schedule]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models._models.PagedSchedule]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_schedules_list_request(
                    skip=skip,
                    sort_by=sort_by,
                    order_by=order_by,
                    status=status,
                    model_names=model_names,
                    top_per_model=top_per_model,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                request = HttpRequest("GET", next_link)
                path_format_arguments = {
                    "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = _deserialize(_models.PagedSchedule, pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def delete(self, schedule_name: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """delete.

        :param schedule_name: Unique identifier of a live streaming inference schedule. This parameter
         is case-sensitive. Required.
        :type schedule_name: str
        :return: None. This object is MutableMapping-compatible.
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_schedules_delete_request(
            schedule_name=schedule_name,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_history(
        self, schedule_name: str, *, start_time: str, end_time: str, **kwargs: Any
    ) -> _models.ScheduleHistoryResult:
        """Get historical detection results from the inference schedule.

        Use this API to retrieve detected anomalies over a historical time period specified in the
        request body. Please refer to the official documentation for the detailed quota and limits.

        :param schedule_name: Required.
        :type schedule_name: str
        :keyword start_time: Required.
        :paramtype start_time: str
        :keyword end_time: Required.
        :paramtype end_time: str
        :return: ScheduleHistoryResult. This object is MutableMapping-compatible.
        :rtype: ~adel.models.ScheduleHistoryResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ScheduleHistoryResult]

        request = build_schedules_get_history_request(
            schedule_name=schedule_name,
            start_time=start_time,
            end_time=end_time,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = _deserialize(_models.ScheduleHistoryResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def update(
        self,
        schedule_name: str,
        body: Union[_models.ScheduleUpdate, JSON],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> _models.Schedule:
        """Update an inference schedule.

        Pause/resume or update selected properties of an inference schedule.

        :param schedule_name: Unique identifier of a live streaming inference schedule. This parameter
         is case-sensitive. Required.
        :type schedule_name: str
        :param body: Required.
        :type body: ~adel.models.ScheduleUpdate or JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: Schedule. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Schedule
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self, schedule_name: str, body: IO, *, content_type: str = "application/merge-patch+json", **kwargs: Any
    ) -> _models.Schedule:
        """Update an inference schedule.

        Pause/resume or update selected properties of an inference schedule.

        :param schedule_name: Unique identifier of a live streaming inference schedule. This parameter
         is case-sensitive. Required.
        :type schedule_name: str
        :param body: Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: Schedule. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Schedule
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(
        self, schedule_name: str, body: Union[_models.ScheduleUpdate, JSON, IO], **kwargs: Any
    ) -> _models.Schedule:
        """Update an inference schedule.

        Pause/resume or update selected properties of an inference schedule.

        :param schedule_name: Unique identifier of a live streaming inference schedule. This parameter
         is case-sensitive. Required.
        :type schedule_name: str
        :param body: Is either a model type or a IO type. Required.
        :type body: ~adel.models.ScheduleUpdate or JSON or IO
        :keyword content_type: Default value is None.
        :paramtype content_type: str
        :return: Schedule. This object is MutableMapping-compatible.
        :rtype: ~adel.models.Schedule
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("content-type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Schedule]

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=AzureJSONEncoder)

        request = build_schedules_update_request(
            schedule_name=schedule_name,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = _deserialize(_models.Schedule, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized


class ReplaysOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~adel.aio.Adel`'s
        :attr:`replays` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create(
        self,
        replay_name: str,
        body: Union[_models.RequestScheduleReplay, JSON],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ScheduleReplay:
        """create.

        :param replay_name: Unique identifier of a replay on an inference schedule. This parameter is
         case-sensitive. Required.
        :type replay_name: str
        :param body: Required.
        :type body: ~adel.models.RequestScheduleReplay or JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ScheduleReplay. This object is MutableMapping-compatible.
        :rtype: ~adel.models.ScheduleReplay
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, replay_name: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ScheduleReplay:
        """create.

        :param replay_name: Unique identifier of a replay on an inference schedule. This parameter is
         case-sensitive. Required.
        :type replay_name: str
        :param body: Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ScheduleReplay. This object is MutableMapping-compatible.
        :rtype: ~adel.models.ScheduleReplay
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(
        self, replay_name: str, body: Union[_models.RequestScheduleReplay, JSON, IO], **kwargs: Any
    ) -> _models.ScheduleReplay:
        """create.

        :param replay_name: Unique identifier of a replay on an inference schedule. This parameter is
         case-sensitive. Required.
        :type replay_name: str
        :param body: Is either a model type or a IO type. Required.
        :type body: ~adel.models.RequestScheduleReplay or JSON or IO
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: ScheduleReplay. This object is MutableMapping-compatible.
        :rtype: ~adel.models.ScheduleReplay
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ScheduleReplay]

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=AzureJSONEncoder)

        request = build_replays_create_request(
            replay_name=replay_name,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = _deserialize(_models.ScheduleReplay, response.json())

        if response.status_code == 201:
            deserialized = _deserialize(_models.ScheduleReplay, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def read(self, replay_name: str, **kwargs: Any) -> _models.ScheduleReplay:
        """read.

        :param replay_name: Unique identifier of a replay on an inference schedule. This parameter is
         case-sensitive. Required.
        :type replay_name: str
        :return: ScheduleReplay. This object is MutableMapping-compatible.
        :rtype: ~adel.models.ScheduleReplay
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ScheduleReplay]

        request = build_replays_read_request(
            replay_name=replay_name,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = _deserialize(_models.ScheduleReplay, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def list(
        self,
        *,
        skip: Optional[int] = None,
        sort_by: Optional[str] = None,
        order_by: Optional[Union[str, "_models.OrderBy"]] = None,
        status: Optional[Union[str, "_models.ReplayStatus"]] = None,
        schedule_name: Optional[str] = None,
        top_per_schedule: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.ScheduleReplay"]:
        """list.

        :keyword skip: The number of records to skip from the list of records based on the sorting
         field and ordering method specified. By default, records are ranked by descending created time
         (UTC). Default value is None.
        :paramtype skip: int
        :keyword sort_by: The name of the field on which you want to sort records. By default, records
         are sorted by created time (UTC). Default value is None.
        :paramtype sort_by: str
        :keyword order_by: Determines whether the records will be returned in descending or ascending
         order. By default, records are ranked in descending order. Known values are: "ASCENDING" and
         "DESCENDING". Default value is None.
        :paramtype order_by: str or ~adel.models.OrderBy
        :keyword status: Filter inference schedule replay by one of the replay statuses: CREATED,
         RUNNING, COMPLETED, or FAILED. Known values are: "CREATED", "RUNNING", "COMPLETED", and
         "FAILED". Default value is None.
        :paramtype status: str or ~adel.models.ReplayStatus
        :keyword schedule_name: Filter replay records by a list of inference schedule name(s). Format
         the list as a comma-separated string, no space allowed. By default, the list of replay records
         are ranked by descending replay created time (UTC) for each inference schedule. Default value
         is None.
        :paramtype schedule_name: str
        :keyword top_per_schedule: The total number of replay records to be returned per inference
         schedule, ordered by created time descending. By default, the full list of replay records will
         be returned for the inference schedule name(s) in your filter. Default value is None.
        :paramtype top_per_schedule: int
        :return: An iterator like instance of ScheduleReplay. This object is MutableMapping-compatible.
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~adel.models.ScheduleReplay]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models._models.PagedScheduleReplay]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_replays_list_request(
                    skip=skip,
                    sort_by=sort_by,
                    order_by=order_by,
                    status=status,
                    schedule_name=schedule_name,
                    top_per_schedule=top_per_schedule,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                request = HttpRequest("GET", next_link)
                path_format_arguments = {
                    "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = _deserialize(_models.PagedScheduleReplay, pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def delete(self, replay_name: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """delete.

        :param replay_name: Unique identifier of a replay on an inference schedule. This parameter is
         case-sensitive. Required.
        :type replay_name: str
        :return: None. This object is MutableMapping-compatible.
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_replays_delete_request(
            replay_name=replay_name,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "resource": self._serialize.url("self._config.resource", self._config.resource, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})
