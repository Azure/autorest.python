@using System;
@using System.Linq;
@using AutoRest.Core.Model
@using AutoRest.Core.Utilities
@using AutoRest.Python
@using AutoRest.Python.Model
@using AutoRest.Python.vanilla.Templates
@inherits AutoRest.Python.PythonTemplate<AutoRest.Python.Azure.Model.MethodPya>
@EmptyLine
    def _@(Model.Name.ToPythonCase())_initial(
            self, @(Model.MethodParameterDeclaration(Model.AddCustomHeader))):
        @Model.BuildInputMappings()
@if (Model.InputParameterTransformation.Any())
{
@EmptyLine
}
@if (Model.ConstantParameters.Any())
{
	foreach (var parameter in Model.ConstantParameters)
	{
        @:@(parameter.Name) = @(parameter.DefaultValue)
	}
@EmptyLine
}
        # Construct URL
        url = self.@(((string)Model.Name).ToPythonCase()).metadata['url']
        @(Model.BuildUrlPath("url", Model.LogicalParameters))
@EmptyLine
        # Construct parameters
        query_parameters = {}
        @(Model.BuildUrlQuery("query_parameters", Model.LogicalParameters))
@EmptyLine
        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = '@(Model.RequestContentType)'
        @(Model.SetDefaultHeaders)
        @(Model.BuildHeaders("header_parameters"))
@EmptyLine
@if (Model.RequestBody != null)
{
        @:# Construct body
  if (Model.IsStreamRequestBody)
  {
    foreach (var parameter in Model.LocalParameters)
    {
      if (parameter.Location == ParameterLocation.Body && parameter.ModelType.IsPrimaryType(KnownPrimaryType.Stream))
      {
        @:body_content = upload_gen(@parameter.Name)
        break;
      }
    }
  }
  else if (Model.RequestBody.IsRequired)
  {
        @:body_content = self._serialize.body(@Model.RequestBody.Name, '@(Model.RequestBody.ModelType.ToPythonRuntimeTypeString())')
  }
  else
  {
        @:if @Model.RequestBody.Name is not None:
            @:body_content = self._serialize.body(@Model.RequestBody.Name, '@(Model.RequestBody.ModelType.ToPythonRuntimeTypeString())')
        @:else:
            @:body_content = None
  }
@EmptyLine
}
        # Construct and send request
        request = self._client.@(MethodPy.GetHttpFunction(Model.HttpMethod))(url, query_parameters)
@if (Model.RequestBody != null)
{
        @:response = self._client.send(
            @:request, header_parameters, body_content, stream=False, **operation_config)
}
else
{
        @:response = self._client.send(request, header_parameters, stream=False, **operation_config)
}
@EmptyLine
        if @Model.FailureStatusCodePredicate:
            @Model.RaisedException
@EmptyLine
@if (Model.HasAnyResponse)
{
        @:deserialized = None
  if (Model.HasResponseHeader)
  {
        @:header_dict = {}
  }
@EmptyLine
  foreach (var responsePair in Model.Responses.Where(r => r.Value.Body != null))
  {
        @:if response.status_code == @MethodPy.GetStatusCodeReference(responsePair.Key):
            @:deserialized = self._deserialize('@responsePair.Value.Body.ToPythonRuntimeTypeString()', response)
            @:@Model.AddIndividualResponseHeader(responsePair.Key)
  }
@EmptyLine
        @:if raw:
            @:client_raw_response = ClientRawResponse(deserialized, response)
@if (Model.HasResponseHeader)
{
            @:try:
                @:@Model.AddResponseHeader()
            @:except DeserializationError:
                @:pass # Deserialization of Headers here can fail
}
            @:return client_raw_response
@EmptyLine
        @:return deserialized
}
else
{
@* Bypass @:@Model.ReturnEmptyResponse, since the HEAD extensions bothers me here*@
        @:if raw:
            @:client_raw_response = ClientRawResponse(None, response)
@if (Model.HasResponseHeader)
{
            @:@Model.AddIndividualResponseHeader(null)
            @:@Model.AddResponseHeader()
}
            @:return client_raw_response

}
@EmptyLine
    def @(Model.Name.ToPythonCase())(
            self, @(Model.MethodParameterDeclaration(Model.AddCustomHeader))):
        """@(WrapComment(string.Empty, Model.BuildSummaryAndDescriptionString()))
@*need to fix comment here for long running function*@
@EmptyLine
@if (Model.Deprecated)
{
@:        .. warning::
@:           This method is deprecated
@EmptyLine
}

@foreach(var parameter in Model.DocumentationParameters)
{
@:        @ParameterWrapComment(string.Empty, MethodPy.GetParameterDocumentationString(parameter))
@:        @ParameterWrapComment(string.Empty, ":type " + parameter.Name + ": " + Model.GetDocumentationType(parameter.ModelType))
}
        @ParameterWrapComment(string.Empty, ":param dict custom_headers: headers that will be added to the request")
        @ParameterWrapComment(string.Empty, ":param bool raw: returns the direct response alongside the deserialized response")
        @ParameterWrapComment(string.Empty, ":return: An instance of AzureOperationPoller that returns " + Model.GetDocumentationTypeName(Model.ReturnType.Body) + " or ClientRawResponse if raw=true")
        @ParameterWrapComment(string.Empty, string.Format(":rtype: ~msrestazure.azure_operation.AzureOperationPoller[{0}] or ~msrest.pipeline.ClientRawResponse", Model.GetReturnTypeDocumentation(Model.ReturnType.Body)))
        @ParameterWrapComment(string.Empty, string.Format(":raises: {0}", Model.ExceptionDocumentation))
        """
@if (Model.Deprecated)
{
@:        @(string.Format("warnings.warn(\"Method {0} is deprecated\", DeprecationWarning)", ((string)Model.Name).ToPythonCase()))
}
        raw_result = self._@(Model.Name.ToPythonCase())_initial(
@foreach(var parameter in Model.DocumentationParameters)
{
@:            @parameter.Name=@parameter.Name,
}                    
            custom_headers=custom_headers,
            raw=True,
            **operation_config
        )
        if raw:
            return raw_result
@EmptyLine
        # Construct and send request
        def long_running_send():
            return raw_result.response
@EmptyLine
        def get_long_running_status(status_link, headers=None):
@EmptyLine
            request = self._client.get(status_link)
            if headers:
                request.headers.update(headers)
            header_parameters = {}
            header_parameters['x-ms-client-request-id'] = raw_result.response.request.headers['x-ms-client-request-id']
            return self._client.send(
                request, header_parameters, stream=False, **operation_config)
@EmptyLine
        def get_long_running_output(response):
@EmptyLine
            if @Model.FailureStatusCodePredicate:
                @Model.RaisedException
@EmptyLine
@if (Model.HasAnyResponse)
{
  if (Model.HasResponseHeader)
  {
            @:@Model.AddIndividualResponseHeader(null)
  }
            @:deserialized = self._deserialize('@Model.ReturnType.Body.ToPythonRuntimeTypeString()', response)
@EmptyLine
            @:if raw:
                @:client_raw_response = ClientRawResponse(deserialized, response)
                @:@Model.AddResponseHeader()
                @:return client_raw_response
@EmptyLine
            @:return deserialized
}
else
{
            @:@Model.ReturnEmptyResponse
}
@EmptyLine
        long_running_operation_timeout = operation_config.get(
            'long_running_operation_timeout',
            self.config.long_running_operation_timeout)
        return AzureOperationPoller(
            long_running_send, get_long_running_output,
            get_long_running_status, long_running_operation_timeout)
    @(((string)Model.Name).ToPythonCase()).metadata = {'url': '@(Model.Url)'}