@using System;
@using System.Linq;
@using AutoRest.Core.Model
@using AutoRest.Core.Utilities
@using AutoRest.Python
@using AutoRest.Python.Model
@using AutoRest.Python.vanilla.Templates
@inherits AutoRest.Python.PythonTemplate<AutoRest.Python.Azure.Model.MethodPya>
    def @(Model.Name.ToPythonCase())(
            self, @(Model.MethodParameterDeclaration(Model.AddCustomHeader))):
        """@(WrapComment(string.Empty, Model.BuildSummaryAndDescriptionString()))
@*need to fix comment here for long running function*@
@EmptyLine
@foreach(var parameter in Model.DocumentationParameters)
{
@:        @ParameterWrapComment(string.Empty, MethodPy.GetParameterDocumentationString(parameter))
@:        @ParameterWrapComment(string.Empty, ":type " + parameter.Name + ": " + Model.GetDocumentationType(parameter.ModelType))
}
        @ParameterWrapComment(string.Empty, ":param dict custom_headers: headers that will be added to the request")
        @ParameterWrapComment(string.Empty, ":param bool raw: returns the direct response alongside the deserialized response")
@if (Model.NeedsCallback)
{
@:        @ParameterWrapComment(string.Empty, ":param callback: When specified, will be called with each chunk of data that is streamed. The callback should take two arguments, the bytes of the current chunk of data and the response object. If the data is uploading, response will be None.")
@:        @ParameterWrapComment(string.Empty, ":type callback: Callable[Bytes, response=None]")
}
        @ParameterWrapComment(string.Empty, ":return: :class:`AzureOperationPoller<msrestazure.azure_operation.AzureOperationPoller>` instance that returns " + Model.GetDocumentationType(Model.ReturnType.Body) + " or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if raw=true")
        @ParameterWrapComment(string.Empty, ":rtype: :class:`AzureOperationPoller<msrestazure.azure_operation.AzureOperationPoller>` or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`")
        @ParameterWrapComment(string.Empty, string.Format(":raises: {0}", Model.ExceptionDocumentation))
        """
        @Model.BuildInputMappings()
@if (Model.InputParameterTransformation.Any())
{
@EmptyLine
}
@if (Model.ConstantParameters.Any())
{
	foreach (var parameter in Model.ConstantParameters)
	{
        @:@(parameter.Name) = @(parameter.DefaultValue)
	}
@EmptyLine
}
        # Construct URL
        url = '@(Model.Url)'
        @(Model.BuildUrlPath("url", Model.LogicalParameters))
@EmptyLine
        # Construct parameters
        query_parameters = {}
        @(Model.BuildUrlQuery("query_parameters", Model.LogicalParameters))
@EmptyLine
        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = '@(Model.RequestContentType)'
        @(Model.SetDefaultHeaders)
        @(Model.BuildHeaders("header_parameters"))
@EmptyLine
@if (Model.RequestBody != null)
{
        @:# Construct body
  if (Model.IsStreamRequestBody)
  {
    foreach (var parameter in Model.LocalParameters)
    {
      if (parameter.Location == ParameterLocation.Body && parameter.ModelType.IsPrimaryType(KnownPrimaryType.Stream))
      {
        @:body_content = upload_gen(@parameter.Name)
        break;
      }
    }
  }
  else if (Model.RequestBody.IsRequired)
  {
        @:body_content = self._serialize.body(@Model.RequestBody.Name, '@(Model.RequestBody.ModelType.ToPythonRuntimeTypeString())')
  }
  else
  {
        @:if @Model.RequestBody.Name is not None:
            @:body_content = self._serialize.body(@Model.RequestBody.Name, '@(Model.RequestBody.ModelType.ToPythonRuntimeTypeString())')
        @:else:
            @:body_content = None
  }
@EmptyLine
}
        # Construct and send request
        def long_running_send():
@EmptyLine
            request = self._client.@(MethodPy.GetHttpFunction(Model.HttpMethod))(url, query_parameters)
@if (Model.RequestBody != null)
{
            @:return self._client.send(
                @:request, header_parameters, body_content, **operation_config)
}
else
{
            @:return self._client.send(request, header_parameters, **operation_config)
}
@EmptyLine
        def get_long_running_status(status_link, headers=None):
@EmptyLine
            request = self._client.get(status_link)
            if headers:
                request.headers.update(headers)
            return self._client.send(
                request, header_parameters, **operation_config)
@EmptyLine
        def get_long_running_output(response):
@EmptyLine
            if @Model.FailureStatusCodePredicate:
                @Model.RaisedException
@EmptyLine
@if (Model.HasAnyResponse)
{
            @:deserialized = None
  if (Model.HasResponseHeader)
  {
            @:header_dict = {}
  }
@EmptyLine
  foreach (var responsePair in Model.Responses.Where(r => r.Value.Body != null))
  {
            @:if response.status_code == @MethodPy.GetStatusCodeReference(responsePair.Key):
    if (responsePair.Value.Body.IsPrimaryType(KnownPrimaryType.Stream))
    {
                @:deserialized = self._client.stream_download(response, callback)
    }
    else
    {
                @:deserialized = self._deserialize('@responsePair.Value.Body.ToPythonRuntimeTypeString()', response)
    }
                @:@Model.AddIndividualResponseHeader(responsePair.Key)
  }
@EmptyLine
            @:if raw:
                @:client_raw_response = ClientRawResponse(deserialized, response)
                @:@Model.AddResponseHeader()
                @:return client_raw_response
@EmptyLine
            @:return deserialized
}
else
{
            @:@Model.ReturnEmptyResponse
}
@EmptyLine
        if raw:
            response = long_running_send()
            return get_long_running_output(response)
@EmptyLine
        long_running_operation_timeout = operation_config.get(
            'long_running_operation_timeout',
            self.config.long_running_operation_timeout)
        return AzureOperationPoller(
            long_running_send, get_long_running_output,
            get_long_running_status, long_running_operation_timeout)
