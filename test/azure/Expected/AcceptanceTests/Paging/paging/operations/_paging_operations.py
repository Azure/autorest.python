# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import functools
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    map_error,
)
from azure.core.paging import CallbackPagingMethod, ItemPaged, NextLinkPagingMethod
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpRequest, HttpResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.polling.base_polling import LROBasePolling
from azure.core.tracing.decorator import distributed_trace

from .. import models as _models

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, Iterable, Optional, TypeVar, Union

    T = TypeVar("T")
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]


class PagingOperations(object):
    """PagingOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~paging.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def _get_no_item_name_pages_initial(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> HttpRequest
        accept = "application/json"

        # Construct URL
        url = self._get_no_item_name_pages_initial.metadata["url"]  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters["Accept"] = self._serialize.header("accept", accept, "str")

        request = self._client.get(url, query_parameters, header_parameters)
        return request

    _get_no_item_name_pages_initial.metadata = {"url": "/paging/noitemname"}  # type: ignore

    @distributed_trace
    def get_no_item_name_pages(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.ProductResultValue"]
        """A paging operation that must return result of the default 'value' node.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword paging_method: The paging strategy to adopt for making requests and processing the
         response. Default is NextLinkPagingMethod. You can pass in
         either an initialized or uninitialized custom paging method. If you pass in an uninitialized
         paging method, make sure your paging method class can input kwargs, as we will initialize your
         paging method with the parameters we would pass into the default paging method + extra kwargs.
        :paramtype paging_method: ~azure.core.paging.PagingMethod
        :return: An iterator like instance of either ProductResultValue or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~paging.models.ProductResultValue]
        :raises: ~azure.core.exceptions.HttpResponseError
        """

        def deserialize_output(pipeline_response):
            return self._deserialize("ProductResultValue", pipeline_response)

        _initial_request = self._get_no_item_name_pages_initial()

        paging_method = kwargs.pop("paging_method", NextLinkPagingMethod)

        try:
            # we accept both initialized and uninitialized paging methods, so we try to initialize
            # the inputted paging method
            paging_method = paging_method(**kwargs)
        except:
            pass

        return ItemPaged(
            paging_method=paging_method,
            deserialize_output=deserialize_output,
            client=self._client,
            continuation_token_location="next_link",
            initial_state=_initial_request,
            _cls=kwargs.pop("cls", None),
            **kwargs,
        )

    def _get_null_next_link_name_pages_initial(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> HttpRequest
        accept = "application/json"

        # Construct URL
        url = self._get_null_next_link_name_pages_initial.metadata["url"]  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters["Accept"] = self._serialize.header("accept", accept, "str")

        request = self._client.get(url, query_parameters, header_parameters)
        return request

    _get_null_next_link_name_pages_initial.metadata = {"url": "/paging/nullnextlink"}  # type: ignore

    @distributed_trace
    def get_null_next_link_name_pages(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.ProductResult"]
        """A paging operation that must ignore any kind of nextLink, and stop after page 1.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword paging_method: The paging strategy to adopt for making requests and processing the
         response. Default is NextLinkPagingMethod. You can pass in
         either an initialized or uninitialized custom paging method. If you pass in an uninitialized
         paging method, make sure your paging method class can input kwargs, as we will initialize your
         paging method with the parameters we would pass into the default paging method + extra kwargs.
        :paramtype paging_method: ~azure.core.paging.PagingMethod
        :return: An iterator like instance of either ProductResult or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~paging.models.ProductResult]
        :raises: ~azure.core.exceptions.HttpResponseError
        """

        def deserialize_output(pipeline_response):
            return self._deserialize("ProductResult", pipeline_response)

        _initial_request = self._get_null_next_link_name_pages_initial()

        paging_method = kwargs.pop("paging_method", NextLinkPagingMethod)

        try:
            # we accept both initialized and uninitialized paging methods, so we try to initialize
            # the inputted paging method
            paging_method = paging_method(**kwargs)
        except:
            pass

        return ItemPaged(
            paging_method=paging_method,
            deserialize_output=deserialize_output,
            client=self._client,
            continuation_token_location=None,
            initial_state=_initial_request,
            item_name="values",
            _cls=kwargs.pop("cls", None),
            **kwargs,
        )

    def _get_single_pages_initial(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> HttpRequest
        accept = "application/json"

        # Construct URL
        url = self._get_single_pages_initial.metadata["url"]  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters["Accept"] = self._serialize.header("accept", accept, "str")

        request = self._client.get(url, query_parameters, header_parameters)
        return request

    _get_single_pages_initial.metadata = {"url": "/paging/single"}  # type: ignore

    @distributed_trace
    def get_single_pages(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.ProductResult"]
        """A paging operation that finishes on the first call without a nextlink.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword paging_method: The paging strategy to adopt for making requests and processing the
         response. Default is NextLinkPagingMethod. You can pass in
         either an initialized or uninitialized custom paging method. If you pass in an uninitialized
         paging method, make sure your paging method class can input kwargs, as we will initialize your
         paging method with the parameters we would pass into the default paging method + extra kwargs.
        :paramtype paging_method: ~azure.core.paging.PagingMethod
        :return: An iterator like instance of either ProductResult or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~paging.models.ProductResult]
        :raises: ~azure.core.exceptions.HttpResponseError
        """

        def deserialize_output(pipeline_response):
            return self._deserialize("ProductResult", pipeline_response)

        _initial_request = self._get_single_pages_initial()

        paging_method = kwargs.pop("paging_method", NextLinkPagingMethod)

        try:
            # we accept both initialized and uninitialized paging methods, so we try to initialize
            # the inputted paging method
            paging_method = paging_method(**kwargs)
        except:
            pass

        return ItemPaged(
            paging_method=paging_method,
            deserialize_output=deserialize_output,
            client=self._client,
            continuation_token_location="next_link",
            initial_state=_initial_request,
            item_name="values",
            _cls=kwargs.pop("cls", None),
            **kwargs,
        )

    def _first_response_empty_initial(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> HttpRequest
        accept = "application/json"

        # Construct URL
        url = self._first_response_empty_initial.metadata["url"]  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters["Accept"] = self._serialize.header("accept", accept, "str")

        request = self._client.get(url, query_parameters, header_parameters)
        return request

    _first_response_empty_initial.metadata = {"url": "/paging/firstResponseEmpty/1"}  # type: ignore

    @distributed_trace
    def first_response_empty(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.ProductResultValue"]
        """A paging operation whose first response's items list is empty, but still returns a next link.
        Second (and final) call, will give you an items list of 1.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword paging_method: The paging strategy to adopt for making requests and processing the
         response. Default is NextLinkPagingMethod. You can pass in
         either an initialized or uninitialized custom paging method. If you pass in an uninitialized
         paging method, make sure your paging method class can input kwargs, as we will initialize your
         paging method with the parameters we would pass into the default paging method + extra kwargs.
        :paramtype paging_method: ~azure.core.paging.PagingMethod
        :return: An iterator like instance of either ProductResultValue or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~paging.models.ProductResultValue]
        :raises: ~azure.core.exceptions.HttpResponseError
        """

        def deserialize_output(pipeline_response):
            return self._deserialize("ProductResultValue", pipeline_response)

        _initial_request = self._first_response_empty_initial()

        paging_method = kwargs.pop("paging_method", NextLinkPagingMethod)

        try:
            # we accept both initialized and uninitialized paging methods, so we try to initialize
            # the inputted paging method
            paging_method = paging_method(**kwargs)
        except:
            pass

        return ItemPaged(
            paging_method=paging_method,
            deserialize_output=deserialize_output,
            client=self._client,
            continuation_token_location="next_link",
            initial_state=_initial_request,
            _cls=kwargs.pop("cls", None),
            **kwargs,
        )

    def _get_multiple_pages_initial(
        self,
        client_request_id=None,  # type: Optional[str]
        paging_get_multiple_pages_options=None,  # type: Optional["_models.PagingGetMultiplePagesOptions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> HttpRequest

        _maxresults = None
        _timeout = None
        if paging_get_multiple_pages_options is not None:
            _maxresults = paging_get_multiple_pages_options.maxresults
            _timeout = paging_get_multiple_pages_options.timeout
        accept = "application/json"

        # Construct URL
        url = self._get_multiple_pages_initial.metadata["url"]  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if client_request_id is not None:
            header_parameters["client-request-id"] = self._serialize.header(
                "client_request_id", client_request_id, "str"
            )
        if _maxresults is not None:
            header_parameters["maxresults"] = self._serialize.header("maxresults", _maxresults, "int")
        if _timeout is not None:
            header_parameters["timeout"] = self._serialize.header("timeout", _timeout, "int")
        header_parameters["Accept"] = self._serialize.header("accept", accept, "str")

        request = self._client.get(url, query_parameters, header_parameters)
        return request

    _get_multiple_pages_initial.metadata = {"url": "/paging/multiple"}  # type: ignore

    @distributed_trace
    def get_multiple_pages(
        self,
        client_request_id=None,  # type: Optional[str]
        paging_get_multiple_pages_options=None,  # type: Optional["_models.PagingGetMultiplePagesOptions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.ProductResult"]
        """A paging operation that includes a nextLink that has 10 pages.

        :param client_request_id:
        :type client_request_id: str
        :param paging_get_multiple_pages_options: Parameter group.
        :type paging_get_multiple_pages_options: ~paging.models.PagingGetMultiplePagesOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword paging_method: The paging strategy to adopt for making requests and processing the
         response. Default is NextLinkPagingMethod. You can pass in
         either an initialized or uninitialized custom paging method. If you pass in an uninitialized
         paging method, make sure your paging method class can input kwargs, as we will initialize your
         paging method with the parameters we would pass into the default paging method + extra kwargs.
        :paramtype paging_method: ~azure.core.paging.PagingMethod
        :return: An iterator like instance of either ProductResult or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~paging.models.ProductResult]
        :raises: ~azure.core.exceptions.HttpResponseError
        """

        def deserialize_output(pipeline_response):
            return self._deserialize("ProductResult", pipeline_response)

        _initial_request = self._get_multiple_pages_initial(
            client_request_id=client_request_id,
            paging_get_multiple_pages_options=paging_get_multiple_pages_options,
        )

        paging_method = kwargs.pop("paging_method", NextLinkPagingMethod)

        try:
            # we accept both initialized and uninitialized paging methods, so we try to initialize
            # the inputted paging method
            paging_method = paging_method(**kwargs)
        except:
            pass

        return ItemPaged(
            paging_method=paging_method,
            deserialize_output=deserialize_output,
            client=self._client,
            continuation_token_location="next_link",
            initial_state=_initial_request,
            item_name="values",
            _cls=kwargs.pop("cls", None),
            **kwargs,
        )

    def _get_with_query_params_initial(
        self,
        required_query_parameter,  # type: int
        **kwargs  # type: Any
    ):
        # type: (...) -> HttpRequest
        query_constant = True
        accept = "application/json"

        # Construct URL
        url = self._get_with_query_params_initial.metadata["url"]  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters["requiredQueryParameter"] = self._serialize.query(
            "required_query_parameter", required_query_parameter, "int"
        )
        query_parameters["queryConstant"] = self._serialize.query("query_constant", query_constant, "bool")

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters["Accept"] = self._serialize.header("accept", accept, "str")

        request = self._client.get(url, query_parameters, header_parameters)
        return request

    _get_with_query_params_initial.metadata = {"url": "/paging/multiple/getWithQueryParams"}  # type: ignore

    def _get_with_query_params_next(
        self,
        next_link,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> HttpRequest
        query_constant = True
        accept = "application/json"

        # Construct URL
        url = self._get_with_query_params_next.metadata["url"]  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters["queryConstant"] = self._serialize.query("query_constant", query_constant, "bool")

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters["Accept"] = self._serialize.header("accept", accept, "str")

        request = self._client.get(url, query_parameters, header_parameters)
        return request

    _get_with_query_params_next.metadata = {"url": "/paging/multiple/nextOperationWithQueryParams"}  # type: ignore

    @distributed_trace
    def get_with_query_params(
        self,
        required_query_parameter,  # type: int
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.ProductResult"]
        """A paging operation that includes a next operation. It has a different query parameter from it's
        next operation nextOperationWithQueryParams. Returns a ProductResult.

        :param required_query_parameter: A required integer query parameter. Put in value '100' to pass
         test.
        :type required_query_parameter: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword paging_method: The paging strategy to adopt for making requests and processing the
         response. Default is CallbackPagingMethod. You can pass in
         either an initialized or uninitialized custom paging method. If you pass in an uninitialized
         paging method, make sure your paging method class can input kwargs, as we will initialize your
         paging method with the parameters we would pass into the default paging method + extra kwargs.
        :paramtype paging_method: ~azure.core.paging.PagingMethod
        :return: An iterator like instance of either ProductResult or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~paging.models.ProductResult]
        :raises: ~azure.core.exceptions.HttpResponseError
        """

        def deserialize_output(pipeline_response):
            return self._deserialize("ProductResult", pipeline_response)

        _initial_request = self._get_with_query_params_initial(
            required_query_parameter=required_query_parameter,
        )
        _next_request_callback = functools.partial(
            self._get_with_query_params_next,
        )

        paging_method = kwargs.pop("paging_method", CallbackPagingMethod)

        try:
            # we accept both initialized and uninitialized paging methods, so we try to initialize
            # the inputted paging method
            paging_method = paging_method(next_request_callback=_next_request_callback, **kwargs)
        except:
            pass

        return ItemPaged(
            paging_method=paging_method,
            deserialize_output=deserialize_output,
            client=self._client,
            continuation_token_location="next_link",
            initial_state=_initial_request,
            item_name="values",
            _cls=kwargs.pop("cls", None),
            **kwargs,
        )

    def _get_odata_multiple_pages_initial(
        self,
        client_request_id=None,  # type: Optional[str]
        paging_get_odata_multiple_pages_options=None,  # type: Optional["_models.PagingGetOdataMultiplePagesOptions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> HttpRequest

        _maxresults = None
        _timeout = None
        if paging_get_odata_multiple_pages_options is not None:
            _maxresults = paging_get_odata_multiple_pages_options.maxresults
            _timeout = paging_get_odata_multiple_pages_options.timeout
        accept = "application/json"

        # Construct URL
        url = self._get_odata_multiple_pages_initial.metadata["url"]  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if client_request_id is not None:
            header_parameters["client-request-id"] = self._serialize.header(
                "client_request_id", client_request_id, "str"
            )
        if _maxresults is not None:
            header_parameters["maxresults"] = self._serialize.header("maxresults", _maxresults, "int")
        if _timeout is not None:
            header_parameters["timeout"] = self._serialize.header("timeout", _timeout, "int")
        header_parameters["Accept"] = self._serialize.header("accept", accept, "str")

        request = self._client.get(url, query_parameters, header_parameters)
        return request

    _get_odata_multiple_pages_initial.metadata = {"url": "/paging/multiple/odata"}  # type: ignore

    @distributed_trace
    def get_odata_multiple_pages(
        self,
        client_request_id=None,  # type: Optional[str]
        paging_get_odata_multiple_pages_options=None,  # type: Optional["_models.PagingGetOdataMultiplePagesOptions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.OdataProductResult"]
        """A paging operation that includes a nextLink in odata format that has 10 pages.

        :param client_request_id:
        :type client_request_id: str
        :param paging_get_odata_multiple_pages_options: Parameter group.
        :type paging_get_odata_multiple_pages_options: ~paging.models.PagingGetOdataMultiplePagesOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword paging_method: The paging strategy to adopt for making requests and processing the
         response. Default is NextLinkPagingMethod. You can pass in
         either an initialized or uninitialized custom paging method. If you pass in an uninitialized
         paging method, make sure your paging method class can input kwargs, as we will initialize your
         paging method with the parameters we would pass into the default paging method + extra kwargs.
        :paramtype paging_method: ~azure.core.paging.PagingMethod
        :return: An iterator like instance of either OdataProductResult or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~paging.models.OdataProductResult]
        :raises: ~azure.core.exceptions.HttpResponseError
        """

        def deserialize_output(pipeline_response):
            return self._deserialize("OdataProductResult", pipeline_response)

        _initial_request = self._get_odata_multiple_pages_initial(
            client_request_id=client_request_id,
            paging_get_odata_multiple_pages_options=paging_get_odata_multiple_pages_options,
        )

        paging_method = kwargs.pop("paging_method", NextLinkPagingMethod)

        try:
            # we accept both initialized and uninitialized paging methods, so we try to initialize
            # the inputted paging method
            paging_method = paging_method(**kwargs)
        except:
            pass

        return ItemPaged(
            paging_method=paging_method,
            deserialize_output=deserialize_output,
            client=self._client,
            continuation_token_location="odata_next_link",
            initial_state=_initial_request,
            item_name="values",
            _cls=kwargs.pop("cls", None),
            **kwargs,
        )

    def _get_multiple_pages_with_offset_initial(
        self,
        paging_get_multiple_pages_with_offset_options,  # type: "_models.PagingGetMultiplePagesWithOffsetOptions"
        client_request_id=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> HttpRequest

        _maxresults = None
        _offset = None
        _timeout = None
        if paging_get_multiple_pages_with_offset_options is not None:
            _maxresults = paging_get_multiple_pages_with_offset_options.maxresults
            _offset = paging_get_multiple_pages_with_offset_options.offset
            _timeout = paging_get_multiple_pages_with_offset_options.timeout
        accept = "application/json"

        # Construct URL
        url = self._get_multiple_pages_with_offset_initial.metadata["url"]  # type: ignore
        path_format_arguments = {
            "offset": self._serialize.url("offset", _offset, "int"),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if client_request_id is not None:
            header_parameters["client-request-id"] = self._serialize.header(
                "client_request_id", client_request_id, "str"
            )
        if _maxresults is not None:
            header_parameters["maxresults"] = self._serialize.header("maxresults", _maxresults, "int")
        if _timeout is not None:
            header_parameters["timeout"] = self._serialize.header("timeout", _timeout, "int")
        header_parameters["Accept"] = self._serialize.header("accept", accept, "str")

        request = self._client.get(url, query_parameters, header_parameters)
        return request

    _get_multiple_pages_with_offset_initial.metadata = {"url": "/paging/multiple/withpath/{offset}"}  # type: ignore

    @distributed_trace
    def get_multiple_pages_with_offset(
        self,
        paging_get_multiple_pages_with_offset_options,  # type: "_models.PagingGetMultiplePagesWithOffsetOptions"
        client_request_id=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.ProductResult"]
        """A paging operation that includes a nextLink that has 10 pages.

        :param paging_get_multiple_pages_with_offset_options: Parameter group.
        :type paging_get_multiple_pages_with_offset_options: ~paging.models.PagingGetMultiplePagesWithOffsetOptions
        :param client_request_id:
        :type client_request_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword paging_method: The paging strategy to adopt for making requests and processing the
         response. Default is NextLinkPagingMethod. You can pass in
         either an initialized or uninitialized custom paging method. If you pass in an uninitialized
         paging method, make sure your paging method class can input kwargs, as we will initialize your
         paging method with the parameters we would pass into the default paging method + extra kwargs.
        :paramtype paging_method: ~azure.core.paging.PagingMethod
        :return: An iterator like instance of either ProductResult or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~paging.models.ProductResult]
        :raises: ~azure.core.exceptions.HttpResponseError
        """

        def deserialize_output(pipeline_response):
            return self._deserialize("ProductResult", pipeline_response)

        _offset = None
        if paging_get_multiple_pages_with_offset_options is not None:
            _offset = paging_get_multiple_pages_with_offset_options.offset

        path_format_arguments = {
            "offset": self._serialize.url("offset", _offset, "int"),
        }

        _initial_request = self._get_multiple_pages_with_offset_initial(
            paging_get_multiple_pages_with_offset_options=paging_get_multiple_pages_with_offset_options,
            client_request_id=client_request_id,
        )

        paging_method = kwargs.pop("paging_method", NextLinkPagingMethod)

        try:
            # we accept both initialized and uninitialized paging methods, so we try to initialize
            # the inputted paging method
            paging_method = paging_method(path_format_arguments=path_format_arguments, **kwargs)
        except:
            pass

        return ItemPaged(
            paging_method=paging_method,
            deserialize_output=deserialize_output,
            client=self._client,
            continuation_token_location="next_link",
            initial_state=_initial_request,
            item_name="values",
            _cls=kwargs.pop("cls", None),
            **kwargs,
        )

    def _get_multiple_pages_retry_first_initial(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> HttpRequest
        accept = "application/json"

        # Construct URL
        url = self._get_multiple_pages_retry_first_initial.metadata["url"]  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters["Accept"] = self._serialize.header("accept", accept, "str")

        request = self._client.get(url, query_parameters, header_parameters)
        return request

    _get_multiple_pages_retry_first_initial.metadata = {"url": "/paging/multiple/retryfirst"}  # type: ignore

    @distributed_trace
    def get_multiple_pages_retry_first(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.ProductResult"]
        """A paging operation that fails on the first call with 500 and then retries and then get a
        response including a nextLink that has 10 pages.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword paging_method: The paging strategy to adopt for making requests and processing the
         response. Default is NextLinkPagingMethod. You can pass in
         either an initialized or uninitialized custom paging method. If you pass in an uninitialized
         paging method, make sure your paging method class can input kwargs, as we will initialize your
         paging method with the parameters we would pass into the default paging method + extra kwargs.
        :paramtype paging_method: ~azure.core.paging.PagingMethod
        :return: An iterator like instance of either ProductResult or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~paging.models.ProductResult]
        :raises: ~azure.core.exceptions.HttpResponseError
        """

        def deserialize_output(pipeline_response):
            return self._deserialize("ProductResult", pipeline_response)

        _initial_request = self._get_multiple_pages_retry_first_initial()

        paging_method = kwargs.pop("paging_method", NextLinkPagingMethod)

        try:
            # we accept both initialized and uninitialized paging methods, so we try to initialize
            # the inputted paging method
            paging_method = paging_method(**kwargs)
        except:
            pass

        return ItemPaged(
            paging_method=paging_method,
            deserialize_output=deserialize_output,
            client=self._client,
            continuation_token_location="next_link",
            initial_state=_initial_request,
            item_name="values",
            _cls=kwargs.pop("cls", None),
            **kwargs,
        )

    def _get_multiple_pages_retry_second_initial(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> HttpRequest
        accept = "application/json"

        # Construct URL
        url = self._get_multiple_pages_retry_second_initial.metadata["url"]  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters["Accept"] = self._serialize.header("accept", accept, "str")

        request = self._client.get(url, query_parameters, header_parameters)
        return request

    _get_multiple_pages_retry_second_initial.metadata = {"url": "/paging/multiple/retrysecond"}  # type: ignore

    @distributed_trace
    def get_multiple_pages_retry_second(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.ProductResult"]
        """A paging operation that includes a nextLink that has 10 pages, of which the 2nd call fails
        first with 500. The client should retry and finish all 10 pages eventually.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword paging_method: The paging strategy to adopt for making requests and processing the
         response. Default is NextLinkPagingMethod. You can pass in
         either an initialized or uninitialized custom paging method. If you pass in an uninitialized
         paging method, make sure your paging method class can input kwargs, as we will initialize your
         paging method with the parameters we would pass into the default paging method + extra kwargs.
        :paramtype paging_method: ~azure.core.paging.PagingMethod
        :return: An iterator like instance of either ProductResult or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~paging.models.ProductResult]
        :raises: ~azure.core.exceptions.HttpResponseError
        """

        def deserialize_output(pipeline_response):
            return self._deserialize("ProductResult", pipeline_response)

        _initial_request = self._get_multiple_pages_retry_second_initial()

        paging_method = kwargs.pop("paging_method", NextLinkPagingMethod)

        try:
            # we accept both initialized and uninitialized paging methods, so we try to initialize
            # the inputted paging method
            paging_method = paging_method(**kwargs)
        except:
            pass

        return ItemPaged(
            paging_method=paging_method,
            deserialize_output=deserialize_output,
            client=self._client,
            continuation_token_location="next_link",
            initial_state=_initial_request,
            item_name="values",
            _cls=kwargs.pop("cls", None),
            **kwargs,
        )

    def _get_single_pages_failure_initial(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> HttpRequest
        accept = "application/json"

        # Construct URL
        url = self._get_single_pages_failure_initial.metadata["url"]  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters["Accept"] = self._serialize.header("accept", accept, "str")

        request = self._client.get(url, query_parameters, header_parameters)
        return request

    _get_single_pages_failure_initial.metadata = {"url": "/paging/single/failure"}  # type: ignore

    @distributed_trace
    def get_single_pages_failure(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.ProductResult"]
        """A paging operation that receives a 400 on the first call.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword paging_method: The paging strategy to adopt for making requests and processing the
         response. Default is NextLinkPagingMethod. You can pass in
         either an initialized or uninitialized custom paging method. If you pass in an uninitialized
         paging method, make sure your paging method class can input kwargs, as we will initialize your
         paging method with the parameters we would pass into the default paging method + extra kwargs.
        :paramtype paging_method: ~azure.core.paging.PagingMethod
        :return: An iterator like instance of either ProductResult or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~paging.models.ProductResult]
        :raises: ~azure.core.exceptions.HttpResponseError
        """

        def deserialize_output(pipeline_response):
            return self._deserialize("ProductResult", pipeline_response)

        _initial_request = self._get_single_pages_failure_initial()

        paging_method = kwargs.pop("paging_method", NextLinkPagingMethod)

        try:
            # we accept both initialized and uninitialized paging methods, so we try to initialize
            # the inputted paging method
            paging_method = paging_method(**kwargs)
        except:
            pass

        return ItemPaged(
            paging_method=paging_method,
            deserialize_output=deserialize_output,
            client=self._client,
            continuation_token_location="next_link",
            initial_state=_initial_request,
            item_name="values",
            _cls=kwargs.pop("cls", None),
            **kwargs,
        )

    def _get_multiple_pages_failure_initial(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> HttpRequest
        accept = "application/json"

        # Construct URL
        url = self._get_multiple_pages_failure_initial.metadata["url"]  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters["Accept"] = self._serialize.header("accept", accept, "str")

        request = self._client.get(url, query_parameters, header_parameters)
        return request

    _get_multiple_pages_failure_initial.metadata = {"url": "/paging/multiple/failure"}  # type: ignore

    @distributed_trace
    def get_multiple_pages_failure(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.ProductResult"]
        """A paging operation that receives a 400 on the second call.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword paging_method: The paging strategy to adopt for making requests and processing the
         response. Default is NextLinkPagingMethod. You can pass in
         either an initialized or uninitialized custom paging method. If you pass in an uninitialized
         paging method, make sure your paging method class can input kwargs, as we will initialize your
         paging method with the parameters we would pass into the default paging method + extra kwargs.
        :paramtype paging_method: ~azure.core.paging.PagingMethod
        :return: An iterator like instance of either ProductResult or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~paging.models.ProductResult]
        :raises: ~azure.core.exceptions.HttpResponseError
        """

        def deserialize_output(pipeline_response):
            return self._deserialize("ProductResult", pipeline_response)

        _initial_request = self._get_multiple_pages_failure_initial()

        paging_method = kwargs.pop("paging_method", NextLinkPagingMethod)

        try:
            # we accept both initialized and uninitialized paging methods, so we try to initialize
            # the inputted paging method
            paging_method = paging_method(**kwargs)
        except:
            pass

        return ItemPaged(
            paging_method=paging_method,
            deserialize_output=deserialize_output,
            client=self._client,
            continuation_token_location="next_link",
            initial_state=_initial_request,
            item_name="values",
            _cls=kwargs.pop("cls", None),
            **kwargs,
        )

    def _get_multiple_pages_failure_uri_initial(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> HttpRequest
        accept = "application/json"

        # Construct URL
        url = self._get_multiple_pages_failure_uri_initial.metadata["url"]  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters["Accept"] = self._serialize.header("accept", accept, "str")

        request = self._client.get(url, query_parameters, header_parameters)
        return request

    _get_multiple_pages_failure_uri_initial.metadata = {"url": "/paging/multiple/failureuri"}  # type: ignore

    @distributed_trace
    def get_multiple_pages_failure_uri(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.ProductResult"]
        """A paging operation that receives an invalid nextLink.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword paging_method: The paging strategy to adopt for making requests and processing the
         response. Default is NextLinkPagingMethod. You can pass in
         either an initialized or uninitialized custom paging method. If you pass in an uninitialized
         paging method, make sure your paging method class can input kwargs, as we will initialize your
         paging method with the parameters we would pass into the default paging method + extra kwargs.
        :paramtype paging_method: ~azure.core.paging.PagingMethod
        :return: An iterator like instance of either ProductResult or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~paging.models.ProductResult]
        :raises: ~azure.core.exceptions.HttpResponseError
        """

        def deserialize_output(pipeline_response):
            return self._deserialize("ProductResult", pipeline_response)

        _initial_request = self._get_multiple_pages_failure_uri_initial()

        paging_method = kwargs.pop("paging_method", NextLinkPagingMethod)

        try:
            # we accept both initialized and uninitialized paging methods, so we try to initialize
            # the inputted paging method
            paging_method = paging_method(**kwargs)
        except:
            pass

        return ItemPaged(
            paging_method=paging_method,
            deserialize_output=deserialize_output,
            client=self._client,
            continuation_token_location="next_link",
            initial_state=_initial_request,
            item_name="values",
            _cls=kwargs.pop("cls", None),
            **kwargs,
        )

    def _get_multiple_pages_fragment_next_link_initial(
        self,
        api_version,  # type: str
        tenant,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> HttpRequest
        accept = "application/json"

        # Construct URL
        url = self._get_multiple_pages_fragment_next_link_initial.metadata["url"]  # type: ignore
        path_format_arguments = {
            "tenant": self._serialize.url("tenant", tenant, "str"),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters["api_version"] = self._serialize.query("api_version", api_version, "str")

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters["Accept"] = self._serialize.header("accept", accept, "str")

        request = self._client.get(url, query_parameters, header_parameters)
        return request

    _get_multiple_pages_fragment_next_link_initial.metadata = {"url": "/paging/multiple/fragment/{tenant}"}  # type: ignore

    def _get_multiple_pages_fragment_next_link_next(
        self,
        next_link,  # type: str
        api_version,  # type: str
        tenant,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> HttpRequest
        accept = "application/json"

        # Construct URL
        url = self._get_multiple_pages_fragment_next_link_next.metadata["url"]  # type: ignore
        path_format_arguments = {
            "nextLink": self._serialize.url("next_link", next_link, "str", skip_quote=True),
            "tenant": self._serialize.url("tenant", tenant, "str"),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters["api_version"] = self._serialize.query("api_version", api_version, "str")

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters["Accept"] = self._serialize.header("accept", accept, "str")

        request = self._client.get(url, query_parameters, header_parameters)
        return request

    _get_multiple_pages_fragment_next_link_next.metadata = {"url": "/paging/multiple/fragment/{tenant}/{nextLink}"}  # type: ignore

    @distributed_trace
    def get_multiple_pages_fragment_next_link(
        self,
        api_version,  # type: str
        tenant,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.OdataProductResult"]
        """A paging operation that doesn't return a full URL, just a fragment.

        :param api_version: Sets the api version to use.
        :type api_version: str
        :param tenant: Sets the tenant to use.
        :type tenant: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword paging_method: The paging strategy to adopt for making requests and processing the
         response. Default is CallbackPagingMethod. You can pass in
         either an initialized or uninitialized custom paging method. If you pass in an uninitialized
         paging method, make sure your paging method class can input kwargs, as we will initialize your
         paging method with the parameters we would pass into the default paging method + extra kwargs.
        :paramtype paging_method: ~azure.core.paging.PagingMethod
        :return: An iterator like instance of either OdataProductResult or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~paging.models.OdataProductResult]
        :raises: ~azure.core.exceptions.HttpResponseError
        """

        def deserialize_output(pipeline_response):
            return self._deserialize("OdataProductResult", pipeline_response)

        _initial_request = self._get_multiple_pages_fragment_next_link_initial(
            api_version=api_version,
            tenant=tenant,
        )
        _next_request_callback = functools.partial(
            self._get_multiple_pages_fragment_next_link_next,
            api_version=api_version,
            tenant=tenant,
        )

        paging_method = kwargs.pop("paging_method", CallbackPagingMethod)

        try:
            # we accept both initialized and uninitialized paging methods, so we try to initialize
            # the inputted paging method
            paging_method = paging_method(next_request_callback=_next_request_callback, **kwargs)
        except:
            pass

        return ItemPaged(
            paging_method=paging_method,
            deserialize_output=deserialize_output,
            client=self._client,
            continuation_token_location="odata_next_link",
            initial_state=_initial_request,
            item_name="values",
            _cls=kwargs.pop("cls", None),
            **kwargs,
        )

    def _get_multiple_pages_fragment_with_grouping_next_link_initial(
        self,
        custom_parameter_group,  # type: "_models.CustomParameterGroup"
        **kwargs  # type: Any
    ):
        # type: (...) -> HttpRequest

        _api_version = None
        _tenant = None
        if custom_parameter_group is not None:
            _api_version = custom_parameter_group.api_version
            _tenant = custom_parameter_group.tenant
        accept = "application/json"

        # Construct URL
        url = self._get_multiple_pages_fragment_with_grouping_next_link_initial.metadata["url"]  # type: ignore
        path_format_arguments = {
            "tenant": self._serialize.url("tenant", _tenant, "str"),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters["api_version"] = self._serialize.query("api_version", _api_version, "str")

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters["Accept"] = self._serialize.header("accept", accept, "str")

        request = self._client.get(url, query_parameters, header_parameters)
        return request

    _get_multiple_pages_fragment_with_grouping_next_link_initial.metadata = {"url": "/paging/multiple/fragmentwithgrouping/{tenant}"}  # type: ignore

    def _get_multiple_pages_fragment_with_grouping_next_link_next(
        self,
        next_link,  # type: str
        custom_parameter_group,  # type: "_models.CustomParameterGroup"
        **kwargs  # type: Any
    ):
        # type: (...) -> HttpRequest

        _api_version = None
        _tenant = None
        if custom_parameter_group is not None:
            _api_version = custom_parameter_group.api_version
            _tenant = custom_parameter_group.tenant
        accept = "application/json"

        # Construct URL
        url = self._get_multiple_pages_fragment_with_grouping_next_link_next.metadata["url"]  # type: ignore
        path_format_arguments = {
            "nextLink": self._serialize.url("next_link", next_link, "str", skip_quote=True),
            "tenant": self._serialize.url("tenant", _tenant, "str"),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters["api_version"] = self._serialize.query("api_version", _api_version, "str")

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters["Accept"] = self._serialize.header("accept", accept, "str")

        request = self._client.get(url, query_parameters, header_parameters)
        return request

    _get_multiple_pages_fragment_with_grouping_next_link_next.metadata = {"url": "/paging/multiple/fragmentwithgrouping/{tenant}/{nextLink}"}  # type: ignore

    @distributed_trace
    def get_multiple_pages_fragment_with_grouping_next_link(
        self,
        custom_parameter_group,  # type: "_models.CustomParameterGroup"
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.OdataProductResult"]
        """A paging operation that doesn't return a full URL, just a fragment with parameters grouped.

        :param custom_parameter_group: Parameter group.
        :type custom_parameter_group: ~paging.models.CustomParameterGroup
        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword paging_method: The paging strategy to adopt for making requests and processing the
         response. Default is CallbackPagingMethod. You can pass in
         either an initialized or uninitialized custom paging method. If you pass in an uninitialized
         paging method, make sure your paging method class can input kwargs, as we will initialize your
         paging method with the parameters we would pass into the default paging method + extra kwargs.
        :paramtype paging_method: ~azure.core.paging.PagingMethod
        :return: An iterator like instance of either OdataProductResult or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~paging.models.OdataProductResult]
        :raises: ~azure.core.exceptions.HttpResponseError
        """

        def deserialize_output(pipeline_response):
            return self._deserialize("OdataProductResult", pipeline_response)

        _initial_request = self._get_multiple_pages_fragment_with_grouping_next_link_initial(
            custom_parameter_group=custom_parameter_group,
        )
        _next_request_callback = functools.partial(
            self._get_multiple_pages_fragment_with_grouping_next_link_next,
            custom_parameter_group=custom_parameter_group,
        )

        paging_method = kwargs.pop("paging_method", CallbackPagingMethod)

        try:
            # we accept both initialized and uninitialized paging methods, so we try to initialize
            # the inputted paging method
            paging_method = paging_method(next_request_callback=_next_request_callback, **kwargs)
        except:
            pass

        return ItemPaged(
            paging_method=paging_method,
            deserialize_output=deserialize_output,
            client=self._client,
            continuation_token_location="odata_next_link",
            initial_state=_initial_request,
            item_name="values",
            _cls=kwargs.pop("cls", None),
            **kwargs,
        )

    def _get_multiple_pages_lro_initial(
        self,
        client_request_id=None,  # type: Optional[str]
        paging_get_multiple_pages_lro_options=None,  # type: Optional["_models.PagingGetMultiplePagesLroOptions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.ProductResult"
        cls = kwargs.pop("cls", None)  # type: ClsType["_models.ProductResult"]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        _maxresults = None
        _timeout = None
        if paging_get_multiple_pages_lro_options is not None:
            _maxresults = paging_get_multiple_pages_lro_options.maxresults
            _timeout = paging_get_multiple_pages_lro_options.timeout
        accept = "application/json"

        # Construct URL
        url = self._get_multiple_pages_lro_initial.metadata["url"]  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if client_request_id is not None:
            header_parameters["client-request-id"] = self._serialize.header(
                "client_request_id", client_request_id, "str"
            )
        if _maxresults is not None:
            header_parameters["maxresults"] = self._serialize.header("maxresults", _maxresults, "int")
        if _timeout is not None:
            header_parameters["timeout"] = self._serialize.header("timeout", _timeout, "int")
        header_parameters["Accept"] = self._serialize.header("accept", accept, "str")

        request = self._client.post(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("ProductResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    _get_multiple_pages_lro_initial.metadata = {"url": "/paging/multiple/lro"}  # type: ignore

    @distributed_trace
    def begin_get_multiple_pages_lro(
        self,
        client_request_id=None,  # type: Optional[str]
        paging_get_multiple_pages_lro_options=None,  # type: Optional["_models.PagingGetMultiplePagesLroOptions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> LROPoller[ItemPaged["_models.ProductResult"]]
        """A long-running paging operation that includes a nextLink that has 10 pages.

        :param client_request_id:
        :type client_request_id: str
        :param paging_get_multiple_pages_lro_options: Parameter group.
        :type paging_get_multiple_pages_lro_options: ~paging.models.PagingGetMultiplePagesLroOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: Pass in True if you'd like the LROBasePolling polling method,
         False for no polling, or your own initialized polling object for a personal polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no Retry-After header is present.
        :keyword paging_method: The paging strategy to adopt for making requests and processing the
         response. Default is NextLinkPagingMethod. You can pass in
         either an initialized or uninitialized custom paging method. If you pass in an uninitialized
         paging method, make sure your paging method class can input kwargs, as we will initialize your
         paging method with the parameters we would pass into the default paging method + extra kwargs.
        :paramtype paging_method: ~azure.core.paging.PagingMethod
        :return: An instance of LROPoller that returns an iterator like instance of either ProductResult or the result of cls(response)
        :rtype: ~azure.core.polling.LROPoller[~azure.core.paging.ItemPaged[~paging.models.ProductResult]]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

        polling = kwargs.pop("polling", False)  # type: Union[bool, PollingMethod]
        cls = kwargs.pop("cls", None)  # type: ClsType["_models.ProductResult"]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._get_multiple_pages_lro_initial(
                client_request_id=client_request_id,
                paging_get_multiple_pages_lro_options=paging_get_multiple_pages_lro_options,
                cls=lambda x, y, z: x,
                **kwargs,
            )

        kwargs.pop("error_map", None)
        kwargs.pop("content_type", None)

        def deserialize_output(pipeline_response):
            return self._deserialize("ProductResult", pipeline_response)

        def get_long_running_output(pipeline_response):
            # TODO: check that cls and error_map kwargs persist here

            paging_method = kwargs.pop("paging_method", NextLinkPagingMethod)

            try:
                # we accept both initialized and uninitialized paging methods, so we try to initialize
                # the inputted paging method
                paging_method = paging_method(**kwargs)
            except:
                pass

            return ItemPaged(
                paging_method=paging_method,
                deserialize_output=deserialize_output,
                client=self._client,
                continuation_token_location="next_link",
                initial_state=pipeline_response,
                item_name="values",
                _cls=kwargs.pop("cls", None),
                **kwargs,
            )

        if polling is True:
            polling_method = LROBasePolling(lro_delay, **kwargs)
        elif polling is False:
            polling_method = NoPolling()
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        else:
            return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    begin_get_multiple_pages_lro.metadata = {"url": "/paging/multiple/lro"}  # type: ignore

    def _get_paging_model_with_item_name_with_xms_client_name_initial(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> HttpRequest
        accept = "application/json"

        # Construct URL
        url = self._get_paging_model_with_item_name_with_xms_client_name_initial.metadata["url"]  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters["Accept"] = self._serialize.header("accept", accept, "str")

        request = self._client.get(url, query_parameters, header_parameters)
        return request

    _get_paging_model_with_item_name_with_xms_client_name_initial.metadata = {"url": "/paging/itemNameWithXMSClientName"}  # type: ignore

    @distributed_trace
    def get_paging_model_with_item_name_with_xms_client_name(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.ProductResultValueWithXMSClientName"]
        """A paging operation that returns a paging model whose item name is is overriden by x-ms-client-
        name 'indexes'.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword paging_method: The paging strategy to adopt for making requests and processing the
         response. Default is NextLinkPagingMethod. You can pass in
         either an initialized or uninitialized custom paging method. If you pass in an uninitialized
         paging method, make sure your paging method class can input kwargs, as we will initialize your
         paging method with the parameters we would pass into the default paging method + extra kwargs.
        :paramtype paging_method: ~azure.core.paging.PagingMethod
        :return: An iterator like instance of either ProductResultValueWithXMSClientName or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~paging.models.ProductResultValueWithXMSClientName]
        :raises: ~azure.core.exceptions.HttpResponseError
        """

        def deserialize_output(pipeline_response):
            return self._deserialize("ProductResultValueWithXMSClientName", pipeline_response)

        _initial_request = self._get_paging_model_with_item_name_with_xms_client_name_initial()

        paging_method = kwargs.pop("paging_method", NextLinkPagingMethod)

        try:
            # we accept both initialized and uninitialized paging methods, so we try to initialize
            # the inputted paging method
            paging_method = paging_method(**kwargs)
        except:
            pass

        return ItemPaged(
            paging_method=paging_method,
            deserialize_output=deserialize_output,
            client=self._client,
            continuation_token_location="next_link",
            initial_state=_initial_request,
            item_name="indexes",
            _cls=kwargs.pop("cls", None),
            **kwargs,
        )
