# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import functools
from typing import Any, Callable, Dict, Generic, List, Optional, TypeVar, Union
import warnings

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async

from ...operations._operations import (
    build_http_client_failure_delete400_request,
    build_http_client_failure_delete407_request,
    build_http_client_failure_delete417_request,
    build_http_client_failure_get400_request,
    build_http_client_failure_get402_request,
    build_http_client_failure_get403_request,
    build_http_client_failure_get411_request,
    build_http_client_failure_get412_request,
    build_http_client_failure_get416_request,
    build_http_client_failure_head400_request,
    build_http_client_failure_head401_request,
    build_http_client_failure_head410_request,
    build_http_client_failure_head429_request,
    build_http_client_failure_options400_request,
    build_http_client_failure_options403_request,
    build_http_client_failure_options412_request,
    build_http_client_failure_patch400_request,
    build_http_client_failure_patch405_request,
    build_http_client_failure_patch414_request,
    build_http_client_failure_post400_request,
    build_http_client_failure_post406_request,
    build_http_client_failure_post415_request,
    build_http_client_failure_put400_request,
    build_http_client_failure_put404_request,
    build_http_client_failure_put409_request,
    build_http_client_failure_put413_request,
    build_http_failure_get_empty_error_request,
    build_http_failure_get_no_model_empty_request,
    build_http_failure_get_no_model_error_request,
    build_http_redirects_delete307_request,
    build_http_redirects_get300_request,
    build_http_redirects_get301_request,
    build_http_redirects_get302_request,
    build_http_redirects_get307_request,
    build_http_redirects_head300_request,
    build_http_redirects_head301_request,
    build_http_redirects_head302_request,
    build_http_redirects_head307_request,
    build_http_redirects_options307_request,
    build_http_redirects_patch302_request,
    build_http_redirects_patch307_request,
    build_http_redirects_post303_request,
    build_http_redirects_post307_request,
    build_http_redirects_put301_request,
    build_http_redirects_put307_request,
    build_http_retry_delete503_request,
    build_http_retry_get502_request,
    build_http_retry_head408_request,
    build_http_retry_options502_request,
    build_http_retry_patch500_request,
    build_http_retry_patch504_request,
    build_http_retry_post503_request,
    build_http_retry_put500_request,
    build_http_retry_put504_request,
    build_http_server_failure_delete505_request,
    build_http_server_failure_get501_request,
    build_http_server_failure_head501_request,
    build_http_server_failure_post505_request,
    build_http_success_delete200_request,
    build_http_success_delete202_request,
    build_http_success_delete204_request,
    build_http_success_get200_request,
    build_http_success_head200_request,
    build_http_success_head204_request,
    build_http_success_head404_request,
    build_http_success_options200_request,
    build_http_success_patch200_request,
    build_http_success_patch202_request,
    build_http_success_patch204_request,
    build_http_success_post200_request,
    build_http_success_post201_request,
    build_http_success_post202_request,
    build_http_success_post204_request,
    build_http_success_put200_request,
    build_http_success_put201_request,
    build_http_success_put202_request,
    build_http_success_put204_request,
    build_multiple_responses_get200_model201_model_default_error200_valid_request,
    build_multiple_responses_get200_model201_model_default_error201_valid_request,
    build_multiple_responses_get200_model201_model_default_error400_valid_request,
    build_multiple_responses_get200_model204_no_model_default_error200_valid_request,
    build_multiple_responses_get200_model204_no_model_default_error201_invalid_request,
    build_multiple_responses_get200_model204_no_model_default_error202_none_request,
    build_multiple_responses_get200_model204_no_model_default_error204_valid_request,
    build_multiple_responses_get200_model204_no_model_default_error400_valid_request,
    build_multiple_responses_get200_model_a200_invalid_request,
    build_multiple_responses_get200_model_a200_none_request,
    build_multiple_responses_get200_model_a200_valid_request,
    build_multiple_responses_get200_model_a201_model_c404_model_d_default_error200_valid_request,
    build_multiple_responses_get200_model_a201_model_c404_model_d_default_error201_valid_request,
    build_multiple_responses_get200_model_a201_model_c404_model_d_default_error400_valid_request,
    build_multiple_responses_get200_model_a201_model_c404_model_d_default_error404_valid_request,
    build_multiple_responses_get200_model_a202_valid_request,
    build_multiple_responses_get200_model_a400_invalid_request,
    build_multiple_responses_get200_model_a400_none_request,
    build_multiple_responses_get200_model_a400_valid_request,
    build_multiple_responses_get202_none204_none_default_error202_none_request,
    build_multiple_responses_get202_none204_none_default_error204_none_request,
    build_multiple_responses_get202_none204_none_default_error400_valid_request,
    build_multiple_responses_get202_none204_none_default_none202_invalid_request,
    build_multiple_responses_get202_none204_none_default_none204_none_request,
    build_multiple_responses_get202_none204_none_default_none400_invalid_request,
    build_multiple_responses_get202_none204_none_default_none400_none_request,
    build_multiple_responses_get_default_model_a200_none_request,
    build_multiple_responses_get_default_model_a200_valid_request,
    build_multiple_responses_get_default_model_a400_none_request,
    build_multiple_responses_get_default_model_a400_valid_request,
    build_multiple_responses_get_default_none200_invalid_request,
    build_multiple_responses_get_default_none200_none_request,
    build_multiple_responses_get_default_none400_invalid_request,
    build_multiple_responses_get_default_none400_none_request,
)

T = TypeVar("T")
JSONType = Any
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class HttpFailureOperations:
    """HttpFailureOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    @distributed_trace_async
    async def get_empty_error(self, **kwargs: Any) -> bool:
        """Get empty error form server.

        :return: bool
        :rtype: bool
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[bool]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_failure_get_empty_error_request(
            template_url=self.get_empty_error.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_empty_error.metadata = {"url": "/http/failure/emptybody/error"}  # type: ignore

    @distributed_trace_async
    async def get_no_model_error(self, **kwargs: Any) -> bool:
        """Get empty error form server.

        :return: bool
        :rtype: bool
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[bool]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_failure_get_no_model_error_request(
            template_url=self.get_no_model_error.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_no_model_error.metadata = {"url": "/http/failure/nomodel/error"}  # type: ignore

    @distributed_trace_async
    async def get_no_model_empty(self, **kwargs: Any) -> bool:
        """Get empty response from server.

        :return: bool
        :rtype: bool
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[bool]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_failure_get_no_model_empty_request(
            template_url=self.get_no_model_empty.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_no_model_empty.metadata = {"url": "/http/failure/nomodel/empty"}  # type: ignore


class HttpSuccessOperations:
    """HttpSuccessOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    @distributed_trace_async
    async def head200(self, **kwargs: Any) -> None:
        """Return 200 status code if successful.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_success_head200_request(
            template_url=self.head200.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    head200.metadata = {"url": "/http/success/200"}  # type: ignore

    @distributed_trace_async
    async def get200(self, **kwargs: Any) -> bool:
        """Get 200 success.

        :return: bool
        :rtype: bool
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[bool]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_success_get200_request(
            template_url=self.get200.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get200.metadata = {"url": "/http/success/200"}  # type: ignore

    @distributed_trace_async
    async def options200(self, **kwargs: Any) -> bool:
        """Options 200 success.

        :return: bool
        :rtype: bool
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[bool]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_success_options200_request(
            template_url=self.options200.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    options200.metadata = {"url": "/http/success/200"}  # type: ignore

    @distributed_trace_async
    async def put200(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Put boolean value true returning 200 success.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_success_put200_request(
            content_type=content_type,
            json=_json,
            template_url=self.put200.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put200.metadata = {"url": "/http/success/200"}  # type: ignore

    @distributed_trace_async
    async def patch200(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Patch true Boolean value in request returning 200.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_success_patch200_request(
            content_type=content_type,
            json=_json,
            template_url=self.patch200.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    patch200.metadata = {"url": "/http/success/200"}  # type: ignore

    @distributed_trace_async
    async def post200(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Post bollean value true in request that returns a 200.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_success_post200_request(
            content_type=content_type,
            json=_json,
            template_url=self.post200.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    post200.metadata = {"url": "/http/success/200"}  # type: ignore

    @distributed_trace_async
    async def delete200(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Delete simple boolean value true returns 200.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_success_delete200_request(
            content_type=content_type,
            json=_json,
            template_url=self.delete200.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete200.metadata = {"url": "/http/success/200"}  # type: ignore

    @distributed_trace_async
    async def put201(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Put true Boolean value in request returns 201.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_success_put201_request(
            content_type=content_type,
            json=_json,
            template_url=self.put201.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put201.metadata = {"url": "/http/success/201"}  # type: ignore

    @distributed_trace_async
    async def post201(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Post true Boolean value in request returns 201 (Created).

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_success_post201_request(
            content_type=content_type,
            json=_json,
            template_url=self.post201.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    post201.metadata = {"url": "/http/success/201"}  # type: ignore

    @distributed_trace_async
    async def put202(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Put true Boolean value in request returns 202 (Accepted).

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_success_put202_request(
            content_type=content_type,
            json=_json,
            template_url=self.put202.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put202.metadata = {"url": "/http/success/202"}  # type: ignore

    @distributed_trace_async
    async def patch202(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Patch true Boolean value in request returns 202.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_success_patch202_request(
            content_type=content_type,
            json=_json,
            template_url=self.patch202.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    patch202.metadata = {"url": "/http/success/202"}  # type: ignore

    @distributed_trace_async
    async def post202(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Post true Boolean value in request returns 202 (Accepted).

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_success_post202_request(
            content_type=content_type,
            json=_json,
            template_url=self.post202.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    post202.metadata = {"url": "/http/success/202"}  # type: ignore

    @distributed_trace_async
    async def delete202(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Delete true Boolean value in request returns 202 (accepted).

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_success_delete202_request(
            content_type=content_type,
            json=_json,
            template_url=self.delete202.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete202.metadata = {"url": "/http/success/202"}  # type: ignore

    @distributed_trace_async
    async def head204(self, **kwargs: Any) -> None:
        """Return 204 status code if successful.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_success_head204_request(
            template_url=self.head204.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    head204.metadata = {"url": "/http/success/204"}  # type: ignore

    @distributed_trace_async
    async def put204(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Put true Boolean value in request returns 204 (no content).

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_success_put204_request(
            content_type=content_type,
            json=_json,
            template_url=self.put204.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put204.metadata = {"url": "/http/success/204"}  # type: ignore

    @distributed_trace_async
    async def patch204(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Patch true Boolean value in request returns 204 (no content).

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_success_patch204_request(
            content_type=content_type,
            json=_json,
            template_url=self.patch204.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    patch204.metadata = {"url": "/http/success/204"}  # type: ignore

    @distributed_trace_async
    async def post204(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Post true Boolean value in request returns 204 (no content).

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_success_post204_request(
            content_type=content_type,
            json=_json,
            template_url=self.post204.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    post204.metadata = {"url": "/http/success/204"}  # type: ignore

    @distributed_trace_async
    async def delete204(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Delete true Boolean value in request returns 204 (no content).

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_success_delete204_request(
            content_type=content_type,
            json=_json,
            template_url=self.delete204.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete204.metadata = {"url": "/http/success/204"}  # type: ignore

    @distributed_trace_async
    async def head404(self, **kwargs: Any) -> None:
        """Return 404 status code.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_success_head404_request(
            template_url=self.head404.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    head404.metadata = {"url": "/http/success/404"}  # type: ignore


class HttpRedirectsOperations:
    """HttpRedirectsOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    @distributed_trace_async
    async def head300(self, **kwargs: Any) -> None:
        """Return 300 status code and redirect to /http/success/200.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_redirects_head300_request(
            template_url=self.head300.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 300]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 300:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    head300.metadata = {"url": "/http/redirect/300"}  # type: ignore

    @distributed_trace_async
    async def get300(self, **kwargs: Any) -> Optional[List[str]]:
        """Return 300 status code and redirect to /http/success/200.

        :return: list of str
        :rtype: list[str] or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 300
                response.json() == [
                    "str"  # Optional.
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[List[str]]]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_redirects_get300_request(
            template_url=self.get300.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 300]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 300:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    get300.metadata = {"url": "/http/redirect/300"}  # type: ignore

    @distributed_trace_async
    async def head301(self, **kwargs: Any) -> None:
        """Return 301 status code and redirect to /http/success/200.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_redirects_head301_request(
            template_url=self.head301.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 301]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 301:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    head301.metadata = {"url": "/http/redirect/301"}  # type: ignore

    @distributed_trace_async
    async def get301(self, **kwargs: Any) -> None:
        """Return 301 status code and redirect to /http/success/200.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_redirects_get301_request(
            template_url=self.get301.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 301]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 301:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    get301.metadata = {"url": "/http/redirect/301"}  # type: ignore

    @distributed_trace_async
    async def put301(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Put true Boolean value in request returns 301.  This request should not be automatically
        redirected, but should return the received 301 to the caller for evaluation.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_redirects_put301_request(
            content_type=content_type,
            json=_json,
            template_url=self.put301.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [301]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    put301.metadata = {"url": "/http/redirect/301"}  # type: ignore

    @distributed_trace_async
    async def head302(self, **kwargs: Any) -> None:
        """Return 302 status code and redirect to /http/success/200.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_redirects_head302_request(
            template_url=self.head302.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 302]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 302:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    head302.metadata = {"url": "/http/redirect/302"}  # type: ignore

    @distributed_trace_async
    async def get302(self, **kwargs: Any) -> None:
        """Return 302 status code and redirect to /http/success/200.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_redirects_get302_request(
            template_url=self.get302.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 302]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 302:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    get302.metadata = {"url": "/http/redirect/302"}  # type: ignore

    @distributed_trace_async
    async def patch302(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Patch true Boolean value in request returns 302.  This request should not be automatically
        redirected, but should return the received 302 to the caller for evaluation.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_redirects_patch302_request(
            content_type=content_type,
            json=_json,
            template_url=self.patch302.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [302]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    patch302.metadata = {"url": "/http/redirect/302"}  # type: ignore

    @distributed_trace_async
    async def post303(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Post true Boolean value in request returns 303.  This request should be automatically
        redirected usign a get, ultimately returning a 200 status code.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_redirects_post303_request(
            content_type=content_type,
            json=_json,
            template_url=self.post303.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 303]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 303:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    post303.metadata = {"url": "/http/redirect/303"}  # type: ignore

    @distributed_trace_async
    async def head307(self, **kwargs: Any) -> None:
        """Redirect with 307, resulting in a 200 success.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_redirects_head307_request(
            template_url=self.head307.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 307]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 307:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    head307.metadata = {"url": "/http/redirect/307"}  # type: ignore

    @distributed_trace_async
    async def get307(self, **kwargs: Any) -> None:
        """Redirect get with 307, resulting in a 200 success.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_redirects_get307_request(
            template_url=self.get307.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 307]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 307:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    get307.metadata = {"url": "/http/redirect/307"}  # type: ignore

    @distributed_trace_async
    async def options307(self, **kwargs: Any) -> None:
        """options redirected with 307, resulting in a 200 after redirect.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_redirects_options307_request(
            template_url=self.options307.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 307]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 307:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    options307.metadata = {"url": "/http/redirect/307"}  # type: ignore

    @distributed_trace_async
    async def put307(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Put redirected with 307, resulting in a 200 after redirect.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_redirects_put307_request(
            content_type=content_type,
            json=_json,
            template_url=self.put307.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 307]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 307:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    put307.metadata = {"url": "/http/redirect/307"}  # type: ignore

    @distributed_trace_async
    async def patch307(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Patch redirected with 307, resulting in a 200 after redirect.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_redirects_patch307_request(
            content_type=content_type,
            json=_json,
            template_url=self.patch307.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 307]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 307:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    patch307.metadata = {"url": "/http/redirect/307"}  # type: ignore

    @distributed_trace_async
    async def post307(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Post redirected with 307, resulting in a 200 after redirect.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_redirects_post307_request(
            content_type=content_type,
            json=_json,
            template_url=self.post307.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 307]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 307:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    post307.metadata = {"url": "/http/redirect/307"}  # type: ignore

    @distributed_trace_async
    async def delete307(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Delete redirected with 307, resulting in a 200 after redirect.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_redirects_delete307_request(
            content_type=content_type,
            json=_json,
            template_url=self.delete307.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 307]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 307:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    delete307.metadata = {"url": "/http/redirect/307"}  # type: ignore


class HttpClientFailureOperations:
    """HttpClientFailureOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    @distributed_trace_async
    async def head400(self, **kwargs: Any) -> None:
        """Return 400 status code - should be represented in the client as an error.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_client_failure_head400_request(
            template_url=self.head400.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    head400.metadata = {"url": "/http/failure/client/400"}  # type: ignore

    @distributed_trace_async
    async def get400(self, **kwargs: Any) -> None:
        """Return 400 status code - should be represented in the client as an error.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_client_failure_get400_request(
            template_url=self.get400.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get400.metadata = {"url": "/http/failure/client/400"}  # type: ignore

    @distributed_trace_async
    async def options400(self, **kwargs: Any) -> None:
        """Return 400 status code - should be represented in the client as an error.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_client_failure_options400_request(
            template_url=self.options400.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    options400.metadata = {"url": "/http/failure/client/400"}  # type: ignore

    @distributed_trace_async
    async def put400(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 400 status code - should be represented in the client as an error.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_client_failure_put400_request(
            content_type=content_type,
            json=_json,
            template_url=self.put400.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put400.metadata = {"url": "/http/failure/client/400"}  # type: ignore

    @distributed_trace_async
    async def patch400(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 400 status code - should be represented in the client as an error.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_client_failure_patch400_request(
            content_type=content_type,
            json=_json,
            template_url=self.patch400.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    patch400.metadata = {"url": "/http/failure/client/400"}  # type: ignore

    @distributed_trace_async
    async def post400(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 400 status code - should be represented in the client as an error.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_client_failure_post400_request(
            content_type=content_type,
            json=_json,
            template_url=self.post400.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    post400.metadata = {"url": "/http/failure/client/400"}  # type: ignore

    @distributed_trace_async
    async def delete400(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 400 status code - should be represented in the client as an error.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_client_failure_delete400_request(
            content_type=content_type,
            json=_json,
            template_url=self.delete400.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete400.metadata = {"url": "/http/failure/client/400"}  # type: ignore

    @distributed_trace_async
    async def head401(self, **kwargs: Any) -> None:
        """Return 401 status code - should be represented in the client as an error.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_client_failure_head401_request(
            template_url=self.head401.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    head401.metadata = {"url": "/http/failure/client/401"}  # type: ignore

    @distributed_trace_async
    async def get402(self, **kwargs: Any) -> None:
        """Return 402 status code - should be represented in the client as an error.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_client_failure_get402_request(
            template_url=self.get402.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get402.metadata = {"url": "/http/failure/client/402"}  # type: ignore

    @distributed_trace_async
    async def options403(self, **kwargs: Any) -> None:
        """Return 403 status code - should be represented in the client as an error.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_client_failure_options403_request(
            template_url=self.options403.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    options403.metadata = {"url": "/http/failure/client/403"}  # type: ignore

    @distributed_trace_async
    async def get403(self, **kwargs: Any) -> None:
        """Return 403 status code - should be represented in the client as an error.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_client_failure_get403_request(
            template_url=self.get403.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get403.metadata = {"url": "/http/failure/client/403"}  # type: ignore

    @distributed_trace_async
    async def put404(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 404 status code - should be represented in the client as an error.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_client_failure_put404_request(
            content_type=content_type,
            json=_json,
            template_url=self.put404.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put404.metadata = {"url": "/http/failure/client/404"}  # type: ignore

    @distributed_trace_async
    async def patch405(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 405 status code - should be represented in the client as an error.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_client_failure_patch405_request(
            content_type=content_type,
            json=_json,
            template_url=self.patch405.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    patch405.metadata = {"url": "/http/failure/client/405"}  # type: ignore

    @distributed_trace_async
    async def post406(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 406 status code - should be represented in the client as an error.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_client_failure_post406_request(
            content_type=content_type,
            json=_json,
            template_url=self.post406.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    post406.metadata = {"url": "/http/failure/client/406"}  # type: ignore

    @distributed_trace_async
    async def delete407(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 407 status code - should be represented in the client as an error.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_client_failure_delete407_request(
            content_type=content_type,
            json=_json,
            template_url=self.delete407.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete407.metadata = {"url": "/http/failure/client/407"}  # type: ignore

    @distributed_trace_async
    async def put409(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 409 status code - should be represented in the client as an error.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_client_failure_put409_request(
            content_type=content_type,
            json=_json,
            template_url=self.put409.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put409.metadata = {"url": "/http/failure/client/409"}  # type: ignore

    @distributed_trace_async
    async def head410(self, **kwargs: Any) -> None:
        """Return 410 status code - should be represented in the client as an error.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_client_failure_head410_request(
            template_url=self.head410.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    head410.metadata = {"url": "/http/failure/client/410"}  # type: ignore

    @distributed_trace_async
    async def get411(self, **kwargs: Any) -> None:
        """Return 411 status code - should be represented in the client as an error.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_client_failure_get411_request(
            template_url=self.get411.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get411.metadata = {"url": "/http/failure/client/411"}  # type: ignore

    @distributed_trace_async
    async def options412(self, **kwargs: Any) -> None:
        """Return 412 status code - should be represented in the client as an error.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_client_failure_options412_request(
            template_url=self.options412.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    options412.metadata = {"url": "/http/failure/client/412"}  # type: ignore

    @distributed_trace_async
    async def get412(self, **kwargs: Any) -> None:
        """Return 412 status code - should be represented in the client as an error.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_client_failure_get412_request(
            template_url=self.get412.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get412.metadata = {"url": "/http/failure/client/412"}  # type: ignore

    @distributed_trace_async
    async def put413(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 413 status code - should be represented in the client as an error.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_client_failure_put413_request(
            content_type=content_type,
            json=_json,
            template_url=self.put413.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put413.metadata = {"url": "/http/failure/client/413"}  # type: ignore

    @distributed_trace_async
    async def patch414(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 414 status code - should be represented in the client as an error.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_client_failure_patch414_request(
            content_type=content_type,
            json=_json,
            template_url=self.patch414.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    patch414.metadata = {"url": "/http/failure/client/414"}  # type: ignore

    @distributed_trace_async
    async def post415(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 415 status code - should be represented in the client as an error.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_client_failure_post415_request(
            content_type=content_type,
            json=_json,
            template_url=self.post415.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    post415.metadata = {"url": "/http/failure/client/415"}  # type: ignore

    @distributed_trace_async
    async def get416(self, **kwargs: Any) -> None:
        """Return 416 status code - should be represented in the client as an error.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_client_failure_get416_request(
            template_url=self.get416.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get416.metadata = {"url": "/http/failure/client/416"}  # type: ignore

    @distributed_trace_async
    async def delete417(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 417 status code - should be represented in the client as an error.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_client_failure_delete417_request(
            content_type=content_type,
            json=_json,
            template_url=self.delete417.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete417.metadata = {"url": "/http/failure/client/417"}  # type: ignore

    @distributed_trace_async
    async def head429(self, **kwargs: Any) -> None:
        """Return 429 status code - should be represented in the client as an error.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_client_failure_head429_request(
            template_url=self.head429.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    head429.metadata = {"url": "/http/failure/client/429"}  # type: ignore


class HttpServerFailureOperations:
    """HttpServerFailureOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    @distributed_trace_async
    async def head501(self, **kwargs: Any) -> None:
        """Return 501 status code - should be represented in the client as an error.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_server_failure_head501_request(
            template_url=self.head501.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    head501.metadata = {"url": "/http/failure/server/501"}  # type: ignore

    @distributed_trace_async
    async def get501(self, **kwargs: Any) -> None:
        """Return 501 status code - should be represented in the client as an error.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_server_failure_get501_request(
            template_url=self.get501.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get501.metadata = {"url": "/http/failure/server/501"}  # type: ignore

    @distributed_trace_async
    async def post505(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 505 status code - should be represented in the client as an error.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_server_failure_post505_request(
            content_type=content_type,
            json=_json,
            template_url=self.post505.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    post505.metadata = {"url": "/http/failure/server/505"}  # type: ignore

    @distributed_trace_async
    async def delete505(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 505 status code - should be represented in the client as an error.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_server_failure_delete505_request(
            content_type=content_type,
            json=_json,
            template_url=self.delete505.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete505.metadata = {"url": "/http/failure/server/505"}  # type: ignore


class HttpRetryOperations:
    """HttpRetryOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    @distributed_trace_async
    async def head408(self, **kwargs: Any) -> None:
        """Return 408 status code, then 200 after retry.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_retry_head408_request(
            template_url=self.head408.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    head408.metadata = {"url": "/http/retry/408"}  # type: ignore

    @distributed_trace_async
    async def put500(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 500 status code, then 200 after retry.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_retry_put500_request(
            content_type=content_type,
            json=_json,
            template_url=self.put500.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put500.metadata = {"url": "/http/retry/500"}  # type: ignore

    @distributed_trace_async
    async def patch500(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 500 status code, then 200 after retry.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_retry_patch500_request(
            content_type=content_type,
            json=_json,
            template_url=self.patch500.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    patch500.metadata = {"url": "/http/retry/500"}  # type: ignore

    @distributed_trace_async
    async def get502(self, **kwargs: Any) -> None:
        """Return 502 status code, then 200 after retry.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_retry_get502_request(
            template_url=self.get502.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get502.metadata = {"url": "/http/retry/502"}  # type: ignore

    @distributed_trace_async
    async def options502(self, **kwargs: Any) -> bool:
        """Return 502 status code, then 200 after retry.

        :return: bool
        :rtype: bool
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[bool]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_http_retry_options502_request(
            template_url=self.options502.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    options502.metadata = {"url": "/http/retry/502"}  # type: ignore

    @distributed_trace_async
    async def post503(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 503 status code, then 200 after retry.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_retry_post503_request(
            content_type=content_type,
            json=_json,
            template_url=self.post503.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    post503.metadata = {"url": "/http/retry/503"}  # type: ignore

    @distributed_trace_async
    async def delete503(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 503 status code, then 200 after retry.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_retry_delete503_request(
            content_type=content_type,
            json=_json,
            template_url=self.delete503.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete503.metadata = {"url": "/http/retry/503"}  # type: ignore

    @distributed_trace_async
    async def put504(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 504 status code, then 200 after retry.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_retry_put504_request(
            content_type=content_type,
            json=_json,
            template_url=self.put504.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put504.metadata = {"url": "/http/retry/504"}  # type: ignore

    @distributed_trace_async
    async def patch504(self, boolean_value: Optional[bool] = True, **kwargs: Any) -> None:
        """Return 504 status code, then 200 after retry.

        :param boolean_value: Simple boolean value true. The default value is True.
        :type boolean_value: bool
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        if boolean_value is not None:
            _json = boolean_value
        else:
            _json = None

        request = build_http_retry_patch504_request(
            content_type=content_type,
            json=_json,
            template_url=self.patch504.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    patch504.metadata = {"url": "/http/retry/504"}  # type: ignore


class MultipleResponsesOperations:
    """MultipleResponsesOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    @distributed_trace_async
    async def get200_model204_no_model_default_error200_valid(self, **kwargs: Any) -> Optional[JSONType]:
        """Send a 200 response with valid payload: {'statusCode': '200'}.

        :return: JSON object
        :rtype: JSONType or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSONType]]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get200_model204_no_model_default_error200_valid_request(
            template_url=self.get200_model204_no_model_default_error200_valid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get200_model204_no_model_default_error200_valid.metadata = {"url": "/http/payloads/200/A/204/none/default/Error/response/200/valid"}  # type: ignore

    @distributed_trace_async
    async def get200_model204_no_model_default_error204_valid(self, **kwargs: Any) -> Optional[JSONType]:
        """Send a 204 response with no payload.

        :return: JSON object
        :rtype: JSONType or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSONType]]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get200_model204_no_model_default_error204_valid_request(
            template_url=self.get200_model204_no_model_default_error204_valid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get200_model204_no_model_default_error204_valid.metadata = {"url": "/http/payloads/200/A/204/none/default/Error/response/204/none"}  # type: ignore

    @distributed_trace_async
    async def get200_model204_no_model_default_error201_invalid(self, **kwargs: Any) -> Optional[JSONType]:
        """Send a 201 response with valid payload: {'statusCode': '201'}.

        :return: JSON object
        :rtype: JSONType or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSONType]]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get200_model204_no_model_default_error201_invalid_request(
            template_url=self.get200_model204_no_model_default_error201_invalid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get200_model204_no_model_default_error201_invalid.metadata = {"url": "/http/payloads/200/A/204/none/default/Error/response/201/valid"}  # type: ignore

    @distributed_trace_async
    async def get200_model204_no_model_default_error202_none(self, **kwargs: Any) -> Optional[JSONType]:
        """Send a 202 response with no payload:.

        :return: JSON object
        :rtype: JSONType or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSONType]]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get200_model204_no_model_default_error202_none_request(
            template_url=self.get200_model204_no_model_default_error202_none.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get200_model204_no_model_default_error202_none.metadata = {"url": "/http/payloads/200/A/204/none/default/Error/response/202/none"}  # type: ignore

    @distributed_trace_async
    async def get200_model204_no_model_default_error400_valid(self, **kwargs: Any) -> Optional[JSONType]:
        """Send a 400 response with valid error payload: {'status': 400, 'message': 'client error'}.

        :return: JSON object
        :rtype: JSONType or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSONType]]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get200_model204_no_model_default_error400_valid_request(
            template_url=self.get200_model204_no_model_default_error400_valid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get200_model204_no_model_default_error400_valid.metadata = {"url": "/http/payloads/200/A/204/none/default/Error/response/400/valid"}  # type: ignore

    @distributed_trace_async
    async def get200_model201_model_default_error200_valid(self, **kwargs: Any) -> JSONType:
        """Send a 200 response with valid payload: {'statusCode': '200'}.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
                # response body for status code(s): 201
                response.json() == {
                    "statusCode": "str",  # Optional.
                    "textStatusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get200_model201_model_default_error200_valid_request(
            template_url=self.get200_model201_model_default_error200_valid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get200_model201_model_default_error200_valid.metadata = {"url": "/http/payloads/200/A/201/B/default/Error/response/200/valid"}  # type: ignore

    @distributed_trace_async
    async def get200_model201_model_default_error201_valid(self, **kwargs: Any) -> JSONType:
        """Send a 201 response with valid payload: {'statusCode': '201', 'textStatusCode': 'Created'}.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
                # response body for status code(s): 201
                response.json() == {
                    "statusCode": "str",  # Optional.
                    "textStatusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get200_model201_model_default_error201_valid_request(
            template_url=self.get200_model201_model_default_error201_valid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get200_model201_model_default_error201_valid.metadata = {"url": "/http/payloads/200/A/201/B/default/Error/response/201/valid"}  # type: ignore

    @distributed_trace_async
    async def get200_model201_model_default_error400_valid(self, **kwargs: Any) -> JSONType:
        """Send a 400 response with valid payload: {'code': '400', 'message': 'client error'}.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
                # response body for status code(s): 201
                response.json() == {
                    "statusCode": "str",  # Optional.
                    "textStatusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get200_model201_model_default_error400_valid_request(
            template_url=self.get200_model201_model_default_error400_valid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get200_model201_model_default_error400_valid.metadata = {"url": "/http/payloads/200/A/201/B/default/Error/response/400/valid"}  # type: ignore

    @distributed_trace_async
    async def get200_model_a201_model_c404_model_d_default_error200_valid(self, **kwargs: Any) -> JSONType:
        """Send a 200 response with valid payload: {'statusCode': '200'}.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
                # response body for status code(s): 201
                response.json() == {
                    "httpCode": "str"  # Optional.
                }
                # response body for status code(s): 404
                response.json() == {
                    "httpStatusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get200_model_a201_model_c404_model_d_default_error200_valid_request(
            template_url=self.get200_model_a201_model_c404_model_d_default_error200_valid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get200_model_a201_model_c404_model_d_default_error200_valid.metadata = {"url": "/http/payloads/200/A/201/C/404/D/default/Error/response/200/valid"}  # type: ignore

    @distributed_trace_async
    async def get200_model_a201_model_c404_model_d_default_error201_valid(self, **kwargs: Any) -> JSONType:
        """Send a 200 response with valid payload: {'httpCode': '201'}.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
                # response body for status code(s): 201
                response.json() == {
                    "httpCode": "str"  # Optional.
                }
                # response body for status code(s): 404
                response.json() == {
                    "httpStatusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get200_model_a201_model_c404_model_d_default_error201_valid_request(
            template_url=self.get200_model_a201_model_c404_model_d_default_error201_valid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get200_model_a201_model_c404_model_d_default_error201_valid.metadata = {"url": "/http/payloads/200/A/201/C/404/D/default/Error/response/201/valid"}  # type: ignore

    @distributed_trace_async
    async def get200_model_a201_model_c404_model_d_default_error404_valid(self, **kwargs: Any) -> JSONType:
        """Send a 200 response with valid payload: {'httpStatusCode': '404'}.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
                # response body for status code(s): 201
                response.json() == {
                    "httpCode": "str"  # Optional.
                }
                # response body for status code(s): 404
                response.json() == {
                    "httpStatusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get200_model_a201_model_c404_model_d_default_error404_valid_request(
            template_url=self.get200_model_a201_model_c404_model_d_default_error404_valid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get200_model_a201_model_c404_model_d_default_error404_valid.metadata = {"url": "/http/payloads/200/A/201/C/404/D/default/Error/response/404/valid"}  # type: ignore

    @distributed_trace_async
    async def get200_model_a201_model_c404_model_d_default_error400_valid(self, **kwargs: Any) -> JSONType:
        """Send a 400 response with valid payload: {'code': '400', 'message': 'client error'}.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
                # response body for status code(s): 201
                response.json() == {
                    "httpCode": "str"  # Optional.
                }
                # response body for status code(s): 404
                response.json() == {
                    "httpStatusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get200_model_a201_model_c404_model_d_default_error400_valid_request(
            template_url=self.get200_model_a201_model_c404_model_d_default_error400_valid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get200_model_a201_model_c404_model_d_default_error400_valid.metadata = {"url": "/http/payloads/200/A/201/C/404/D/default/Error/response/400/valid"}  # type: ignore

    @distributed_trace_async
    async def get202_none204_none_default_error202_none(self, **kwargs: Any) -> None:
        """Send a 202 response with no payload.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get202_none204_none_default_error202_none_request(
            template_url=self.get202_none204_none_default_error202_none.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get202_none204_none_default_error202_none.metadata = {"url": "/http/payloads/202/none/204/none/default/Error/response/202/none"}  # type: ignore

    @distributed_trace_async
    async def get202_none204_none_default_error204_none(self, **kwargs: Any) -> None:
        """Send a 204 response with no payload.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get202_none204_none_default_error204_none_request(
            template_url=self.get202_none204_none_default_error204_none.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get202_none204_none_default_error204_none.metadata = {"url": "/http/payloads/202/none/204/none/default/Error/response/204/none"}  # type: ignore

    @distributed_trace_async
    async def get202_none204_none_default_error400_valid(self, **kwargs: Any) -> None:
        """Send a 400 response with valid payload: {'code': '400', 'message': 'client error'}.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get202_none204_none_default_error400_valid_request(
            template_url=self.get202_none204_none_default_error400_valid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get202_none204_none_default_error400_valid.metadata = {"url": "/http/payloads/202/none/204/none/default/Error/response/400/valid"}  # type: ignore

    @distributed_trace_async
    async def get202_none204_none_default_none202_invalid(self, **kwargs: Any) -> None:
        """Send a 202 response with an unexpected payload {'property': 'value'}.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get202_none204_none_default_none202_invalid_request(
            template_url=self.get202_none204_none_default_none202_invalid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get202_none204_none_default_none202_invalid.metadata = {"url": "/http/payloads/202/none/204/none/default/none/response/202/invalid"}  # type: ignore

    @distributed_trace_async
    async def get202_none204_none_default_none204_none(self, **kwargs: Any) -> None:
        """Send a 204 response with no payload.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get202_none204_none_default_none204_none_request(
            template_url=self.get202_none204_none_default_none204_none.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get202_none204_none_default_none204_none.metadata = {"url": "/http/payloads/202/none/204/none/default/none/response/204/none"}  # type: ignore

    @distributed_trace_async
    async def get202_none204_none_default_none400_none(self, **kwargs: Any) -> None:
        """Send a 400 response with no payload.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get202_none204_none_default_none400_none_request(
            template_url=self.get202_none204_none_default_none400_none.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get202_none204_none_default_none400_none.metadata = {"url": "/http/payloads/202/none/204/none/default/none/response/400/none"}  # type: ignore

    @distributed_trace_async
    async def get202_none204_none_default_none400_invalid(self, **kwargs: Any) -> None:
        """Send a 400 response with an unexpected payload {'property': 'value'}.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get202_none204_none_default_none400_invalid_request(
            template_url=self.get202_none204_none_default_none400_invalid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get202_none204_none_default_none400_invalid.metadata = {"url": "/http/payloads/202/none/204/none/default/none/response/400/invalid"}  # type: ignore

    @distributed_trace_async
    async def get_default_model_a200_valid(self, **kwargs: Any) -> JSONType:
        """Send a 200 response with valid payload: {'statusCode': '200'}.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get_default_model_a200_valid_request(
            template_url=self.get_default_model_a200_valid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_default_model_a200_valid.metadata = {"url": "/http/payloads/default/A/response/200/valid"}  # type: ignore

    @distributed_trace_async
    async def get_default_model_a200_none(self, **kwargs: Any) -> JSONType:
        """Send a 200 response with no payload.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get_default_model_a200_none_request(
            template_url=self.get_default_model_a200_none.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_default_model_a200_none.metadata = {"url": "/http/payloads/default/A/response/200/none"}  # type: ignore

    @distributed_trace_async
    async def get_default_model_a400_valid(self, **kwargs: Any) -> None:
        """Send a 400 response with valid payload: {'statusCode': '400'}.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get_default_model_a400_valid_request(
            template_url=self.get_default_model_a400_valid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get_default_model_a400_valid.metadata = {"url": "/http/payloads/default/A/response/400/valid"}  # type: ignore

    @distributed_trace_async
    async def get_default_model_a400_none(self, **kwargs: Any) -> None:
        """Send a 400 response with no payload.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get_default_model_a400_none_request(
            template_url=self.get_default_model_a400_none.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get_default_model_a400_none.metadata = {"url": "/http/payloads/default/A/response/400/none"}  # type: ignore

    @distributed_trace_async
    async def get_default_none200_invalid(self, **kwargs: Any) -> None:
        """Send a 200 response with invalid payload: {'statusCode': '200'}.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get_default_none200_invalid_request(
            template_url=self.get_default_none200_invalid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get_default_none200_invalid.metadata = {"url": "/http/payloads/default/none/response/200/invalid"}  # type: ignore

    @distributed_trace_async
    async def get_default_none200_none(self, **kwargs: Any) -> None:
        """Send a 200 response with no payload.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get_default_none200_none_request(
            template_url=self.get_default_none200_none.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get_default_none200_none.metadata = {"url": "/http/payloads/default/none/response/200/none"}  # type: ignore

    @distributed_trace_async
    async def get_default_none400_invalid(self, **kwargs: Any) -> None:
        """Send a 400 response with valid payload: {'statusCode': '400'}.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get_default_none400_invalid_request(
            template_url=self.get_default_none400_invalid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get_default_none400_invalid.metadata = {"url": "/http/payloads/default/none/response/400/invalid"}  # type: ignore

    @distributed_trace_async
    async def get_default_none400_none(self, **kwargs: Any) -> None:
        """Send a 400 response with no payload.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get_default_none400_none_request(
            template_url=self.get_default_none400_none.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    get_default_none400_none.metadata = {"url": "/http/payloads/default/none/response/400/none"}  # type: ignore

    @distributed_trace_async
    async def get200_model_a200_none(self, **kwargs: Any) -> JSONType:
        """Send a 200 response with no payload, when a payload is expected - client should return a null
        object of thde type for model A.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get200_model_a200_none_request(
            template_url=self.get200_model_a200_none.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get200_model_a200_none.metadata = {"url": "/http/payloads/200/A/response/200/none"}  # type: ignore

    @distributed_trace_async
    async def get200_model_a200_valid(self, **kwargs: Any) -> JSONType:
        """Send a 200 response with payload {'statusCode': '200'}.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get200_model_a200_valid_request(
            template_url=self.get200_model_a200_valid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get200_model_a200_valid.metadata = {"url": "/http/payloads/200/A/response/200/valid"}  # type: ignore

    @distributed_trace_async
    async def get200_model_a200_invalid(self, **kwargs: Any) -> JSONType:
        """Send a 200 response with invalid payload {'statusCodeInvalid': '200'}.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get200_model_a200_invalid_request(
            template_url=self.get200_model_a200_invalid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get200_model_a200_invalid.metadata = {"url": "/http/payloads/200/A/response/200/invalid"}  # type: ignore

    @distributed_trace_async
    async def get200_model_a400_none(self, **kwargs: Any) -> JSONType:
        """Send a 400 response with no payload client should treat as an http error with no error model.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get200_model_a400_none_request(
            template_url=self.get200_model_a400_none.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get200_model_a400_none.metadata = {"url": "/http/payloads/200/A/response/400/none"}  # type: ignore

    @distributed_trace_async
    async def get200_model_a400_valid(self, **kwargs: Any) -> JSONType:
        """Send a 200 response with payload {'statusCode': '400'}.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get200_model_a400_valid_request(
            template_url=self.get200_model_a400_valid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get200_model_a400_valid.metadata = {"url": "/http/payloads/200/A/response/400/valid"}  # type: ignore

    @distributed_trace_async
    async def get200_model_a400_invalid(self, **kwargs: Any) -> JSONType:
        """Send a 200 response with invalid payload {'statusCodeInvalid': '400'}.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get200_model_a400_invalid_request(
            template_url=self.get200_model_a400_invalid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get200_model_a400_invalid.metadata = {"url": "/http/payloads/200/A/response/400/invalid"}  # type: ignore

    @distributed_trace_async
    async def get200_model_a202_valid(self, **kwargs: Any) -> JSONType:
        """Send a 202 response with payload {'statusCode': '202'}.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "statusCode": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_multiple_responses_get200_model_a202_valid_request(
            template_url=self.get200_model_a202_valid.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get200_model_a202_valid.metadata = {"url": "/http/payloads/200/A/response/202/valid"}  # type: ignore
