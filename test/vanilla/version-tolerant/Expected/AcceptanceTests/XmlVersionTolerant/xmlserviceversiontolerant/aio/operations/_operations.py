# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import sys
from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
from xml.etree import ElementTree as ET

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ...operations._operations import (
    build_xml_get_acls_request,
    build_xml_get_bytes_request,
    build_xml_get_complex_type_ref_no_meta_request,
    build_xml_get_complex_type_ref_with_meta_request,
    build_xml_get_empty_child_element_request,
    build_xml_get_empty_list_request,
    build_xml_get_empty_root_list_request,
    build_xml_get_empty_wrapped_lists_request,
    build_xml_get_headers_request,
    build_xml_get_root_list_request,
    build_xml_get_root_list_single_item_request,
    build_xml_get_service_properties_request,
    build_xml_get_simple_request,
    build_xml_get_uri_request,
    build_xml_get_wrapped_lists_request,
    build_xml_get_xms_text_request,
    build_xml_json_input_request,
    build_xml_json_output_request,
    build_xml_list_blobs_request,
    build_xml_list_containers_request,
    build_xml_put_acls_request,
    build_xml_put_binary_request,
    build_xml_put_complex_type_ref_no_meta_request,
    build_xml_put_complex_type_ref_with_meta_request,
    build_xml_put_empty_child_element_request,
    build_xml_put_empty_list_request,
    build_xml_put_empty_root_list_request,
    build_xml_put_empty_wrapped_lists_request,
    build_xml_put_root_list_request,
    build_xml_put_root_list_single_item_request,
    build_xml_put_service_properties_request,
    build_xml_put_simple_request,
    build_xml_put_uri_request,
    build_xml_put_wrapped_lists_request,
)

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class XmlOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~xmlserviceversiontolerant.aio.AutoRestSwaggerBATXMLService`'s
        :attr:`xml` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_complex_type_ref_no_meta(self, **kwargs: Any) -> ET.Element:
        """Get a complex type that has a ref to a complex type with no XML node.

        :return: XML Element
        :rtype: ET.Element
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "RefToModel": {
                        "ID": "str"  # Optional. The id of the res.
                    },
                    "Something": "str"  # Optional. Something else (just to avoid flattening).
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[ET.Element]

        request = build_xml_get_complex_type_ref_no_meta_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(ET.Element, deserialized), {})

        return cast(ET.Element, deserialized)

    @distributed_trace_async
    async def put_complex_type_ref_no_meta(  # pylint: disable=inconsistent-return-statements
        self, model: ET.Element, **kwargs: Any
    ) -> None:
        """Puts a complex type that has a ref to a complex type with no XML node.

        :param model: Required.
        :type model: ET.Element
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                model = {
                    "RefToModel": {
                        "ID": "str"  # Optional. The id of the res.
                    },
                    "Something": "str"  # Optional. Something else (just to avoid flattening).
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        _content = model

        request = build_xml_put_complex_type_ref_no_meta_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_complex_type_ref_with_meta(self, **kwargs: Any) -> ET.Element:
        """Get a complex type that has a ref to a complex type with XML node.

        :return: XML Element
        :rtype: ET.Element
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "RefToModel": {
                        "ID": "str"  # Optional. The id of the res.
                    },
                    "Something": "str"  # Optional. Something else (just to avoid flattening).
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[ET.Element]

        request = build_xml_get_complex_type_ref_with_meta_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(ET.Element, deserialized), {})

        return cast(ET.Element, deserialized)

    @distributed_trace_async
    async def put_complex_type_ref_with_meta(  # pylint: disable=inconsistent-return-statements
        self, model: ET.Element, **kwargs: Any
    ) -> None:
        """Puts a complex type that has a ref to a complex type with XML node.

        :param model: Required.
        :type model: ET.Element
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                model = {
                    "RefToModel": {
                        "ID": "str"  # Optional. The id of the res.
                    },
                    "Something": "str"  # Optional. Something else (just to avoid flattening).
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        _content = model

        request = build_xml_put_complex_type_ref_with_meta_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_simple(self, **kwargs: Any) -> ET.Element:
        """Get a simple XML document.

        :return: XML Element
        :rtype: ET.Element
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "author": "str",  # Optional.
                    "date": "str",  # Optional.
                    "slides": [
                        {
                            "items": [
                                "str"  # Optional.
                            ],
                            "title": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "title": "str"  # Optional.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[ET.Element]

        request = build_xml_get_simple_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(ET.Element, deserialized), {})

        return cast(ET.Element, deserialized)

    @distributed_trace_async
    async def put_simple(  # pylint: disable=inconsistent-return-statements
        self, slideshow: ET.Element, **kwargs: Any
    ) -> None:
        """Put a simple XML document.

        :param slideshow: Required.
        :type slideshow: ET.Element
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                slideshow = {
                    "author": "str",  # Optional.
                    "date": "str",  # Optional.
                    "slides": [
                        {
                            "items": [
                                "str"  # Optional.
                            ],
                            "title": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "title": "str"  # Optional.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        _content = slideshow

        request = build_xml_put_simple_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_wrapped_lists(self, **kwargs: Any) -> ET.Element:
        """Get an XML document with multiple wrapped lists.

        :return: XML Element
        :rtype: ET.Element
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "BadApples": [
                        "str"  # Optional.
                    ],
                    "GoodApples": [
                        "str"  # Optional.
                    ]
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[ET.Element]

        request = build_xml_get_wrapped_lists_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(ET.Element, deserialized), {})

        return cast(ET.Element, deserialized)

    @distributed_trace_async
    async def put_wrapped_lists(  # pylint: disable=inconsistent-return-statements
        self, wrapped_lists: ET.Element, **kwargs: Any
    ) -> None:
        """Put an XML document with multiple wrapped lists.

        :param wrapped_lists: Required.
        :type wrapped_lists: ET.Element
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                wrapped_lists = {
                    "BadApples": [
                        "str"  # Optional.
                    ],
                    "GoodApples": [
                        "str"  # Optional.
                    ]
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        _content = wrapped_lists

        request = build_xml_put_wrapped_lists_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_headers(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Get strongly-typed response headers.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_xml_get_headers_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Custom-Header"] = self._deserialize("str", response.headers.get("Custom-Header"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace_async
    async def get_empty_list(self, **kwargs: Any) -> ET.Element:
        """Get an empty list.

        :return: XML Element
        :rtype: ET.Element
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "author": "str",  # Optional.
                    "date": "str",  # Optional.
                    "slides": [
                        {
                            "items": [
                                "str"  # Optional.
                            ],
                            "title": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "title": "str"  # Optional.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[ET.Element]

        request = build_xml_get_empty_list_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(ET.Element, deserialized), {})

        return cast(ET.Element, deserialized)

    @distributed_trace_async
    async def put_empty_list(  # pylint: disable=inconsistent-return-statements
        self, slideshow: ET.Element, **kwargs: Any
    ) -> None:
        """Puts an empty list.

        :param slideshow: Required.
        :type slideshow: ET.Element
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                slideshow = {
                    "author": "str",  # Optional.
                    "date": "str",  # Optional.
                    "slides": [
                        {
                            "items": [
                                "str"  # Optional.
                            ],
                            "title": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "title": "str"  # Optional.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        _content = slideshow

        request = build_xml_put_empty_list_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_empty_wrapped_lists(self, **kwargs: Any) -> ET.Element:
        """Gets some empty wrapped lists.

        :return: XML Element
        :rtype: ET.Element
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "BadApples": [
                        "str"  # Optional.
                    ],
                    "GoodApples": [
                        "str"  # Optional.
                    ]
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[ET.Element]

        request = build_xml_get_empty_wrapped_lists_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(ET.Element, deserialized), {})

        return cast(ET.Element, deserialized)

    @distributed_trace_async
    async def put_empty_wrapped_lists(  # pylint: disable=inconsistent-return-statements
        self, apple_barrel: ET.Element, **kwargs: Any
    ) -> None:
        """Puts some empty wrapped lists.

        :param apple_barrel: Required.
        :type apple_barrel: ET.Element
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                apple_barrel = {
                    "BadApples": [
                        "str"  # Optional.
                    ],
                    "GoodApples": [
                        "str"  # Optional.
                    ]
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        _content = apple_barrel

        request = build_xml_put_empty_wrapped_lists_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_root_list(self, **kwargs: Any) -> ET.Element:
        """Gets a list as the root element.

        :return: XML Element
        :rtype: ET.Element
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "expiration": "2020-02-20 00:00:00",  # Optional. The time at which
                          you should reconsider eating this banana.
                        "flavor": "str",  # Optional.
                        "name": "str"  # Optional.
                    }
                ]
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[ET.Element]

        request = build_xml_get_root_list_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(ET.Element, deserialized), {})

        return cast(ET.Element, deserialized)

    @distributed_trace_async
    async def put_root_list(  # pylint: disable=inconsistent-return-statements
        self, bananas: ET.Element, **kwargs: Any
    ) -> None:
        """Puts a list as the root element.

        :param bananas: Required.
        :type bananas: ET.Element
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                bananas = [
                    {
                        "expiration": "2020-02-20 00:00:00",  # Optional. The time at which
                          you should reconsider eating this banana.
                        "flavor": "str",  # Optional.
                        "name": "str"  # Optional.
                    }
                ]
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        _content = bananas

        request = build_xml_put_root_list_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_root_list_single_item(self, **kwargs: Any) -> ET.Element:
        """Gets a list with a single item.

        :return: XML Element
        :rtype: ET.Element
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "expiration": "2020-02-20 00:00:00",  # Optional. The time at which
                          you should reconsider eating this banana.
                        "flavor": "str",  # Optional.
                        "name": "str"  # Optional.
                    }
                ]
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[ET.Element]

        request = build_xml_get_root_list_single_item_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(ET.Element, deserialized), {})

        return cast(ET.Element, deserialized)

    @distributed_trace_async
    async def put_root_list_single_item(  # pylint: disable=inconsistent-return-statements
        self, bananas: ET.Element, **kwargs: Any
    ) -> None:
        """Puts a list with a single item.

        :param bananas: Required.
        :type bananas: ET.Element
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                bananas = [
                    {
                        "expiration": "2020-02-20 00:00:00",  # Optional. The time at which
                          you should reconsider eating this banana.
                        "flavor": "str",  # Optional.
                        "name": "str"  # Optional.
                    }
                ]
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        _content = bananas

        request = build_xml_put_root_list_single_item_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_empty_root_list(self, **kwargs: Any) -> ET.Element:
        """Gets an empty list as the root element.

        :return: XML Element
        :rtype: ET.Element
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "expiration": "2020-02-20 00:00:00",  # Optional. The time at which
                          you should reconsider eating this banana.
                        "flavor": "str",  # Optional.
                        "name": "str"  # Optional.
                    }
                ]
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[ET.Element]

        request = build_xml_get_empty_root_list_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(ET.Element, deserialized), {})

        return cast(ET.Element, deserialized)

    @distributed_trace_async
    async def put_empty_root_list(  # pylint: disable=inconsistent-return-statements
        self, bananas: ET.Element, **kwargs: Any
    ) -> None:
        """Puts an empty list as the root element.

        :param bananas: Required.
        :type bananas: ET.Element
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                bananas = [
                    {
                        "expiration": "2020-02-20 00:00:00",  # Optional. The time at which
                          you should reconsider eating this banana.
                        "flavor": "str",  # Optional.
                        "name": "str"  # Optional.
                    }
                ]
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        _content = bananas

        request = build_xml_put_empty_root_list_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_empty_child_element(self, **kwargs: Any) -> ET.Element:
        """Gets an XML document with an empty child element.

        :return: XML Element
        :rtype: ET.Element
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "expiration": "2020-02-20 00:00:00",  # Optional. The time at which you
                      should reconsider eating this banana.
                    "flavor": "str",  # Optional.
                    "name": "str"  # Optional.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[ET.Element]

        request = build_xml_get_empty_child_element_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(ET.Element, deserialized), {})

        return cast(ET.Element, deserialized)

    @distributed_trace_async
    async def put_empty_child_element(  # pylint: disable=inconsistent-return-statements
        self, banana: ET.Element, **kwargs: Any
    ) -> None:
        """Puts a value with an empty child element.

        :param banana: Required.
        :type banana: ET.Element
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                banana = {
                    "expiration": "2020-02-20 00:00:00",  # Optional. The time at which you
                      should reconsider eating this banana.
                    "flavor": "str",  # Optional.
                    "name": "str"  # Optional.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        _content = banana

        request = build_xml_put_empty_child_element_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def list_containers(self, **kwargs: Any) -> ET.Element:
        """Lists containers in a storage account.

        :keyword comp: Default value is "list". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype comp: str
        :return: XML Element
        :rtype: ET.Element
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Containers": [
                        {
                            "Metadata": {
                                "str": "str"  # Optional. Dictionary of
                                  :code:`<string>`.
                            },
                            "Name": "str",  # Required.
                            "Properties": {
                                "Etag": "str",  # Required.
                                "Last-Modified": "2020-02-20 00:00:00",  # Required.
                                "LeaseDuration": "str",  # Optional. Known values
                                  are: "infinite" and "fixed".
                                "LeaseState": "str",  # Optional. Known values are:
                                  "available", "leased", "expired", "breaking", and "broken".
                                "LeaseStatus": "str",  # Optional. Known values are:
                                  "locked" and "unlocked".
                                "PublicAccess": "str"  # Optional. Known values are:
                                  "container" and "blob".
                            }
                        }
                    ],
                    "Marker": "str",  # Optional.
                    "MaxResults": 0,  # Required.
                    "NextMarker": "str",  # Required.
                    "Prefix": "str",  # Required.
                    "ServiceEndpoint": "str"  # Required.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        comp = kwargs.pop("comp", _params.pop("comp", "list"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[ET.Element]

        request = build_xml_list_containers_request(
            comp=comp,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(ET.Element, deserialized), {})

        return cast(ET.Element, deserialized)

    @distributed_trace_async
    async def get_service_properties(self, **kwargs: Any) -> ET.Element:
        """Gets storage service properties.

        :keyword comp: Default value is "properties". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype comp: str
        :keyword restype: Default value is "service". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype restype: str
        :return: XML Element
        :rtype: ET.Element
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Cors": [
                        {
                            "AllowedHeaders": "str",  # the request headers that the
                              origin domain may specify on the CORS request. Required.
                            "AllowedMethods": "str",  # The methods (HTTP request verbs)
                              that the origin domain may use for a CORS request. (comma separated).
                              Required.
                            "AllowedOrigins": "str",  # The origin domains that are
                              permitted to make a request against the storage service via CORS. The
                              origin domain is the domain from which the request originates. Note that
                              the origin must be an exact case-sensitive match with the origin that the
                              user age sends to the service. You can also use the wildcard character
                              '*' to allow all origin domains to make requests via CORS. Required.
                            "ExposedHeaders": "str",  # The response headers that may be
                              sent in the response to the CORS request and exposed by the browser to
                              the request issuer. Required.
                            "MaxAgeInSeconds": 0  # The maximum amount time that a
                              browser should cache the preflight OPTIONS request. Required.
                        }
                    ],
                    "DefaultServiceVersion": "str",  # Optional. The default version to use for
                      requests to the Blob service if an incoming request's version is not specified.
                      Possible values include version 2008-10-27 and all more recent versions.
                    "DeleteRetentionPolicy": {
                        "Days": 0,  # Optional. Indicates the number of days that metrics or
                          logging or soft-deleted data should be retained. All data older than this
                          value will be deleted.
                        "Enabled": bool  # Indicates whether a retention policy is enabled
                          for the storage service. Required.
                    },
                    "HourMetrics": {
                        "Enabled": bool,  # Indicates whether metrics are enabled for the
                          Blob service. Required.
                        "IncludeAPIs": bool,  # Optional. Indicates whether metrics should
                          generate summary statistics for called API operations.
                        "RetentionPolicy": {
                            "Days": 0,  # Optional. Indicates the number of days that
                              metrics or logging or soft-deleted data should be retained. All data
                              older than this value will be deleted.
                            "Enabled": bool  # Indicates whether a retention policy is
                              enabled for the storage service. Required.
                        },
                        "Version": "str"  # Optional. The version of Storage Analytics to
                          configure.
                    },
                    "Logging": {
                        "Delete": bool,  # Indicates whether all delete requests should be
                          logged. Required.
                        "Read": bool,  # Indicates whether all read requests should be
                          logged. Required.
                        "RetentionPolicy": {
                            "Days": 0,  # Optional. Indicates the number of days that
                              metrics or logging or soft-deleted data should be retained. All data
                              older than this value will be deleted.
                            "Enabled": bool  # Indicates whether a retention policy is
                              enabled for the storage service. Required.
                        },
                        "Version": "str",  # The version of Storage Analytics to configure.
                          Required.
                        "Write": bool  # Indicates whether all write requests should be
                          logged. Required.
                    },
                    "MinuteMetrics": {
                        "Enabled": bool,  # Indicates whether metrics are enabled for the
                          Blob service. Required.
                        "IncludeAPIs": bool,  # Optional. Indicates whether metrics should
                          generate summary statistics for called API operations.
                        "RetentionPolicy": {
                            "Days": 0,  # Optional. Indicates the number of days that
                              metrics or logging or soft-deleted data should be retained. All data
                              older than this value will be deleted.
                            "Enabled": bool  # Indicates whether a retention policy is
                              enabled for the storage service. Required.
                        },
                        "Version": "str"  # Optional. The version of Storage Analytics to
                          configure.
                    }
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        comp = kwargs.pop("comp", _params.pop("comp", "properties"))  # type: str
        restype = kwargs.pop("restype", _params.pop("restype", "service"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[ET.Element]

        request = build_xml_get_service_properties_request(
            comp=comp,
            restype=restype,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(ET.Element, deserialized), {})

        return cast(ET.Element, deserialized)

    @distributed_trace_async
    async def put_service_properties(  # pylint: disable=inconsistent-return-statements
        self, properties: ET.Element, **kwargs: Any
    ) -> None:
        """Puts storage service properties.

        :param properties: Required.
        :type properties: ET.Element
        :keyword comp: Default value is "properties". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype comp: str
        :keyword restype: Default value is "service". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype restype: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "Cors": [
                        {
                            "AllowedHeaders": "str",  # the request headers that the
                              origin domain may specify on the CORS request. Required.
                            "AllowedMethods": "str",  # The methods (HTTP request verbs)
                              that the origin domain may use for a CORS request. (comma separated).
                              Required.
                            "AllowedOrigins": "str",  # The origin domains that are
                              permitted to make a request against the storage service via CORS. The
                              origin domain is the domain from which the request originates. Note that
                              the origin must be an exact case-sensitive match with the origin that the
                              user age sends to the service. You can also use the wildcard character
                              '*' to allow all origin domains to make requests via CORS. Required.
                            "ExposedHeaders": "str",  # The response headers that may be
                              sent in the response to the CORS request and exposed by the browser to
                              the request issuer. Required.
                            "MaxAgeInSeconds": 0  # The maximum amount time that a
                              browser should cache the preflight OPTIONS request. Required.
                        }
                    ],
                    "DefaultServiceVersion": "str",  # Optional. The default version to use for
                      requests to the Blob service if an incoming request's version is not specified.
                      Possible values include version 2008-10-27 and all more recent versions.
                    "DeleteRetentionPolicy": {
                        "Days": 0,  # Optional. Indicates the number of days that metrics or
                          logging or soft-deleted data should be retained. All data older than this
                          value will be deleted.
                        "Enabled": bool  # Indicates whether a retention policy is enabled
                          for the storage service. Required.
                    },
                    "HourMetrics": {
                        "Enabled": bool,  # Indicates whether metrics are enabled for the
                          Blob service. Required.
                        "IncludeAPIs": bool,  # Optional. Indicates whether metrics should
                          generate summary statistics for called API operations.
                        "RetentionPolicy": {
                            "Days": 0,  # Optional. Indicates the number of days that
                              metrics or logging or soft-deleted data should be retained. All data
                              older than this value will be deleted.
                            "Enabled": bool  # Indicates whether a retention policy is
                              enabled for the storage service. Required.
                        },
                        "Version": "str"  # Optional. The version of Storage Analytics to
                          configure.
                    },
                    "Logging": {
                        "Delete": bool,  # Indicates whether all delete requests should be
                          logged. Required.
                        "Read": bool,  # Indicates whether all read requests should be
                          logged. Required.
                        "RetentionPolicy": {
                            "Days": 0,  # Optional. Indicates the number of days that
                              metrics or logging or soft-deleted data should be retained. All data
                              older than this value will be deleted.
                            "Enabled": bool  # Indicates whether a retention policy is
                              enabled for the storage service. Required.
                        },
                        "Version": "str",  # The version of Storage Analytics to configure.
                          Required.
                        "Write": bool  # Indicates whether all write requests should be
                          logged. Required.
                    },
                    "MinuteMetrics": {
                        "Enabled": bool,  # Indicates whether metrics are enabled for the
                          Blob service. Required.
                        "IncludeAPIs": bool,  # Optional. Indicates whether metrics should
                          generate summary statistics for called API operations.
                        "RetentionPolicy": {
                            "Days": 0,  # Optional. Indicates the number of days that
                              metrics or logging or soft-deleted data should be retained. All data
                              older than this value will be deleted.
                            "Enabled": bool  # Indicates whether a retention policy is
                              enabled for the storage service. Required.
                        },
                        "Version": "str"  # Optional. The version of Storage Analytics to
                          configure.
                    }
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        comp = kwargs.pop("comp", _params.pop("comp", "properties"))  # type: str
        restype = kwargs.pop("restype", _params.pop("restype", "service"))  # type: str
        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        _content = properties

        request = build_xml_put_service_properties_request(
            comp=comp,
            restype=restype,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_acls(self, **kwargs: Any) -> ET.Element:
        """Gets storage ACLs for a container.

        :keyword comp: Default value is "acl". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype comp: str
        :keyword restype: Default value is "container". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype restype: str
        :return: XML Element
        :rtype: ET.Element
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "AccessPolicy": {
                            "Expiry": "2020-02-20 00:00:00",  # the date-time the policy
                              expires. Required.
                            "Permission": "str",  # the permissions for the acl policy.
                              Required.
                            "Start": "2020-02-20 00:00:00"  # the date-time the policy is
                              active. Required.
                        },
                        "Id": "str"  # a unique id. Required.
                    }
                ]
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        comp = kwargs.pop("comp", _params.pop("comp", "acl"))  # type: str
        restype = kwargs.pop("restype", _params.pop("restype", "container"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[ET.Element]

        request = build_xml_get_acls_request(
            comp=comp,
            restype=restype,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(ET.Element, deserialized), {})

        return cast(ET.Element, deserialized)

    @distributed_trace_async
    async def put_acls(  # pylint: disable=inconsistent-return-statements
        self, properties: ET.Element, **kwargs: Any
    ) -> None:
        """Puts storage ACLs for a container.

        :param properties: Required.
        :type properties: ET.Element
        :keyword comp: Default value is "acl". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype comp: str
        :keyword restype: Default value is "container". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype restype: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = [
                    {
                        "AccessPolicy": {
                            "Expiry": "2020-02-20 00:00:00",  # the date-time the policy
                              expires. Required.
                            "Permission": "str",  # the permissions for the acl policy.
                              Required.
                            "Start": "2020-02-20 00:00:00"  # the date-time the policy is
                              active. Required.
                        },
                        "Id": "str"  # a unique id. Required.
                    }
                ]
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        comp = kwargs.pop("comp", _params.pop("comp", "acl"))  # type: str
        restype = kwargs.pop("restype", _params.pop("restype", "container"))  # type: str
        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        _content = properties

        request = build_xml_put_acls_request(
            comp=comp,
            restype=restype,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def list_blobs(self, **kwargs: Any) -> ET.Element:
        """Lists blobs in a storage container.

        :keyword comp: Default value is "list". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype comp: str
        :keyword restype: Default value is "container". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype restype: str
        :return: XML Element
        :rtype: ET.Element
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Blobs": {
                        "Blob": [
                            {
                                "Deleted": bool,  # Required.
                                "Metadata": {
                                    "str": "str"  # Optional. Dictionary of
                                      :code:`<string>`.
                                },
                                "Name": "str",  # Required.
                                "Properties": {
                                    "AccessTier": "str",  # Optional. Known
                                      values are: "P4", "P6", "P10", "P20", "P30", "P40", "P50", "Hot",
                                      "Cool", and "Archive".
                                    "AccessTierInferred": bool,  # Optional.
                                      Properties of a blob. Required.
                                    "ArchiveStatus": "str",  # Optional. Known
                                      values are: "rehydrate-pending-to-hot" and
                                      "rehydrate-pending-to-cool".
                                    "BlobType": "str",  # Optional. Known values
                                      are: "BlockBlob", "PageBlob", and "AppendBlob".
                                    "Cache-Control": "str",  # Optional.
                                      Properties of a blob. Required.
                                    "Content-Disposition": "str",  # Optional.
                                      Properties of a blob. Required.
                                    "Content-Encoding": "str",  # Optional.
                                      Properties of a blob. Required.
                                    "Content-Language": "str",  # Optional.
                                      Properties of a blob. Required.
                                    "Content-Length": 0,  # Optional. Size in
                                      bytes.
                                    "Content-MD5": "str",  # Optional. Properties
                                      of a blob. Required.
                                    "Content-Type": "str",  # Optional.
                                      Properties of a blob. Required.
                                    "CopyCompletionTime": "2020-02-20 00:00:00",
                                      # Optional. Properties of a blob. Required.
                                    "CopyId": "str",  # Optional. Properties of a
                                      blob. Required.
                                    "CopyProgress": "str",  # Optional.
                                      Properties of a blob. Required.
                                    "CopySource": "str",  # Optional. Properties
                                      of a blob. Required.
                                    "CopyStatus": "str",  # Optional. Known
                                      values are: "pending", "success", "aborted", and "failed".
                                    "CopyStatusDescription": "str",  # Optional.
                                      Properties of a blob. Required.
                                    "DeletedTime": "2020-02-20 00:00:00",  #
                                      Optional. Properties of a blob. Required.
                                    "DestinationSnapshot": "str",  # Optional.
                                      Properties of a blob. Required.
                                    "Etag": "str",  # Required.
                                    "IncrementalCopy": bool,  # Optional.
                                      Properties of a blob. Required.
                                    "Last-Modified": "2020-02-20 00:00:00",  #
                                      Required.
                                    "LeaseDuration": "str",  # Optional. Known
                                      values are: "infinite" and "fixed".
                                    "LeaseState": "str",  # Optional. Known
                                      values are: "available", "leased", "expired", "breaking", and
                                      "broken".
                                    "LeaseStatus": "str",  # Optional. Known
                                      values are: "locked" and "unlocked".
                                    "RemainingRetentionDays": 0,  # Optional.
                                      Properties of a blob. Required.
                                    "ServerEncrypted": bool,  # Optional.
                                      Properties of a blob. Required.
                                    "x-ms-blob-sequence-number": 0  # Optional.
                                      Properties of a blob. Required.
                                },
                                "Snapshot": "str"  # Required.
                            }
                        ],
                        "BlobPrefix": [
                            {
                                "Name": "str"  # Required.
                            }
                        ]
                    },
                    "ContainerName": "str",  # Required.
                    "Delimiter": "str",  # Required.
                    "Marker": "str",  # Required.
                    "MaxResults": 0,  # Required.
                    "NextMarker": "str",  # Required.
                    "Prefix": "str",  # Required.
                    "ServiceEndpoint": "str"  # Optional.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        comp = kwargs.pop("comp", _params.pop("comp", "list"))  # type: str
        restype = kwargs.pop("restype", _params.pop("restype", "container"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[ET.Element]

        request = build_xml_list_blobs_request(
            comp=comp,
            restype=restype,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(ET.Element, deserialized), {})

        return cast(ET.Element, deserialized)

    @overload
    async def json_input(  # pylint: disable=inconsistent-return-statements
        self, properties: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """A Swagger with XML that has one operation that takes JSON as input. You need to send the ID
        number 42.

        :param properties: Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "id": 0  # Optional.
                }
        """

    @overload
    async def json_input(  # pylint: disable=inconsistent-return-statements
        self, properties: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """A Swagger with XML that has one operation that takes JSON as input. You need to send the ID
        number 42.

        :param properties: Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def json_input(  # pylint: disable=inconsistent-return-statements
        self, properties: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """A Swagger with XML that has one operation that takes JSON as input. You need to send the ID
        number 42.

        :param properties: Is either a model type or a IO type. Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IO, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_xml_json_input_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def json_output(self, **kwargs: Any) -> JSON:
        """A Swagger with XML that has one operation that returns JSON. ID number 42.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "id": 0  # Optional.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_xml_json_output_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def get_xms_text(self, **kwargs: Any) -> ET.Element:
        """Get back an XML object with an x-ms-text property, which should translate to the returned
        object's 'language' property being 'english' and its 'content' property being 'I am text'.

        :return: XML Element
        :rtype: ET.Element
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "content": "str",  # Optional. Returned value should be 'I am text'.
                    "language": "str"  # Optional. Returned value should be 'english'.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[ET.Element]

        request = build_xml_get_xms_text_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(ET.Element, deserialized), {})

        return cast(ET.Element, deserialized)

    @distributed_trace_async
    async def get_bytes(self, **kwargs: Any) -> ET.Element:
        """Get an XML document with binary property.

        :return: XML Element
        :rtype: ET.Element
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Bytes": bytes("bytes", encoding="utf-8")  # Optional.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[ET.Element]

        request = build_xml_get_bytes_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(ET.Element, deserialized), {})

        return cast(ET.Element, deserialized)

    @distributed_trace_async
    async def put_binary(  # pylint: disable=inconsistent-return-statements
        self, slideshow: ET.Element, **kwargs: Any
    ) -> None:
        """Put an XML document with binary property.

        :param slideshow: Required.
        :type slideshow: ET.Element
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                slideshow = {
                    "Bytes": bytes("bytes", encoding="utf-8")  # Optional.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        _content = slideshow

        request = build_xml_put_binary_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_uri(self, **kwargs: Any) -> ET.Element:
        """Get an XML document with uri property.

        :return: XML Element
        :rtype: ET.Element
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Url": "str"  # Optional.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[ET.Element]

        request = build_xml_get_uri_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(ET.Element, deserialized), {})

        return cast(ET.Element, deserialized)

    @distributed_trace_async
    async def put_uri(self, model: ET.Element, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Put an XML document with uri property.

        :param model: Required.
        :type model: ET.Element
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                model = {
                    "Url": "str"  # Optional.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/xml"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        _content = model

        request = build_xml_put_uri_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})
