# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, List, Optional, TypeVar
from xml.etree import ElementTree as ET

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async

from ...operations._operations import (
    build_xml_get_acls_request,
    build_xml_get_bytes_request,
    build_xml_get_complex_type_ref_no_meta_request,
    build_xml_get_complex_type_ref_with_meta_request,
    build_xml_get_empty_child_element_request,
    build_xml_get_empty_list_request,
    build_xml_get_empty_root_list_request,
    build_xml_get_empty_wrapped_lists_request,
    build_xml_get_headers_request,
    build_xml_get_root_list_request,
    build_xml_get_root_list_single_item_request,
    build_xml_get_service_properties_request,
    build_xml_get_simple_request,
    build_xml_get_uri_request,
    build_xml_get_wrapped_lists_request,
    build_xml_get_xms_text_request,
    build_xml_json_input_request,
    build_xml_json_output_request,
    build_xml_list_blobs_request,
    build_xml_list_containers_request,
    build_xml_put_acls_request,
    build_xml_put_binary_request,
    build_xml_put_complex_type_ref_no_meta_request,
    build_xml_put_complex_type_ref_with_meta_request,
    build_xml_put_empty_child_element_request,
    build_xml_put_empty_list_request,
    build_xml_put_empty_root_list_request,
    build_xml_put_empty_wrapped_lists_request,
    build_xml_put_root_list_request,
    build_xml_put_root_list_single_item_request,
    build_xml_put_service_properties_request,
    build_xml_put_simple_request,
    build_xml_put_uri_request,
    build_xml_put_wrapped_lists_request,
)

T = TypeVar("T")
JSONType = Any
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class XmlOperations:  # pylint: disable=too-many-public-methods
    """XmlOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    @distributed_trace_async
    async def get_complex_type_ref_no_meta(self, **kwargs: Any) -> JSONType:
        """Get a complex type that has a ref to a complex type with no XML node.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "RefToModel": {
                        "ID": "str"  # Optional. The id of the res.
                    },
                    "Something": "str"  # Optional. Something else (just to avoid flattening).
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_complex_type_ref_no_meta_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def put_complex_type_ref_no_meta(  # pylint: disable=inconsistent-return-statements
        self, model: JSONType, **kwargs: Any
    ) -> None:
        """Puts a complex type that has a ref to a complex type with no XML node.

        :param model:
        :type model: JSONType
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                model = {
                    "RefToModel": {
                        "ID": "str"  # Optional. The id of the res.
                    },
                    "Something": "str"  # Optional. Something else (just to avoid flattening).
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        _content = model

        request = build_xml_put_complex_type_ref_no_meta_request(
            content_type=content_type,
            content=_content,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_complex_type_ref_with_meta(self, **kwargs: Any) -> JSONType:
        """Get a complex type that has a ref to a complex type with XML node.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "RefToModel": {
                        "ID": "str"  # Optional. The id of the res.
                    },
                    "Something": "str"  # Optional. Something else (just to avoid flattening).
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_complex_type_ref_with_meta_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def put_complex_type_ref_with_meta(  # pylint: disable=inconsistent-return-statements
        self, model: JSONType, **kwargs: Any
    ) -> None:
        """Puts a complex type that has a ref to a complex type with XML node.

        :param model:
        :type model: JSONType
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                model = {
                    "RefToModel": {
                        "ID": "str"  # Optional. The id of the res.
                    },
                    "Something": "str"  # Optional. Something else (just to avoid flattening).
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        _content = model

        request = build_xml_put_complex_type_ref_with_meta_request(
            content_type=content_type,
            content=_content,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_simple(self, **kwargs: Any) -> JSONType:
        """Get a simple XML document.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "author": "str",  # Optional.
                    "date": "str",  # Optional.
                    "slides": [
                        {
                            "items": [
                                "str"  # Optional.
                            ],
                            "title": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "title": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_simple_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def put_simple(  # pylint: disable=inconsistent-return-statements
        self, slideshow: JSONType, **kwargs: Any
    ) -> None:
        """Put a simple XML document.

        :param slideshow:
        :type slideshow: JSONType
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                slideshow = {
                    "author": "str",  # Optional.
                    "date": "str",  # Optional.
                    "slides": [
                        {
                            "items": [
                                "str"  # Optional.
                            ],
                            "title": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "title": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        _content = slideshow

        request = build_xml_put_simple_request(
            content_type=content_type,
            content=_content,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_wrapped_lists(self, **kwargs: Any) -> JSONType:
        """Get an XML document with multiple wrapped lists.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "BadApples": [
                        "str"  # Optional.
                    ],
                    "GoodApples": [
                        "str"  # Optional.
                    ]
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_wrapped_lists_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def put_wrapped_lists(  # pylint: disable=inconsistent-return-statements
        self, wrapped_lists: JSONType, **kwargs: Any
    ) -> None:
        """Put an XML document with multiple wrapped lists.

        :param wrapped_lists:
        :type wrapped_lists: JSONType
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                wrapped_lists = {
                    "BadApples": [
                        "str"  # Optional.
                    ],
                    "GoodApples": [
                        "str"  # Optional.
                    ]
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        _content = wrapped_lists

        request = build_xml_put_wrapped_lists_request(
            content_type=content_type,
            content=_content,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_headers(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Get strongly-typed response headers.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_headers_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Custom-Header"] = self._deserialize("str", response.headers.get("Custom-Header"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace_async
    async def get_empty_list(self, **kwargs: Any) -> JSONType:
        """Get an empty list.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "author": "str",  # Optional.
                    "date": "str",  # Optional.
                    "slides": [
                        {
                            "items": [
                                "str"  # Optional.
                            ],
                            "title": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "title": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_empty_list_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def put_empty_list(  # pylint: disable=inconsistent-return-statements
        self, slideshow: JSONType, **kwargs: Any
    ) -> None:
        """Puts an empty list.

        :param slideshow:
        :type slideshow: JSONType
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                slideshow = {
                    "author": "str",  # Optional.
                    "date": "str",  # Optional.
                    "slides": [
                        {
                            "items": [
                                "str"  # Optional.
                            ],
                            "title": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "title": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        _content = slideshow

        request = build_xml_put_empty_list_request(
            content_type=content_type,
            content=_content,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_empty_wrapped_lists(self, **kwargs: Any) -> JSONType:
        """Gets some empty wrapped lists.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "BadApples": [
                        "str"  # Optional.
                    ],
                    "GoodApples": [
                        "str"  # Optional.
                    ]
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_empty_wrapped_lists_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def put_empty_wrapped_lists(  # pylint: disable=inconsistent-return-statements
        self, apple_barrel: JSONType, **kwargs: Any
    ) -> None:
        """Puts some empty wrapped lists.

        :param apple_barrel:
        :type apple_barrel: JSONType
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                apple_barrel = {
                    "BadApples": [
                        "str"  # Optional.
                    ],
                    "GoodApples": [
                        "str"  # Optional.
                    ]
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        _content = apple_barrel

        request = build_xml_put_empty_wrapped_lists_request(
            content_type=content_type,
            content=_content,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_root_list(self, **kwargs: Any) -> List[JSONType]:
        """Gets a list as the root element.

        :return: list of JSON object
        :rtype: list[JSONType]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "expiration": "2020-02-20 00:00:00",  # Optional. The time at which
                          you should reconsider eating this banana.
                        "flavor": "str",  # Optional.
                        "name": "str"  # Optional.
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[List[JSONType]]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_root_list_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def put_root_list(  # pylint: disable=inconsistent-return-statements
        self, bananas: List[JSONType], **kwargs: Any
    ) -> None:
        """Puts a list as the root element.

        :param bananas:
        :type bananas: list[JSONType]
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                bananas = [
                    {
                        "expiration": "2020-02-20 00:00:00",  # Optional. The time at which
                          you should reconsider eating this banana.
                        "flavor": "str",  # Optional.
                        "name": "str"  # Optional.
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        _content = bananas

        request = build_xml_put_root_list_request(
            content_type=content_type,
            content=_content,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_root_list_single_item(self, **kwargs: Any) -> List[JSONType]:
        """Gets a list with a single item.

        :return: list of JSON object
        :rtype: list[JSONType]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "expiration": "2020-02-20 00:00:00",  # Optional. The time at which
                          you should reconsider eating this banana.
                        "flavor": "str",  # Optional.
                        "name": "str"  # Optional.
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[List[JSONType]]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_root_list_single_item_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def put_root_list_single_item(  # pylint: disable=inconsistent-return-statements
        self, bananas: List[JSONType], **kwargs: Any
    ) -> None:
        """Puts a list with a single item.

        :param bananas:
        :type bananas: list[JSONType]
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                bananas = [
                    {
                        "expiration": "2020-02-20 00:00:00",  # Optional. The time at which
                          you should reconsider eating this banana.
                        "flavor": "str",  # Optional.
                        "name": "str"  # Optional.
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        _content = bananas

        request = build_xml_put_root_list_single_item_request(
            content_type=content_type,
            content=_content,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_empty_root_list(self, **kwargs: Any) -> List[JSONType]:
        """Gets an empty list as the root element.

        :return: list of JSON object
        :rtype: list[JSONType]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "expiration": "2020-02-20 00:00:00",  # Optional. The time at which
                          you should reconsider eating this banana.
                        "flavor": "str",  # Optional.
                        "name": "str"  # Optional.
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[List[JSONType]]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_empty_root_list_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def put_empty_root_list(  # pylint: disable=inconsistent-return-statements
        self, bananas: List[JSONType], **kwargs: Any
    ) -> None:
        """Puts an empty list as the root element.

        :param bananas:
        :type bananas: list[JSONType]
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                bananas = [
                    {
                        "expiration": "2020-02-20 00:00:00",  # Optional. The time at which
                          you should reconsider eating this banana.
                        "flavor": "str",  # Optional.
                        "name": "str"  # Optional.
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        _content = bananas

        request = build_xml_put_empty_root_list_request(
            content_type=content_type,
            content=_content,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_empty_child_element(self, **kwargs: Any) -> JSONType:
        """Gets an XML document with an empty child element.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "expiration": "2020-02-20 00:00:00",  # Optional. The time at which you
                      should reconsider eating this banana.
                    "flavor": "str",  # Optional.
                    "name": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_empty_child_element_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def put_empty_child_element(  # pylint: disable=inconsistent-return-statements
        self, banana: JSONType, **kwargs: Any
    ) -> None:
        """Puts a value with an empty child element.

        :param banana:
        :type banana: JSONType
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                banana = {
                    "expiration": "2020-02-20 00:00:00",  # Optional. The time at which you
                      should reconsider eating this banana.
                    "flavor": "str",  # Optional.
                    "name": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        _content = banana

        request = build_xml_put_empty_child_element_request(
            content_type=content_type,
            content=_content,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def list_containers(self, **kwargs: Any) -> JSONType:
        """Lists containers in a storage account.

        :keyword comp:  Default value is "list". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype comp: str
        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Containers": [
                        {
                            "Metadata": {
                                "str": "str"  # Optional. Dictionary of
                                  :code:`<string>`.
                            },
                            "Name": "str",  # Required.
                            "Properties": {
                                "Etag": "str",  # Required.
                                "Last-Modified": "2020-02-20 00:00:00",  # Required.
                                "LeaseDuration": "str",  # Optional. Possible values
                                  include: "infinite", "fixed".
                                "LeaseState": "str",  # Optional. Possible values
                                  include: "available", "leased", "expired", "breaking", "broken".
                                "LeaseStatus": "str",  # Optional. Possible values
                                  include: "locked", "unlocked".
                                "PublicAccess": "str"  # Optional. Possible values
                                  include: "container", "blob".
                            }
                        }
                    ],
                    "Marker": "str",  # Optional.
                    "MaxResults": 0,  # Required.
                    "NextMarker": "str",  # Required.
                    "Prefix": "str",  # Required.
                    "ServiceEndpoint": "str"  # Required.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        comp = kwargs.pop("comp", "list")  # type: str

        request = build_xml_list_containers_request(
            comp=comp,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def get_service_properties(self, **kwargs: Any) -> JSONType:
        """Gets storage service properties.

        :keyword comp:  Default value is "properties". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype comp: str
        :keyword restype:  Default value is "service". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype restype: str
        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Cors": [
                        {
                            "AllowedHeaders": "str",  # Required. the request headers
                              that the origin domain may specify on the CORS request.
                            "AllowedMethods": "str",  # Required. The methods (HTTP
                              request verbs) that the origin domain may use for a CORS request. (comma
                              separated).
                            "AllowedOrigins": "str",  # Required. The origin domains that
                              are permitted to make a request against the storage service via CORS. The
                              origin domain is the domain from which the request originates. Note that
                              the origin must be an exact case-sensitive match with the origin that the
                              user age sends to the service. You can also use the wildcard character
                              '*' to allow all origin domains to make requests via CORS.
                            "ExposedHeaders": "str",  # Required. The response headers
                              that may be sent in the response to the CORS request and exposed by the
                              browser to the request issuer.
                            "MaxAgeInSeconds": 0  # Required. The maximum amount time
                              that a browser should cache the preflight OPTIONS request.
                        }
                    ],
                    "DefaultServiceVersion": "str",  # Optional. The default version to use for
                      requests to the Blob service if an incoming request's version is not specified.
                      Possible values include version 2008-10-27 and all more recent versions.
                    "DeleteRetentionPolicy": {
                        "Days": 0,  # Optional. Indicates the number of days that metrics or
                          logging or soft-deleted data should be retained. All data older than this
                          value will be deleted.
                        "Enabled": bool  # Required. Indicates whether a retention policy is
                          enabled for the storage service.
                    },
                    "HourMetrics": {
                        "Enabled": bool,  # Required. Indicates whether metrics are enabled
                          for the Blob service.
                        "IncludeAPIs": bool,  # Optional. Indicates whether metrics should
                          generate summary statistics for called API operations.
                        "RetentionPolicy": {
                            "Days": 0,  # Optional. Indicates the number of days that
                              metrics or logging or soft-deleted data should be retained. All data
                              older than this value will be deleted.
                            "Enabled": bool  # Required. Indicates whether a retention
                              policy is enabled for the storage service.
                        },
                        "Version": "str"  # Optional. The version of Storage Analytics to
                          configure.
                    },
                    "Logging": {
                        "Delete": bool,  # Required. Indicates whether all delete requests
                          should be logged.
                        "Read": bool,  # Required. Indicates whether all read requests should
                          be logged.
                        "RetentionPolicy": {
                            "Days": 0,  # Optional. Indicates the number of days that
                              metrics or logging or soft-deleted data should be retained. All data
                              older than this value will be deleted.
                            "Enabled": bool  # Required. Indicates whether a retention
                              policy is enabled for the storage service.
                        },
                        "Version": "str",  # Required. The version of Storage Analytics to
                          configure.
                        "Write": bool  # Required. Indicates whether all write requests
                          should be logged.
                    },
                    "MinuteMetrics": {
                        "Enabled": bool,  # Required. Indicates whether metrics are enabled
                          for the Blob service.
                        "IncludeAPIs": bool,  # Optional. Indicates whether metrics should
                          generate summary statistics for called API operations.
                        "RetentionPolicy": {
                            "Days": 0,  # Optional. Indicates the number of days that
                              metrics or logging or soft-deleted data should be retained. All data
                              older than this value will be deleted.
                            "Enabled": bool  # Required. Indicates whether a retention
                              policy is enabled for the storage service.
                        },
                        "Version": "str"  # Optional. The version of Storage Analytics to
                          configure.
                    }
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        comp = kwargs.pop("comp", "properties")  # type: str
        restype = kwargs.pop("restype", "service")  # type: str

        request = build_xml_get_service_properties_request(
            comp=comp,
            restype=restype,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def put_service_properties(  # pylint: disable=inconsistent-return-statements
        self, properties: JSONType, **kwargs: Any
    ) -> None:
        """Puts storage service properties.

        :param properties:
        :type properties: JSONType
        :keyword comp:  Default value is "properties". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype comp: str
        :keyword restype:  Default value is "service". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype restype: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "Cors": [
                        {
                            "AllowedHeaders": "str",  # Required. the request headers
                              that the origin domain may specify on the CORS request.
                            "AllowedMethods": "str",  # Required. The methods (HTTP
                              request verbs) that the origin domain may use for a CORS request. (comma
                              separated).
                            "AllowedOrigins": "str",  # Required. The origin domains that
                              are permitted to make a request against the storage service via CORS. The
                              origin domain is the domain from which the request originates. Note that
                              the origin must be an exact case-sensitive match with the origin that the
                              user age sends to the service. You can also use the wildcard character
                              '*' to allow all origin domains to make requests via CORS.
                            "ExposedHeaders": "str",  # Required. The response headers
                              that may be sent in the response to the CORS request and exposed by the
                              browser to the request issuer.
                            "MaxAgeInSeconds": 0  # Required. The maximum amount time
                              that a browser should cache the preflight OPTIONS request.
                        }
                    ],
                    "DefaultServiceVersion": "str",  # Optional. The default version to use for
                      requests to the Blob service if an incoming request's version is not specified.
                      Possible values include version 2008-10-27 and all more recent versions.
                    "DeleteRetentionPolicy": {
                        "Days": 0,  # Optional. Indicates the number of days that metrics or
                          logging or soft-deleted data should be retained. All data older than this
                          value will be deleted.
                        "Enabled": bool  # Required. Indicates whether a retention policy is
                          enabled for the storage service.
                    },
                    "HourMetrics": {
                        "Enabled": bool,  # Required. Indicates whether metrics are enabled
                          for the Blob service.
                        "IncludeAPIs": bool,  # Optional. Indicates whether metrics should
                          generate summary statistics for called API operations.
                        "RetentionPolicy": {
                            "Days": 0,  # Optional. Indicates the number of days that
                              metrics or logging or soft-deleted data should be retained. All data
                              older than this value will be deleted.
                            "Enabled": bool  # Required. Indicates whether a retention
                              policy is enabled for the storage service.
                        },
                        "Version": "str"  # Optional. The version of Storage Analytics to
                          configure.
                    },
                    "Logging": {
                        "Delete": bool,  # Required. Indicates whether all delete requests
                          should be logged.
                        "Read": bool,  # Required. Indicates whether all read requests should
                          be logged.
                        "RetentionPolicy": {
                            "Days": 0,  # Optional. Indicates the number of days that
                              metrics or logging or soft-deleted data should be retained. All data
                              older than this value will be deleted.
                            "Enabled": bool  # Required. Indicates whether a retention
                              policy is enabled for the storage service.
                        },
                        "Version": "str",  # Required. The version of Storage Analytics to
                          configure.
                        "Write": bool  # Required. Indicates whether all write requests
                          should be logged.
                    },
                    "MinuteMetrics": {
                        "Enabled": bool,  # Required. Indicates whether metrics are enabled
                          for the Blob service.
                        "IncludeAPIs": bool,  # Optional. Indicates whether metrics should
                          generate summary statistics for called API operations.
                        "RetentionPolicy": {
                            "Days": 0,  # Optional. Indicates the number of days that
                              metrics or logging or soft-deleted data should be retained. All data
                              older than this value will be deleted.
                            "Enabled": bool  # Required. Indicates whether a retention
                              policy is enabled for the storage service.
                        },
                        "Version": "str"  # Optional. The version of Storage Analytics to
                          configure.
                    }
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        comp = kwargs.pop("comp", "properties")  # type: str
        restype = kwargs.pop("restype", "service")  # type: str
        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        _content = properties

        request = build_xml_put_service_properties_request(
            comp=comp,
            restype=restype,
            content_type=content_type,
            content=_content,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_acls(self, **kwargs: Any) -> List[JSONType]:
        """Gets storage ACLs for a container.

        :keyword comp:  Default value is "acl". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype comp: str
        :keyword restype:  Default value is "container". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype restype: str
        :return: list of JSON object
        :rtype: list[JSONType]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "AccessPolicy": {
                            "Expiry": "2020-02-20 00:00:00",  # Required. the date-time
                              the policy expires.
                            "Permission": "str",  # Required. the permissions for the acl
                              policy.
                            "Start": "2020-02-20 00:00:00"  # Required. the date-time the
                              policy is active.
                        },
                        "Id": "str"  # Required. a unique id.
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[List[JSONType]]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        comp = kwargs.pop("comp", "acl")  # type: str
        restype = kwargs.pop("restype", "container")  # type: str

        request = build_xml_get_acls_request(
            comp=comp,
            restype=restype,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def put_acls(  # pylint: disable=inconsistent-return-statements
        self, properties: List[JSONType], **kwargs: Any
    ) -> None:
        """Puts storage ACLs for a container.

        :param properties:
        :type properties: list[JSONType]
        :keyword comp:  Default value is "acl". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype comp: str
        :keyword restype:  Default value is "container". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype restype: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = [
                    {
                        "AccessPolicy": {
                            "Expiry": "2020-02-20 00:00:00",  # Required. the date-time
                              the policy expires.
                            "Permission": "str",  # Required. the permissions for the acl
                              policy.
                            "Start": "2020-02-20 00:00:00"  # Required. the date-time the
                              policy is active.
                        },
                        "Id": "str"  # Required. a unique id.
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        comp = kwargs.pop("comp", "acl")  # type: str
        restype = kwargs.pop("restype", "container")  # type: str
        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        _content = properties

        request = build_xml_put_acls_request(
            comp=comp,
            restype=restype,
            content_type=content_type,
            content=_content,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def list_blobs(self, **kwargs: Any) -> JSONType:
        """Lists blobs in a storage container.

        :keyword comp:  Default value is "list". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype comp: str
        :keyword restype:  Default value is "container". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype restype: str
        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Blobs": {
                        "Blob": [
                            {
                                "Deleted": bool,  # Required.
                                "Metadata": {
                                    "str": "str"  # Optional. Dictionary of
                                      :code:`<string>`.
                                },
                                "Name": "str",  # Required.
                                "Properties": {
                                    "AccessTier": "str",  # Optional. Possible
                                      values include: "P4", "P6", "P10", "P20", "P30", "P40", "P50",
                                      "Hot", "Cool", "Archive".
                                    "AccessTierInferred": bool,  # Optional.
                                      Required. Properties of a blob.
                                    "ArchiveStatus": "str",  # Optional. Possible
                                      values include: "rehydrate-pending-to-hot",
                                      "rehydrate-pending-to-cool".
                                    "BlobType": "str",  # Optional. Possible
                                      values include: "BlockBlob", "PageBlob", "AppendBlob".
                                    "Cache-Control": "str",  # Optional.
                                      Required. Properties of a blob.
                                    "Content-Disposition": "str",  # Optional.
                                      Required. Properties of a blob.
                                    "Content-Encoding": "str",  # Optional.
                                      Required. Properties of a blob.
                                    "Content-Language": "str",  # Optional.
                                      Required. Properties of a blob.
                                    "Content-Length": 0.0,  # Optional. Size in
                                      bytes.
                                    "Content-MD5": "str",  # Optional. Required.
                                      Properties of a blob.
                                    "Content-Type": "str",  # Optional. Required.
                                      Properties of a blob.
                                    "CopyCompletionTime": "2020-02-20 00:00:00",
                                      # Optional. Required. Properties of a blob.
                                    "CopyId": "str",  # Optional. Required.
                                      Properties of a blob.
                                    "CopyProgress": "str",  # Optional. Required.
                                      Properties of a blob.
                                    "CopySource": "str",  # Optional. Required.
                                      Properties of a blob.
                                    "CopyStatus": "str",  # Optional. Possible
                                      values include: "pending", "success", "aborted", "failed".
                                    "CopyStatusDescription": "str",  # Optional.
                                      Required. Properties of a blob.
                                    "DeletedTime": "2020-02-20 00:00:00",  #
                                      Optional. Required. Properties of a blob.
                                    "DestinationSnapshot": "str",  # Optional.
                                      Required. Properties of a blob.
                                    "Etag": "str",  # Required.
                                    "IncrementalCopy": bool,  # Optional.
                                      Required. Properties of a blob.
                                    "Last-Modified": "2020-02-20 00:00:00",  #
                                      Required.
                                    "LeaseDuration": "str",  # Optional. Possible
                                      values include: "infinite", "fixed".
                                    "LeaseState": "str",  # Optional. Possible
                                      values include: "available", "leased", "expired", "breaking",
                                      "broken".
                                    "LeaseStatus": "str",  # Optional. Possible
                                      values include: "locked", "unlocked".
                                    "RemainingRetentionDays": 0,  # Optional.
                                      Required. Properties of a blob.
                                    "ServerEncrypted": bool,  # Optional.
                                      Required. Properties of a blob.
                                    "x-ms-blob-sequence-number": 0  # Optional.
                                      Required. Properties of a blob.
                                },
                                "Snapshot": "str"  # Required.
                            }
                        ],
                        "BlobPrefix": [
                            {
                                "Name": "str"  # Required.
                            }
                        ]
                    },
                    "ContainerName": "str",  # Required.
                    "Delimiter": "str",  # Required.
                    "Marker": "str",  # Required.
                    "MaxResults": 0,  # Required.
                    "NextMarker": "str",  # Required.
                    "Prefix": "str",  # Required.
                    "ServiceEndpoint": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        comp = kwargs.pop("comp", "list")  # type: str
        restype = kwargs.pop("restype", "container")  # type: str

        request = build_xml_list_blobs_request(
            comp=comp,
            restype=restype,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def json_input(  # pylint: disable=inconsistent-return-statements
        self, properties: JSONType, **kwargs: Any
    ) -> None:
        """A Swagger with XML that has one operation that takes JSON as input. You need to send the ID
        number 42.

        :param properties:
        :type properties: JSONType
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "id": 0  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        _json = properties

        request = build_xml_json_input_request(
            content_type=content_type,
            json=_json,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def json_output(self, **kwargs: Any) -> JSONType:
        """A Swagger with XML that has one operation that returns JSON. ID number 42.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "id": 0  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_json_output_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def get_xms_text(self, **kwargs: Any) -> JSONType:
        """Get back an XML object with an x-ms-text property, which should translate to the returned
        object's 'language' property being 'english' and its 'content' property being 'I am text'.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "content": "str",  # Optional. Returned value should be 'I am text'.
                    "language": "str"  # Optional. Returned value should be 'english'.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_xms_text_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def get_bytes(self, **kwargs: Any) -> JSONType:
        """Get an XML document with binary property.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Bytes": bytearray("bytearray", encoding="utf-8")  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_bytes_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def put_binary(  # pylint: disable=inconsistent-return-statements
        self, slideshow: JSONType, **kwargs: Any
    ) -> None:
        """Put an XML document with binary property.

        :param slideshow:
        :type slideshow: JSONType
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                slideshow = {
                    "Bytes": bytearray("bytearray", encoding="utf-8")  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        _content = slideshow

        request = build_xml_put_binary_request(
            content_type=content_type,
            content=_content,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_uri(self, **kwargs: Any) -> JSONType:
        """Get an XML document with uri property.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Url": str  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_uri_request()
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def put_uri(self, model: JSONType, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Put an XML document with uri property.

        :param model:
        :type model: JSONType
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                model = {
                    "Url": str  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        _content = model

        request = build_xml_put_uri_request(
            content_type=content_type,
            content=_content,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = await self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})
