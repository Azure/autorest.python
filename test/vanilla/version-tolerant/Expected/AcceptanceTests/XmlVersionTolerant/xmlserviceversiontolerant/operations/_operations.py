# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import functools
from typing import TYPE_CHECKING
import warnings
from xml.etree import ElementTree as ET

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from msrest import Serializer

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, List, Optional, TypeVar

    T = TypeVar("T")
    JSONType = Any
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False
# fmt: off

def build_xml_get_complex_type_ref_no_meta_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/complex-type-ref-no-meta')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_put_complex_type_ref_no_meta_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    # Construct URL
    url = kwargs.pop("template_url", '/xml/complex-type-ref-no-meta')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_get_complex_type_ref_with_meta_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/complex-type-ref-with-meta')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_put_complex_type_ref_with_meta_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    # Construct URL
    url = kwargs.pop("template_url", '/xml/complex-type-ref-with-meta')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_get_simple_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/simple')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_put_simple_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/simple')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_get_wrapped_lists_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/wrapped-lists')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_put_wrapped_lists_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/wrapped-lists')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_get_headers_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    # Construct URL
    url = kwargs.pop("template_url", '/xml/headers')

    return HttpRequest(
        method="GET",
        url=url,
        **kwargs
    )


def build_xml_get_empty_list_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/empty-list')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_put_empty_list_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    # Construct URL
    url = kwargs.pop("template_url", '/xml/empty-list')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_get_empty_wrapped_lists_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/empty-wrapped-lists')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_put_empty_wrapped_lists_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    # Construct URL
    url = kwargs.pop("template_url", '/xml/empty-wrapped-lists')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_get_root_list_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/root-list')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_put_root_list_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    # Construct URL
    url = kwargs.pop("template_url", '/xml/root-list')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_get_root_list_single_item_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/root-list-single-item')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_put_root_list_single_item_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    # Construct URL
    url = kwargs.pop("template_url", '/xml/root-list-single-item')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_get_empty_root_list_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/empty-root-list')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_put_empty_root_list_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    # Construct URL
    url = kwargs.pop("template_url", '/xml/empty-root-list')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_get_empty_child_element_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/empty-child-element')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_put_empty_child_element_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    # Construct URL
    url = kwargs.pop("template_url", '/xml/empty-child-element')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_list_containers_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    comp = kwargs.pop('comp', "list")  # type: str

    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/')

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_xml_get_service_properties_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    comp = kwargs.pop('comp', "properties")  # type: str
    restype = kwargs.pop('restype', "service")  # type: str

    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/')

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_xml_put_service_properties_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    comp = kwargs.pop('comp', "properties")  # type: str
    restype = kwargs.pop('restype', "service")  # type: str
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    # Construct URL
    url = kwargs.pop("template_url", '/xml/')

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_xml_get_acls_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    comp = kwargs.pop('comp', "acl")  # type: str
    restype = kwargs.pop('restype', "container")  # type: str

    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/mycontainer')

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_xml_put_acls_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    comp = kwargs.pop('comp', "acl")  # type: str
    restype = kwargs.pop('restype', "container")  # type: str
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    # Construct URL
    url = kwargs.pop("template_url", '/xml/mycontainer')

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_xml_list_blobs_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    comp = kwargs.pop('comp', "list")  # type: str
    restype = kwargs.pop('restype', "container")  # type: str

    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/mycontainer')

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_xml_json_input_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    # Construct URL
    url = kwargs.pop("template_url", '/xml/jsoninput')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_json_output_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/jsonoutput')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_get_xms_text_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/x-ms-text')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_get_bytes_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/bytes')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_put_binary_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/bytes')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_get_uri_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/url')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_xml_put_uri_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/xml/url')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )

# fmt: on
class XmlOperations(object):
    """XmlOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    @distributed_trace
    def get_complex_type_ref_no_meta(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> JSONType
        """Get a complex type that has a ref to a complex type with no XML node.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "RefToModel": {
                        "ID": "str"  # Optional. The id of the res.
                    },
                    "Something": "str"  # Optional. Something else (just to avoid flattening).
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_complex_type_ref_no_meta_request(
            template_url=self.get_complex_type_ref_no_meta.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_complex_type_ref_no_meta.metadata = {"url": "/xml/complex-type-ref-no-meta"}  # type: ignore

    @distributed_trace
    def put_complex_type_ref_no_meta(
        self,
        model,  # type: JSONType
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Puts a complex type that has a ref to a complex type with no XML node.

        :param model:
        :type model: JSONType
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                model = {
                    "RefToModel": {
                        "ID": "str"  # Optional. The id of the res.
                    },
                    "Something": "str"  # Optional. Something else (just to avoid flattening).
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        content = model

        request = build_xml_put_complex_type_ref_no_meta_request(
            content_type=content_type,
            content=content,
            template_url=self.put_complex_type_ref_no_meta.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_complex_type_ref_no_meta.metadata = {"url": "/xml/complex-type-ref-no-meta"}  # type: ignore

    @distributed_trace
    def get_complex_type_ref_with_meta(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> JSONType
        """Get a complex type that has a ref to a complex type with XML node.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "RefToModel": {
                        "ID": "str"  # Optional. The id of the res.
                    },
                    "Something": "str"  # Optional. Something else (just to avoid flattening).
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_complex_type_ref_with_meta_request(
            template_url=self.get_complex_type_ref_with_meta.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_complex_type_ref_with_meta.metadata = {"url": "/xml/complex-type-ref-with-meta"}  # type: ignore

    @distributed_trace
    def put_complex_type_ref_with_meta(
        self,
        model,  # type: JSONType
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Puts a complex type that has a ref to a complex type with XML node.

        :param model:
        :type model: JSONType
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                model = {
                    "RefToModel": {
                        "ID": "str"  # Optional. The id of the res.
                    },
                    "Something": "str"  # Optional. Something else (just to avoid flattening).
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        content = model

        request = build_xml_put_complex_type_ref_with_meta_request(
            content_type=content_type,
            content=content,
            template_url=self.put_complex_type_ref_with_meta.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_complex_type_ref_with_meta.metadata = {"url": "/xml/complex-type-ref-with-meta"}  # type: ignore

    @distributed_trace
    def get_simple(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> JSONType
        """Get a simple XML document.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "author": "str",  # Optional.
                    "date": "str",  # Optional.
                    "slides": [
                        {
                            "items": [
                                "str"  # Optional.
                            ],
                            "title": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "title": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_simple_request(
            template_url=self.get_simple.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_simple.metadata = {"url": "/xml/simple"}  # type: ignore

    @distributed_trace
    def put_simple(
        self,
        slideshow,  # type: JSONType
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Put a simple XML document.

        :param slideshow:
        :type slideshow: JSONType
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                slideshow = {
                    "author": "str",  # Optional.
                    "date": "str",  # Optional.
                    "slides": [
                        {
                            "items": [
                                "str"  # Optional.
                            ],
                            "title": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "title": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        content = slideshow

        request = build_xml_put_simple_request(
            content_type=content_type,
            content=content,
            template_url=self.put_simple.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_simple.metadata = {"url": "/xml/simple"}  # type: ignore

    @distributed_trace
    def get_wrapped_lists(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> JSONType
        """Get an XML document with multiple wrapped lists.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "BadApples": [
                        "str"  # Optional.
                    ],
                    "GoodApples": [
                        "str"  # Optional.
                    ]
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_wrapped_lists_request(
            template_url=self.get_wrapped_lists.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_wrapped_lists.metadata = {"url": "/xml/wrapped-lists"}  # type: ignore

    @distributed_trace
    def put_wrapped_lists(
        self,
        wrapped_lists,  # type: JSONType
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Put an XML document with multiple wrapped lists.

        :param wrapped_lists:
        :type wrapped_lists: JSONType
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                wrapped_lists = {
                    "BadApples": [
                        "str"  # Optional.
                    ],
                    "GoodApples": [
                        "str"  # Optional.
                    ]
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        content = wrapped_lists

        request = build_xml_put_wrapped_lists_request(
            content_type=content_type,
            content=content,
            template_url=self.put_wrapped_lists.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_wrapped_lists.metadata = {"url": "/xml/wrapped-lists"}  # type: ignore

    @distributed_trace
    def get_headers(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Get strongly-typed response headers.

        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_headers_request(
            template_url=self.get_headers.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["Custom-Header"] = self._deserialize("str", response.headers.get("Custom-Header"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    get_headers.metadata = {"url": "/xml/headers"}  # type: ignore

    @distributed_trace
    def get_empty_list(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> JSONType
        """Get an empty list.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "author": "str",  # Optional.
                    "date": "str",  # Optional.
                    "slides": [
                        {
                            "items": [
                                "str"  # Optional.
                            ],
                            "title": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "title": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_empty_list_request(
            template_url=self.get_empty_list.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_empty_list.metadata = {"url": "/xml/empty-list"}  # type: ignore

    @distributed_trace
    def put_empty_list(
        self,
        slideshow,  # type: JSONType
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Puts an empty list.

        :param slideshow:
        :type slideshow: JSONType
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                slideshow = {
                    "author": "str",  # Optional.
                    "date": "str",  # Optional.
                    "slides": [
                        {
                            "items": [
                                "str"  # Optional.
                            ],
                            "title": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "title": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        content = slideshow

        request = build_xml_put_empty_list_request(
            content_type=content_type,
            content=content,
            template_url=self.put_empty_list.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_empty_list.metadata = {"url": "/xml/empty-list"}  # type: ignore

    @distributed_trace
    def get_empty_wrapped_lists(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> JSONType
        """Gets some empty wrapped lists.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "BadApples": [
                        "str"  # Optional.
                    ],
                    "GoodApples": [
                        "str"  # Optional.
                    ]
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_empty_wrapped_lists_request(
            template_url=self.get_empty_wrapped_lists.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_empty_wrapped_lists.metadata = {"url": "/xml/empty-wrapped-lists"}  # type: ignore

    @distributed_trace
    def put_empty_wrapped_lists(
        self,
        apple_barrel,  # type: JSONType
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Puts some empty wrapped lists.

        :param apple_barrel:
        :type apple_barrel: JSONType
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                apple_barrel = {
                    "BadApples": [
                        "str"  # Optional.
                    ],
                    "GoodApples": [
                        "str"  # Optional.
                    ]
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        content = apple_barrel

        request = build_xml_put_empty_wrapped_lists_request(
            content_type=content_type,
            content=content,
            template_url=self.put_empty_wrapped_lists.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_empty_wrapped_lists.metadata = {"url": "/xml/empty-wrapped-lists"}  # type: ignore

    @distributed_trace
    def get_root_list(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> List[JSONType]
        """Gets a list as the root element.

        :return: list of JSON object
        :rtype: list[JSONType]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "expiration": "2020-02-20 00:00:00",  # Optional. The time at which you should reconsider eating this banana.
                        "flavor": "str",  # Optional.
                        "name": "str"  # Optional.
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[List[JSONType]]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_root_list_request(
            template_url=self.get_root_list.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_root_list.metadata = {"url": "/xml/root-list"}  # type: ignore

    @distributed_trace
    def put_root_list(
        self,
        bananas,  # type: List[JSONType]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Puts a list as the root element.

        :param bananas:
        :type bananas: list[JSONType]
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                bananas = [
                    {
                        "expiration": "2020-02-20 00:00:00",  # Optional. The time at which you should reconsider eating this banana.
                        "flavor": "str",  # Optional.
                        "name": "str"  # Optional.
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        serialization_ctxt = {"xml": {"name": "bananas", "wrapped": True, "itemsName": "banana"}}
        content = bananas

        request = build_xml_put_root_list_request(
            content_type=content_type,
            content=content,
            template_url=self.put_root_list.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_root_list.metadata = {"url": "/xml/root-list"}  # type: ignore

    @distributed_trace
    def get_root_list_single_item(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> List[JSONType]
        """Gets a list with a single item.

        :return: list of JSON object
        :rtype: list[JSONType]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "expiration": "2020-02-20 00:00:00",  # Optional. The time at which you should reconsider eating this banana.
                        "flavor": "str",  # Optional.
                        "name": "str"  # Optional.
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[List[JSONType]]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_root_list_single_item_request(
            template_url=self.get_root_list_single_item.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_root_list_single_item.metadata = {"url": "/xml/root-list-single-item"}  # type: ignore

    @distributed_trace
    def put_root_list_single_item(
        self,
        bananas,  # type: List[JSONType]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Puts a list with a single item.

        :param bananas:
        :type bananas: list[JSONType]
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                bananas = [
                    {
                        "expiration": "2020-02-20 00:00:00",  # Optional. The time at which you should reconsider eating this banana.
                        "flavor": "str",  # Optional.
                        "name": "str"  # Optional.
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        serialization_ctxt = {"xml": {"name": "bananas", "wrapped": True, "itemsName": "banana"}}
        content = bananas

        request = build_xml_put_root_list_single_item_request(
            content_type=content_type,
            content=content,
            template_url=self.put_root_list_single_item.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_root_list_single_item.metadata = {"url": "/xml/root-list-single-item"}  # type: ignore

    @distributed_trace
    def get_empty_root_list(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> List[JSONType]
        """Gets an empty list as the root element.

        :return: list of JSON object
        :rtype: list[JSONType]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "expiration": "2020-02-20 00:00:00",  # Optional. The time at which you should reconsider eating this banana.
                        "flavor": "str",  # Optional.
                        "name": "str"  # Optional.
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[List[JSONType]]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_empty_root_list_request(
            template_url=self.get_empty_root_list.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_empty_root_list.metadata = {"url": "/xml/empty-root-list"}  # type: ignore

    @distributed_trace
    def put_empty_root_list(
        self,
        bananas,  # type: List[JSONType]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Puts an empty list as the root element.

        :param bananas:
        :type bananas: list[JSONType]
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                bananas = [
                    {
                        "expiration": "2020-02-20 00:00:00",  # Optional. The time at which you should reconsider eating this banana.
                        "flavor": "str",  # Optional.
                        "name": "str"  # Optional.
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        serialization_ctxt = {"xml": {"name": "bananas", "wrapped": True, "itemsName": "banana"}}
        content = bananas

        request = build_xml_put_empty_root_list_request(
            content_type=content_type,
            content=content,
            template_url=self.put_empty_root_list.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_empty_root_list.metadata = {"url": "/xml/empty-root-list"}  # type: ignore

    @distributed_trace
    def get_empty_child_element(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> JSONType
        """Gets an XML document with an empty child element.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "expiration": "2020-02-20 00:00:00",  # Optional. The time at which you should reconsider eating this banana.
                    "flavor": "str",  # Optional.
                    "name": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_empty_child_element_request(
            template_url=self.get_empty_child_element.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_empty_child_element.metadata = {"url": "/xml/empty-child-element"}  # type: ignore

    @distributed_trace
    def put_empty_child_element(
        self,
        banana,  # type: JSONType
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Puts a value with an empty child element.

        :param banana:
        :type banana: JSONType
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                banana = {
                    "expiration": "2020-02-20 00:00:00",  # Optional. The time at which you should reconsider eating this banana.
                    "flavor": "str",  # Optional.
                    "name": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        content = banana

        request = build_xml_put_empty_child_element_request(
            content_type=content_type,
            content=content,
            template_url=self.put_empty_child_element.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_empty_child_element.metadata = {"url": "/xml/empty-child-element"}  # type: ignore

    @distributed_trace
    def list_containers(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> JSONType
        """Lists containers in a storage account.

        :keyword comp: The default value is "list". Note that overriding this default value may result
         in unsupported behavior.
        :paramtype comp: str
        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Containers": [
                        {
                            "Metadata": {
                                "str": "str"  # Optional. Dictionary of :code:`<string>`.
                            },
                            "Name": "str",  # Required.
                            "Properties": {
                                "Etag": "str",  # Required.
                                "Last-Modified": "2020-02-20 00:00:00",  # Required.
                                "LeaseDuration": "str",  # Optional. Possible values include: "infinite", "fixed".
                                "LeaseState": "str",  # Optional. Possible values include: "available", "leased", "expired", "breaking", "broken".
                                "LeaseStatus": "str",  # Optional. Possible values include: "locked", "unlocked".
                                "PublicAccess": "str"  # Optional. Possible values include: "container", "blob".
                            }
                        }
                    ],
                    "Marker": "str",  # Optional.
                    "MaxResults": 0,  # Required.
                    "NextMarker": "str",  # Required.
                    "Prefix": "str",  # Required.
                    "ServiceEndpoint": "str"  # Required.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        comp = kwargs.pop("comp", "list")  # type: str

        request = build_xml_list_containers_request(
            comp=comp,
            template_url=self.list_containers.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    list_containers.metadata = {"url": "/xml/"}  # type: ignore

    @distributed_trace
    def get_service_properties(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> JSONType
        """Gets storage service properties.

        :keyword comp: The default value is "properties". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype comp: str
        :keyword restype: The default value is "service". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype restype: str
        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Cors": [
                        {
                            "AllowedHeaders": "str",  # Required. the request headers that the origin domain may specify on the CORS request.
                            "AllowedMethods": "str",  # Required. The methods (HTTP request verbs) that the origin domain may use for a CORS request. (comma separated).
                            "AllowedOrigins": "str",  # Required. The origin domains that are permitted to make a request against the storage service via CORS. The origin domain is the domain from which the request originates. Note that the origin must be an exact case-sensitive match with the origin that the user age sends to the service. You can also use the wildcard character '*' to allow all origin domains to make requests via CORS.
                            "ExposedHeaders": "str",  # Required. The response headers that may be sent in the response to the CORS request and exposed by the browser to the request issuer.
                            "MaxAgeInSeconds": 0  # Required. The maximum amount time that a browser should cache the preflight OPTIONS request.
                        }
                    ],
                    "DefaultServiceVersion": "str",  # Optional. The default version to use for requests to the Blob service if an incoming request's version is not specified. Possible values include version 2008-10-27 and all more recent versions.
                    "DeleteRetentionPolicy": {
                        "Days": 0,  # Optional. Indicates the number of days that metrics or logging or soft-deleted data should be retained. All data older than this value will be deleted.
                        "Enabled": bool  # Required. Indicates whether a retention policy is enabled for the storage service.
                    },
                    "HourMetrics": {
                        "Enabled": bool,  # Required. Indicates whether metrics are enabled for the Blob service.
                        "IncludeAPIs": bool,  # Optional. Indicates whether metrics should generate summary statistics for called API operations.
                        "RetentionPolicy": {
                            "Days": 0,  # Optional. Indicates the number of days that metrics or logging or soft-deleted data should be retained. All data older than this value will be deleted.
                            "Enabled": bool  # Required. Indicates whether a retention policy is enabled for the storage service.
                        },
                        "Version": "str"  # Optional. The version of Storage Analytics to configure.
                    },
                    "Logging": {
                        "Delete": bool,  # Required. Indicates whether all delete requests should be logged.
                        "Read": bool,  # Required. Indicates whether all read requests should be logged.
                        "RetentionPolicy": {
                            "Days": 0,  # Optional. Indicates the number of days that metrics or logging or soft-deleted data should be retained. All data older than this value will be deleted.
                            "Enabled": bool  # Required. Indicates whether a retention policy is enabled for the storage service.
                        },
                        "Version": "str",  # Required. The version of Storage Analytics to configure.
                        "Write": bool  # Required. Indicates whether all write requests should be logged.
                    },
                    "MinuteMetrics": {
                        "Enabled": bool,  # Required. Indicates whether metrics are enabled for the Blob service.
                        "IncludeAPIs": bool,  # Optional. Indicates whether metrics should generate summary statistics for called API operations.
                        "RetentionPolicy": {
                            "Days": 0,  # Optional. Indicates the number of days that metrics or logging or soft-deleted data should be retained. All data older than this value will be deleted.
                            "Enabled": bool  # Required. Indicates whether a retention policy is enabled for the storage service.
                        },
                        "Version": "str"  # Optional. The version of Storage Analytics to configure.
                    }
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        comp = kwargs.pop("comp", "properties")  # type: str
        restype = kwargs.pop("restype", "service")  # type: str

        request = build_xml_get_service_properties_request(
            comp=comp,
            restype=restype,
            template_url=self.get_service_properties.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_service_properties.metadata = {"url": "/xml/"}  # type: ignore

    @distributed_trace
    def put_service_properties(
        self,
        properties,  # type: JSONType
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Puts storage service properties.

        :param properties:
        :type properties: JSONType
        :keyword comp: The default value is "properties". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype comp: str
        :keyword restype: The default value is "service". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype restype: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "Cors": [
                        {
                            "AllowedHeaders": "str",  # Required. the request headers that the origin domain may specify on the CORS request.
                            "AllowedMethods": "str",  # Required. The methods (HTTP request verbs) that the origin domain may use for a CORS request. (comma separated).
                            "AllowedOrigins": "str",  # Required. The origin domains that are permitted to make a request against the storage service via CORS. The origin domain is the domain from which the request originates. Note that the origin must be an exact case-sensitive match with the origin that the user age sends to the service. You can also use the wildcard character '*' to allow all origin domains to make requests via CORS.
                            "ExposedHeaders": "str",  # Required. The response headers that may be sent in the response to the CORS request and exposed by the browser to the request issuer.
                            "MaxAgeInSeconds": 0  # Required. The maximum amount time that a browser should cache the preflight OPTIONS request.
                        }
                    ],
                    "DefaultServiceVersion": "str",  # Optional. The default version to use for requests to the Blob service if an incoming request's version is not specified. Possible values include version 2008-10-27 and all more recent versions.
                    "DeleteRetentionPolicy": {
                        "Days": 0,  # Optional. Indicates the number of days that metrics or logging or soft-deleted data should be retained. All data older than this value will be deleted.
                        "Enabled": bool  # Required. Indicates whether a retention policy is enabled for the storage service.
                    },
                    "HourMetrics": {
                        "Enabled": bool,  # Required. Indicates whether metrics are enabled for the Blob service.
                        "IncludeAPIs": bool,  # Optional. Indicates whether metrics should generate summary statistics for called API operations.
                        "RetentionPolicy": {
                            "Days": 0,  # Optional. Indicates the number of days that metrics or logging or soft-deleted data should be retained. All data older than this value will be deleted.
                            "Enabled": bool  # Required. Indicates whether a retention policy is enabled for the storage service.
                        },
                        "Version": "str"  # Optional. The version of Storage Analytics to configure.
                    },
                    "Logging": {
                        "Delete": bool,  # Required. Indicates whether all delete requests should be logged.
                        "Read": bool,  # Required. Indicates whether all read requests should be logged.
                        "RetentionPolicy": {
                            "Days": 0,  # Optional. Indicates the number of days that metrics or logging or soft-deleted data should be retained. All data older than this value will be deleted.
                            "Enabled": bool  # Required. Indicates whether a retention policy is enabled for the storage service.
                        },
                        "Version": "str",  # Required. The version of Storage Analytics to configure.
                        "Write": bool  # Required. Indicates whether all write requests should be logged.
                    },
                    "MinuteMetrics": {
                        "Enabled": bool,  # Required. Indicates whether metrics are enabled for the Blob service.
                        "IncludeAPIs": bool,  # Optional. Indicates whether metrics should generate summary statistics for called API operations.
                        "RetentionPolicy": {
                            "Days": 0,  # Optional. Indicates the number of days that metrics or logging or soft-deleted data should be retained. All data older than this value will be deleted.
                            "Enabled": bool  # Required. Indicates whether a retention policy is enabled for the storage service.
                        },
                        "Version": "str"  # Optional. The version of Storage Analytics to configure.
                    }
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        comp = kwargs.pop("comp", "properties")  # type: str
        restype = kwargs.pop("restype", "service")  # type: str
        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        content = properties

        request = build_xml_put_service_properties_request(
            comp=comp,
            restype=restype,
            content_type=content_type,
            content=content,
            template_url=self.put_service_properties.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_service_properties.metadata = {"url": "/xml/"}  # type: ignore

    @distributed_trace
    def get_acls(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> List[JSONType]
        """Gets storage ACLs for a container.

        :keyword comp: The default value is "acl". Note that overriding this default value may result
         in unsupported behavior.
        :paramtype comp: str
        :keyword restype: The default value is "container". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype restype: str
        :return: list of JSON object
        :rtype: list[JSONType]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "AccessPolicy": {
                            "Expiry": "2020-02-20 00:00:00",  # Required. the date-time the policy expires.
                            "Permission": "str",  # Required. the permissions for the acl policy.
                            "Start": "2020-02-20 00:00:00"  # Required. the date-time the policy is active.
                        },
                        "Id": "str"  # Required. a unique id.
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[List[JSONType]]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        comp = kwargs.pop("comp", "acl")  # type: str
        restype = kwargs.pop("restype", "container")  # type: str

        request = build_xml_get_acls_request(
            comp=comp,
            restype=restype,
            template_url=self.get_acls.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_acls.metadata = {"url": "/xml/mycontainer"}  # type: ignore

    @distributed_trace
    def put_acls(
        self,
        properties,  # type: List[JSONType]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Puts storage ACLs for a container.

        :param properties:
        :type properties: list[JSONType]
        :keyword comp: The default value is "acl". Note that overriding this default value may result
         in unsupported behavior.
        :paramtype comp: str
        :keyword restype: The default value is "container". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype restype: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = [
                    {
                        "AccessPolicy": {
                            "Expiry": "2020-02-20 00:00:00",  # Required. the date-time the policy expires.
                            "Permission": "str",  # Required. the permissions for the acl policy.
                            "Start": "2020-02-20 00:00:00"  # Required. the date-time the policy is active.
                        },
                        "Id": "str"  # Required. a unique id.
                    }
                ]
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        comp = kwargs.pop("comp", "acl")  # type: str
        restype = kwargs.pop("restype", "container")  # type: str
        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        serialization_ctxt = {"xml": {"name": "SignedIdentifiers", "wrapped": True, "itemsName": "SignedIdentifier"}}
        content = properties

        request = build_xml_put_acls_request(
            comp=comp,
            restype=restype,
            content_type=content_type,
            content=content,
            template_url=self.put_acls.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_acls.metadata = {"url": "/xml/mycontainer"}  # type: ignore

    @distributed_trace
    def list_blobs(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> JSONType
        """Lists blobs in a storage container.

        :keyword comp: The default value is "list". Note that overriding this default value may result
         in unsupported behavior.
        :paramtype comp: str
        :keyword restype: The default value is "container". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype restype: str
        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Blobs": {
                        "Blob": [
                            {
                                "Deleted": bool,  # Required.
                                "Metadata": {
                                    "str": "str"  # Optional. Dictionary of :code:`<string>`.
                                },
                                "Name": "str",  # Required.
                                "Properties": {
                                    "AccessTier": "str",  # Optional. Possible values include: "P4", "P6", "P10", "P20", "P30", "P40", "P50", "Hot", "Cool", "Archive".
                                    "AccessTierInferred": bool,  # Optional. Required. Properties of a blob.
                                    "ArchiveStatus": "str",  # Optional. Possible values include: "rehydrate-pending-to-hot", "rehydrate-pending-to-cool".
                                    "BlobType": "str",  # Optional. Possible values include: "BlockBlob", "PageBlob", "AppendBlob".
                                    "Cache-Control": "str",  # Optional. Required. Properties of a blob.
                                    "Content-Disposition": "str",  # Optional. Required. Properties of a blob.
                                    "Content-Encoding": "str",  # Optional. Required. Properties of a blob.
                                    "Content-Language": "str",  # Optional. Required. Properties of a blob.
                                    "Content-Length": 0.0,  # Optional. Size in bytes.
                                    "Content-MD5": "str",  # Optional. Required. Properties of a blob.
                                    "Content-Type": "str",  # Optional. Required. Properties of a blob.
                                    "CopyCompletionTime": "2020-02-20 00:00:00",  # Optional. Required. Properties of a blob.
                                    "CopyId": "str",  # Optional. Required. Properties of a blob.
                                    "CopyProgress": "str",  # Optional. Required. Properties of a blob.
                                    "CopySource": "str",  # Optional. Required. Properties of a blob.
                                    "CopyStatus": "str",  # Optional. Possible values include: "pending", "success", "aborted", "failed".
                                    "CopyStatusDescription": "str",  # Optional. Required. Properties of a blob.
                                    "DeletedTime": "2020-02-20 00:00:00",  # Optional. Required. Properties of a blob.
                                    "DestinationSnapshot": "str",  # Optional. Required. Properties of a blob.
                                    "Etag": "str",  # Required.
                                    "IncrementalCopy": bool,  # Optional. Required. Properties of a blob.
                                    "Last-Modified": "2020-02-20 00:00:00",  # Required.
                                    "LeaseDuration": "str",  # Optional. Possible values include: "infinite", "fixed".
                                    "LeaseState": "str",  # Optional. Possible values include: "available", "leased", "expired", "breaking", "broken".
                                    "LeaseStatus": "str",  # Optional. Possible values include: "locked", "unlocked".
                                    "RemainingRetentionDays": 0,  # Optional. Required. Properties of a blob.
                                    "ServerEncrypted": bool,  # Optional. Required. Properties of a blob.
                                    "x-ms-blob-sequence-number": 0  # Optional. Required. Properties of a blob.
                                },
                                "Snapshot": "str"  # Required.
                            }
                        ],
                        "BlobPrefix": [
                            {
                                "Name": "str"  # Required.
                            }
                        ]
                    },
                    "ContainerName": "str",  # Required.
                    "Delimiter": "str",  # Required.
                    "Marker": "str",  # Required.
                    "MaxResults": 0,  # Required.
                    "NextMarker": "str",  # Required.
                    "Prefix": "str",  # Required.
                    "ServiceEndpoint": "str"  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        comp = kwargs.pop("comp", "list")  # type: str
        restype = kwargs.pop("restype", "container")  # type: str

        request = build_xml_list_blobs_request(
            comp=comp,
            restype=restype,
            template_url=self.list_blobs.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    list_blobs.metadata = {"url": "/xml/mycontainer"}  # type: ignore

    @distributed_trace
    def json_input(
        self,
        properties,  # type: JSONType
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """A Swagger with XML that has one operation that takes JSON as input. You need to send the ID
        number 42.

        :param properties:
        :type properties: JSONType
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "id": 0  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/json")  # type: Optional[str]

        json = properties

        request = build_xml_json_input_request(
            content_type=content_type,
            json=json,
            template_url=self.json_input.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    json_input.metadata = {"url": "/xml/jsoninput"}  # type: ignore

    @distributed_trace
    def json_output(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> JSONType
        """A Swagger with XML that has one operation that returns JSON. ID number 42.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "id": 0  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_json_output_request(
            template_url=self.json_output.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    json_output.metadata = {"url": "/xml/jsonoutput"}  # type: ignore

    @distributed_trace
    def get_xms_text(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> JSONType
        """Get back an XML object with an x-ms-text property, which should translate to the returned
        object's 'language' property being 'english' and its 'content' property being 'I am text'.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "content": "str",  # Optional. Returned value should be 'I am text'.
                    "language": "str"  # Optional. Returned value should be 'english'.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_xms_text_request(
            template_url=self.get_xms_text.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_xms_text.metadata = {"url": "/xml/x-ms-text"}  # type: ignore

    @distributed_trace
    def get_bytes(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> JSONType
        """Get an XML document with binary property.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Bytes": bytearray("bytearray", encoding="utf-8")  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_bytes_request(
            template_url=self.get_bytes.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_bytes.metadata = {"url": "/xml/bytes"}  # type: ignore

    @distributed_trace
    def put_binary(
        self,
        slideshow,  # type: JSONType
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Put an XML document with binary property.

        :param slideshow:
        :type slideshow: JSONType
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                slideshow = {
                    "Bytes": bytearray("bytearray", encoding="utf-8")  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        content = slideshow

        request = build_xml_put_binary_request(
            content_type=content_type,
            content=content,
            template_url=self.put_binary.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_binary.metadata = {"url": "/xml/bytes"}  # type: ignore

    @distributed_trace
    def get_uri(
        self, **kwargs  # type: Any
    ):
        # type: (...) -> JSONType
        """Get an XML document with uri property.

        :return: JSON object
        :rtype: JSONType
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Url": str  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[JSONType]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        request = build_xml_get_uri_request(
            template_url=self.get_uri.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = ET.fromstring(response.text())
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_uri.metadata = {"url": "/xml/url"}  # type: ignore

    @distributed_trace
    def put_uri(
        self,
        model,  # type: JSONType
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Put an XML document with uri property.

        :param model:
        :type model: JSONType
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                model = {
                    "Url": str  # Optional.
                }
        """
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}))

        content_type = kwargs.pop("content_type", "application/xml")  # type: Optional[str]

        content = model

        request = build_xml_put_uri_request(
            content_type=content_type,
            content=content,
            template_url=self.put_uri.metadata["url"],
        )
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_uri.metadata = {"url": "/xml/url"}  # type: ignore
